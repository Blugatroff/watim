import "../../std/core.watim" as Core
import "../../std/result.watim" as Result (Result(Error, Success))
import "../../std/bytes.watim" as Bytes
import "../../std/io.watim" as IO
import "../../std/maybe.watim" as Maybe (Maybe(None, Some), assert-some)
import "../../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../../std/array.watim" as Array (Array)
import "../../std/map.watim" as Map (Map)
import "../../std/arena.watim" as Arena (Arena)
import "../../std/fs.watim" as FS
import "../../std/util.watim" as Util (i32-format, bool-format)
import "../../std/fmt.watim" as Fmt (Formatter)
import "../../std/fmt-utils.watim" as Fmt
import "../../std/list.watim" as List (List)

import "../logging.watim" as Logging
import "../lexer.watim" as Lexer (
    Token, Token-lexeme, Token-location, Token-line, Token-column,
    Token-eq-to-lexeme, Token-eq-by-location, Token-string-content, Token-format
)
import "../parser.watim" as P

import "../resolving/module.watim" as Resolved
import "../resolving/top-items.watim" as Resolved (
    Struct, Variant, VariantCase,
    TypeDefinition(Struct, Variant), TypeDefinition-name,
    VariantCase-name, LocalName, LocalName-format, Global,
    Import, Extern, Signature)
import "../resolving/resolver.watim" as Resolved
import "../resolving/words.watim" as Resolved (
    ScopeId, ScopeId-format, LocalId, LocalId-format, LocalId-eq,
    FunctionHandle, VarId, VarId-format, GlobalId, GlobalId-format,
    StringWord, FunRef, Call,
)
import "../resolving/intrinsics.watim" as Resolved
import "../resolving/type.watim" as Type (
    Type(Bool, I8, I32, I64, Ptr, Custom, Fun, Tuple, Hole, Generic), Types-eq, Types-format,
    CustomTypeType, CustomTypeType-format,
    FunType, FunType-format, TupleType,
    NamedType, NamedType-format, NamedType-type, NamedType-contains-hole,
    ModuleId, CustomTypeHandle, CustomTypeHandle-eq, CustomTypeHandle-format
)
import "../resolving/type-lookup.watim" as TypeLookup (
    TypeLookup, Types-pretty-bracketed, CustomTypeType-pretty)

import "./ast.watim" as Ast (
    Module, FunctionOrExtern, Local, Local-format,
    Word, BlockAnnotation, FieldAccess,
    Scope, Function, FunctionOrExtern-signature,
    Match, MatchCase, If, Loop, Block,
    IndirectCall, VariantWord, UnpackTuple, MakeTuple, StructWord,
    StructWordNamed, Cast, Load, Intrinsic, IntrinsicWord,
    Flip, FieldInit, InitLocal, GetField, GetLocal,
    SetLocal, StoreLocal, RefLocal)
import "./intrinsics.watim" as Intrinsics

struct CheckError {
    module: ModuleId
    line: i32
    column: i32
    message: Array<i8>
}
fn CheckError-print(fd: i32, self: CheckError, modules: .Map<ByteSlice, P:Module>) -> i32 { block {
    &modules.keys $self.module.index Array:get<ByteSlice> @file-path
    $fd $file-path ~ ByteSlice:unpack IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd ":" IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.line IO:print Core:dup<i32> 0 /= if { break } drop
    $fd ":" IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.column IO:print Core:dup<i32> 0 /= if { break } drop
    $fd " " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd &self.message Array:unpack<_> IO:write-all
} }
fn error(ctx: .Ctx, token: .Token, message-ptr: .i8, message-len: i32) -> CheckError {
    $ctx.module-id $token Token-location $ctx.persistent $message-ptr $message-len Array:init<_> make CheckError
}
fn abort<T>(ctx: .Ctx, token: .Token, message-ptr: .i8, message-len: i32) -> Result<T, CheckError> {
    $ctx $token $message-ptr $message-len error
    make Result<T, CheckError>.Error
}
fn abort-m(ctx: .Ctx, token: .Token, message-ptr: .i8, message-len: i32) -> Maybe<CheckError> {
    $ctx.module-id $token Token-location $ctx.persistent $message-ptr $message-len Array:init<_> make CheckError
    make Maybe<CheckError>.Some
}

struct Ctx {
    temp: .Arena
    persistent: .Arena
    resolved-modules: .Map<ByteSlice, Resolved:Module>
    checked-modules: .Array<Module>
    signatures: .Array<Signature>
    globals: .Map<ByteSlice, Resolved:Global>
    // resolved-module: .Resolved:Module
    type-lookup: .TypeLookup
    module-id: ModuleId
}

fn resolved-module(ctx: .Ctx) -> .Resolved:Module {
    &ctx.resolved-modules.values $ctx.module-id.index Array:get<_>
}

fn check-modules(arena: .Arena, modules: .Map<ByteSlice, Resolved:Module>) -> Result<Map<ByteSlice, Module>, CheckError> {
    $arena \ByteSlice:eq-by-ref $modules.values.len Map:new-with-capacity<ByteSlice, Module> @checked-modules
    $arena Arena:temp @temp @save
    0 @id
    loop {
        $id $modules.keys.len = if { $checked-modules make Result<Map<ByteSlice, Module>, CheckError>.Success break }
        &modules.keys $id Array:get<ByteSlice> @module-path
        &modules.values $id Array:get<Resolved:Module> @module

        Logging:enabled if {
            2 "Checking module: " IO:write-all IO:check
            2 $module-path ~ ByteSlice:unpack IO:write-all IO:check
            2 "\n" IO:write-all IO:check
        }
        $temp Arena:save @save

        make TypeLookup {
            $id make ModuleId @module-id
            &module.type-definitions.values @types
            $modules @other-modules
        } @type-lookup

        $temp $module.functions.values.len Array:new-with-capacity<Signature> @signatures
        0 @i
        loop {
            $i $module.functions.values.len = if { break }
            &module.functions.values $i Array:get<_> Resolved:FunctionOrExtern-signature ~
            &signatures flip Array:push-assert-no-alloc<_>
            $i 1 + #i
        }

        make Ctx {
            $temp @temp
            $arena @persistent
            $modules @resolved-modules
            &checked-modules.values @checked-modules
            &signatures @signatures
            &module.globals @globals
            &type-lookup @type-lookup
            $type-lookup.module-id @module-id
        } @ctx

        &ctx &type-lookup forbid-directly-recursive-types match {
            case Some -> { make Result<Map<ByteSlice, Module>, CheckError>.Error break }
            case None -> {}
        }

        &ctx check-functions match {
            case Error -> { make Result<Map<ByteSlice, Module>, CheckError>.Error break }
            case Success -> {}
        } @functions

        &checked-modules $module-path ~
        make Module {
            $module-path @module-path
            $module.imports @imports
            $module.type-definitions @type-definitions
            $module.globals @globals
            $functions @functions
            $module.static-data @static-data
        } Map:insert-assert-no-alloc<ByteSlice, Module> Maybe:assert-none<_>


        $id 1 + #id
        $temp $save Arena:restore
    }
    $temp $save Arena:restore
}

fn forbid-directly-recursive-types(ctx: .Ctx, type-lookup: .TypeLookup) -> Maybe<CheckError> {
    0 @i
    loop {
        $i $type-lookup.types.len = if { make Maybe<CheckError>.None break }
        $type-lookup.module-id $i make CustomTypeHandle @handle
        $ctx $type-lookup &handle List:empty<CustomTypeHandle> @stack &stack is-directly-recursive if {
            $type-lookup &handle TypeLookup:lookup TypeDefinition-name @token
            $ctx $token "structs and variants cannot be recursive" abort-m break
        }
        $i 1 + #i
    }
}

fn is-directly-recursive(ctx: .Ctx, type-lookup: .TypeLookup, handle: .CustomTypeHandle, stack: .List<CustomTypeHandle>) -> bool { block {
    \CustomTypeHandle-eq $stack $handle List:contains<CustomTypeHandle> if {
        1 1 = break
    }
    $type-lookup $handle TypeLookup:lookup match {
        case Struct -> {
            @struc
            0 @i
            loop {
                $i $struc.fields.len = if { 0 1 = break }
                &struc.fields $i Array:get<NamedType> .type match {
                    case Type.Custom -> {
                        @custom-type
                        $handle ~ $stack List:cons<CustomTypeHandle> @stack'
                        $ctx $type-lookup &custom-type.type-definition &stack' is-directly-recursive if {
                            1 1 = break
                        }
                    }
                    case _ -> { drop }
                }
                $i 1 + #i
            }
        }
        case Variant -> {
            @varint
            0 @i
            loop {
                $i $varint.cases.len = if { 0 1 = break }
                &varint.cases $i Array:get<VariantCase> .type match {
                    case None -> {}
                    case Some -> { match {
                        case Type.Custom -> {
                            @custom-type
                            $handle ~ $stack List:cons<CustomTypeHandle> @stack'
                            $ctx $type-lookup &custom-type.type-definition &stack' is-directly-recursive if {
                                1 1 = break
                            }
                        }
                        case _ -> { drop }
                    } }
                }
                $i 1 + #i
            }
        }
    }
} }

fn check-functions(ctx: .Ctx) -> Result<Map<ByteSlice, FunctionOrExtern>, CheckError> {
    $ctx resolved-module @resolved-module
    $ctx.persistent \ByteSlice:eq-by-ref $resolved-module.functions.values.len
    Map:new-with-capacity<ByteSlice, FunctionOrExtern> @functions
    0 @i
    loop (-> Result<Map<ByteSlice, FunctionOrExtern>, CheckError>) {
        $resolved-module.functions.values.len $i = if {
            $functions make Result<Map<ByteSlice, FunctionOrExtern>, CheckError>.Success break
        }
        &resolved-module.functions.values $i Array:get<Resolved:FunctionOrExtern> match {
            case Resolved:FunctionOrExtern.Function -> {
                @fun
                Stack-new-root @stack

                $ctx.persistent \LocalId-eq $fun.locals.values.len Map:new-with-capacity<LocalId, Local> @locals
                0 @i
                loop {
                    $i $fun.locals.values.len = if { break }
                    &fun.locals.keys   $i Array:get<_> @local-id
                    &fun.locals.values $i Array:get<_> @locl
                    $locl.parameter match {
                        case None -> {}
                        case Some -> {
                            @parameter
                            make Local {
                                $locl.name @name
                                $parameter @type
                                1 1 = @is-parameter
                                0 1 = @reffed
                            }
                            &locals flip $local-id ~ flip Map:insert-assert-no-alloc<_, _> drop
                        }
                    }
                    $i 1 + #i
                }

                $ctx.temp $ctx &locals $ctx.type-lookup $ctx.signatures $ctx.globals WordCtx-new @word-ctx
                &word-ctx &stack &fun.body.words check-words match {
                    case Error -> { make Result<Map<ByteSlice, FunctionOrExtern>, CheckError>.Error break }
                    case Success -> {}
                } [,] @diverges @words
                $diverges not if {
                    &stack.positive &fun.signature.returns Types-eq not if {
                        $ctx.temp Fmt:into-new-string @msg @fmt
                        &fmt "unexpected return values:\n\texpected: " Fmt:write
                        &fmt $ctx.type-lookup &fun.signature.returns Types-pretty-bracketed
                        &fmt "\n\tactual:   " Fmt:write
                        &fmt $ctx.type-lookup &stack.positive Types-pretty-bracketed
                        $ctx &fun.name $msg Array:unpack<_> abort<Map<ByteSlice, FunctionOrExtern>> break
                    }
                }

                $fun.name $fun.export $fun.signature $locals
                $fun.body.id $words make Scope
                make Function make FunctionOrExtern.Function
                &functions flip
                &fun.name Token-lexeme make ByteSlice flip
                Map:insert-assert-no-alloc<ByteSlice, FunctionOrExtern> drop
            }
            case Resolved:FunctionOrExtern.Extern -> {
                @extrn
                &functions
                &extrn.name Token-lexeme make ByteSlice
                $extrn ~ make FunctionOrExtern.Extern
                Map:insert-assert-no-alloc<ByteSlice, FunctionOrExtern> drop
            }
        }
        $i 1 + #i
    }
}

struct BreakStack {
    token: Token
    types: Array<Type>
    reachable: bool
}

struct WordCtx {
    temp: .Arena
    persistent: .Arena
    ctx: .Ctx
    // imports: .Map<ByteSlice, Array<Import>>
    env: .Map<LocalId, Local>
    type-lookup: .TypeLookup
    ptr-I8: .Type
    ptr-I32: .Type
    I32: .Type
    Bool: .Type
    intrinsics: Map<Resolved:Intrinsic, IntrinsicGroupDescription>
    signatures: .Array<Signature>
    globals: .Map<ByteSlice, Global>
    struc-lit-ctx: Maybe<.Array<Type>>
    brek-stacks: Maybe<.Array<BreakStack>>
    blok-returns: Maybe<.Array<Type>>
    reachable: bool
}
fn WordCtx-new(temp: .Arena, ctx: .Ctx, env: .Map<LocalId, Local>, type-lookup: .TypeLookup, signatures: .Array<Signature>, globals: .Map<ByteSlice, Global>) -> WordCtx {
    $ctx.persistent make Type.I8 Arena:push<Type> @I8
    $ctx.persistent make Type.I32 Arena:push<Type> @I32
    $ctx.persistent $I8 make Type.Ptr Arena:push<Type> @ptr-I8
    $ctx.persistent $I32 make Type.Ptr Arena:push<Type> @ptr-I32
    $ctx.persistent make Type.Bool Arena:push<Type> @Bool
    make WordCtx {
        $temp @temp
        $ctx.persistent @persistent
        $ctx @ctx
        $env @env
        $type-lookup @type-lookup
        $signatures @signatures
        $globals @globals
        $ptr-I8 @ptr-I8
        $ptr-I32 @ptr-I32
        $I32 @I32
        $Bool @Bool
        $temp $ptr-I8 intrinsics @intrinsics
        make Maybe<.Array<Type>>.None @struc-lit-ctx
        make Maybe<.Array<BreakStack>>.None @brek-stacks
        make Maybe<.Array<Type>>.None @blok-returns
        1 1 = @reachable
    }
}
fn with-struc-lit-ctx(ctx: .WordCtx, struc-lit-ctx: .Array<Type>) -> WordCtx {
    $ctx ~ @new
    $struc-lit-ctx make Maybe<.Array<Type>>.Some #new.struc-lit-ctx
    $new
}
fn with-brek-stacks(ctx: .WordCtx, brek-stacks: .Array<BreakStack>, blok-returns: Maybe<.Array<Type>>) -> WordCtx {
    $ctx ~ @new
    $brek-stacks make Maybe<.Array<BreakStack>>.Some #new.brek-stacks
    $blok-returns #new.blok-returns
    $new
}

fn lookup-signature(ctx: .WordCtx, function: .FunctionHandle) -> .Signature {
    $function.module $ctx.ctx.module-id = if {
        $ctx.signatures $function.index Array:get<Signature>
    } else {
        $ctx.ctx.checked-modules $function.module.index Array:get<Module> @module
        &module.functions.values $function.index Array:get<FunctionOrExtern> FunctionOrExtern-signature
    }
}

fn check-words(ctx: .WordCtx, stack: .Stack, remaining-words: .Array<Resolved:Word>) -> Result<[Array<Word>, bool], CheckError> {
    0 1 = @diverges
    $ctx.persistent $remaining-words.len Array:new-with-capacity<Word> @resolved
    loop (-> Result<[Array<Word>, bool], CheckError>) {
        $remaining-words.len 0 = if { $resolved $diverges [,2] make Result<[Array<Word>, bool], CheckError>.Success break }
        $remaining-words Array:pop-front<Resolved:Word> @parsed-word
        $ctx $stack $remaining-words &resolved &parsed-word check-word match {
            case Error -> { make Result<[Array<Word>, bool], CheckError>.Error break }
            case Success -> {}
        }
        $diverges or #diverges
        $diverges not #ctx.reachable
    }
}

fn check-word(
    ctx: .WordCtx,
    stack: .Stack,
    remaining-words: .Array<Resolved:Word>,
    checked-words: .Array<Word>,
    word: .Resolved:Word
) -> Result<bool, CheckError> { block {
    $word match {
        case Resolved:Word.Number -> {
            $ctx $stack make Type.I32 push
            ~ make Word.Number 0 1 = [,2] make Result<[Word, bool], CheckError>.Success
        }
        case Resolved:Word.String -> {
            $ctx $stack $ctx.ptr-I8 ~ push
            $ctx $stack make Type.I32 push
            ~ make Word.String 0 1 = [,2] make Result<[Word, bool], CheckError>.Success
        }
        case Resolved:Word.GetLocal -> { $ctx flip $stack flip check-get-local }
        case Resolved:Word.RefLocal -> { $ctx flip $stack flip check-ref-local }
        case Resolved:Word.InitLocal -> { $ctx flip $stack flip check-init-local }
        case Resolved:Word.Call -> { $ctx flip $stack flip check-call }
        case Resolved:Word.Cast -> { $ctx flip $stack flip check-cast }
        case Resolved:Word.Sizeof -> {
            $ctx $stack make Type.I32 push
            ~ make Word.Sizeof 0 1 = [,2] make Result<[Word, bool], CheckError>.Success
        }
        case Resolved:Word.MakeStruct -> { $ctx flip $stack flip check-mk-struc }
        case Resolved:Word.MakeStructNamed -> { $ctx flip $stack flip check-mk-struc-named }
        case Resolved:Word.FunRef -> { $ctx flip $stack flip check-fun-ref }
        case Resolved:Word.If -> { $ctx flip $stack flip $remaining-words flip check-iff }
        case Resolved:Word.Loop -> { $ctx flip $stack flip check-lop }
        case Resolved:Word.Break -> { $ctx flip $stack flip check-brek }
        case Resolved:Word.SetLocal -> { $ctx flip $stack flip check-set-local }
        case Resolved:Word.Block -> { $ctx flip $stack flip check-blok }
        case Resolved:Word.IndirectCall -> { $ctx flip $stack flip check-indirect-call }
        case Resolved:Word.StoreLocal -> { $ctx flip $stack flip check-store }
        case Resolved:Word.Load -> { $ctx flip $stack flip check-load }
        case Resolved:Word.Match -> { $ctx flip $stack flip check-matsh }
        case Resolved:Word.MatchVoid -> { $ctx flip $stack flip check-matsh-void }
        case Resolved:Word.MakeVariant -> { $ctx flip $stack flip check-mk-varint }
        case Resolved:Word.GetField -> { $ctx flip $stack flip check-get-field }
        case Resolved:Word.MakeTuple -> { $ctx flip $stack flip check-mk-tuple }
        case Resolved:Word.UnpackTuple -> { $ctx flip $stack flip check-unpack-tuple }
        case Resolved:Word.Intrinsic -> { $ctx flip $stack flip check-intrinsics }
        case Resolved:Word.FieldInit -> { $ctx flip $stack flip check-field-init }
        case Resolved:Word.StackAnnotation -> { $ctx flip $stack flip check-stack-annotation break }
    } match {
        case Error -> { make Result<bool, CheckError>.Error }
        case Success -> {
            [,]
            flip $ctx.persistent flip $checked-words flip Array:push<Word>
            make Result<bool, CheckError>.Success
        }
    }
} }

variant IntrinsicReturns {
    case Constant -> Array<Intrinsics:Type>
    case Dynamic -> (.Arena, .Array<Type>, .Array<Type> -> Array<Type>)
}

struct IntrinsicDescription {
    parameters: Array<Intrinsics:Type>
    returns: IntrinsicReturns
    construct-intrinsic: (.Array<Type>, .Array<Type> -> Intrinsic)
}

struct IntrinsicGroupDescription {
    generic-arguments: i32
    parameter-count: i32
    overloadings: Array<IntrinsicDescription>
}

fn construct-gt(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Gt }
fn construct-ge(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Ge }
fn construct-lt(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Lt }
fn construct-le(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Le }
fn construct-mod(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Mod }
fn construct-add(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Add }
fn construct-sub(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Sub }
fn construct-mul(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Mul }
fn construct-div(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Div }
fn construct-eq(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Eq }
fn construct-not-eq(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.NotEq }
fn construct-uninit(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $generic-arguments 0 Array:get<_> ~ make Intrinsic.Uninit }
fn construct-uninit-returns(arena: .Arena, generic-arguments: .Array<Type>, params: .Array<Type>) -> Array<Type> { $arena $generic-arguments 0 Array:get<_> ~ Array:singleton<_> }
fn construct-drop(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Drop }
fn construct-flip(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ $params 1 Array:get<_> ~ make Flip make Intrinsic.Flip }
fn construct-store(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 1 Array:get<_> ~ make Intrinsic.Store }
fn construct-and(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.And }
fn construct-or(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Or }
fn construct-not(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Not }
fn construct-shr(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Shr }
fn construct-shl(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { $params 0 Array:get<_> ~ make Intrinsic.Shl }
fn construct-mem-copy(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { make Intrinsic.MemCopy }
fn construct-mem-fill(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { make Intrinsic.MemFill }
fn construct-mem-grow(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { make Intrinsic.MemGrow }
fn construct-set-stack-size(generic-arguments: .Array<Type>, params: .Array<Type>) -> Intrinsic { make Intrinsic.SetStackSize }

fn intrinsics(arena: .Arena, ptr-I8: .Type) -> Map<Resolved:Intrinsic, IntrinsicGroupDescription> {
    $arena \Resolved:Intrinsic-eq 24 Map:new-with-capacity<Resolved:Intrinsic, IntrinsicGroupDescription> @intrinsics

    &intrinsics make Resolved:Intrinsic.Gt make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 1 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.Bool Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-gt @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Ge make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 2 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I8 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I8 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.Bool Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-ge @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.Bool Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-ge @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Lt make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 1 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.Bool Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-lt @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Le make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 2 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I8 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I8 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.Bool Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-le @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.Bool Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-le @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Mod make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 2 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I32 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-mod @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I64 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I64 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I64 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-mod @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Sub make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 2 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I32 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-sub @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                $arena "a" make ByteSlice make Intrinsics:Type.MetaVar Arena:push<_> make Intrinsics:Type.Ptr @a
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters $a Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena $a Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-sub @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Add make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 2 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I32 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-add @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                $arena "a" make ByteSlice make Intrinsics:Type.MetaVar Arena:push<_> make Intrinsics:Type.Ptr @a
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters $a Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena $a Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-add @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Mul make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 1 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I32 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-mul @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Div make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 2 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I32 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-div @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I64 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I64 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I64 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-div @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Eq make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 1 Array:new-with-capacity<IntrinsicDescription> @overloadings

            "a" make ByteSlice make Intrinsics:Type.MetaVar @a

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters $a Array:push-assert-no-alloc<_>
                    &parameters $a Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.Bool Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-eq @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.NotEq make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 1 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                "a" make ByteSlice make Intrinsics:Type.MetaVar @a
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters $a Array:push-assert-no-alloc<_>
                    &parameters $a Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.Bool Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-not-eq @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Uninit make IntrinsicGroupDescription {
        1 @generic-arguments
        0 @parameter-count

        block {
            $arena 1 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                Array:new<Intrinsics:Type> @parameters
                \construct-uninit-returns make IntrinsicReturns.Dynamic @returns
                \construct-uninit @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Drop make IntrinsicGroupDescription {
        0 @generic-arguments
        1 @parameter-count

        block {
            $arena 1 Array:new-with-capacity<IntrinsicDescription> @overloadings

            "a" make ByteSlice make Intrinsics:Type.MetaVar @a

            &overloadings make IntrinsicDescription {
                block {
                    $arena 1 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters $a Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                Array:new<Intrinsics:Type> make IntrinsicReturns.Constant @returns
                \construct-drop @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Flip make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 1 Array:new-with-capacity<IntrinsicDescription> @overloadings

            "a" make ByteSlice make Intrinsics:Type.MetaVar @a
            "b" make ByteSlice make Intrinsics:Type.MetaVar @b

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters $a Array:push-assert-no-alloc<_>
                    &parameters $b Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters $b Array:push-assert-no-alloc<_>
                    &parameters $a Array:push-assert-no-alloc<_>
                    $parameters
                } make IntrinsicReturns.Constant @returns
                \construct-flip @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Store make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 1 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                "a" make ByteSlice make Intrinsics:Type.MetaVar @a
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters $arena $a Arena:push<_> make Intrinsics:Type.Ptr Array:push-assert-no-alloc<_>
                    &parameters $a Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                Array:new<Intrinsics:Type> make IntrinsicReturns.Constant @returns
                \construct-store @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.And make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 2 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.Bool Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.Bool Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.Bool Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-and @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I32 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-and @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Or make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 3 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.Bool Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.Bool Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.Bool Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-or @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I32 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-or @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I64 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I64 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I64 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-or @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Not make IntrinsicGroupDescription {
        0 @generic-arguments
        1 @parameter-count

        block {
            $arena 3 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 1 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.Bool Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.Bool Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-not @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                block {
                    $arena 1 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I32 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-not @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                block {
                    $arena 1 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I64 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I64 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-not @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Shr make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 2 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I32 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-shr @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I64 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I64 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I64 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-shr @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.Shl make IntrinsicGroupDescription {
        0 @generic-arguments
        2 @parameter-count

        block {
            $arena 2 Array:new-with-capacity<IntrinsicDescription> @overloadings

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I32 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-shl @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            &overloadings make IntrinsicDescription {
                block {
                    $arena 2 Array:new-with-capacity<Intrinsics:Type> @parameters
                    &parameters make Intrinsics:Type.I64 Array:push-assert-no-alloc<_>
                    &parameters make Intrinsics:Type.I64 Array:push-assert-no-alloc<_>
                    $parameters
                } @parameters
                $arena make Intrinsics:Type.I64 Array:singleton<_> make IntrinsicReturns.Constant @returns
                \construct-shl @construct-intrinsic
            } Array:push-assert-no-alloc<IntrinsicDescription>

            $overloadings
        } @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.MemGrow make IntrinsicGroupDescription {
        0 @generic-arguments
        1 @parameter-count
        $arena make IntrinsicDescription {
            $arena make Intrinsics:Type.I32 Array:singleton<Intrinsics:Type> @parameters
            $arena make Intrinsics:Type.I32 Array:singleton<Intrinsics:Type> make IntrinsicReturns.Constant @returns
            \construct-mem-grow @construct-intrinsic
        } Array:singleton<IntrinsicDescription> @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.MemCopy make IntrinsicGroupDescription {
        0 @generic-arguments
        3 @parameter-count
        $arena make IntrinsicDescription {
            block {
                $arena 3 Array:new-with-capacity<Intrinsics:Type> @parameters
                &parameters $arena make Intrinsics:Type.I8 Arena:push<_> make Intrinsics:Type.Ptr Array:push-assert-no-alloc<_>
                &parameters $arena make Intrinsics:Type.I8 Arena:push<_> make Intrinsics:Type.Ptr Array:push-assert-no-alloc<_>
                &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                $parameters
            } @parameters
            Array:new<Intrinsics:Type> make IntrinsicReturns.Constant @returns
            \construct-mem-copy @construct-intrinsic
        } Array:singleton<IntrinsicDescription> @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.MemFill make IntrinsicGroupDescription {
        0 @generic-arguments
        3 @parameter-count
        $arena make IntrinsicDescription {
            block {
                $arena 3 Array:new-with-capacity<Intrinsics:Type> @parameters
                &parameters $arena make Intrinsics:Type.I8 Arena:push<_> make Intrinsics:Type.Ptr Array:push-assert-no-alloc<_>
                &parameters make Intrinsics:Type.I8 Array:push-assert-no-alloc<_>
                &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                $parameters
            } @parameters
            Array:new<Intrinsics:Type> make IntrinsicReturns.Constant @returns
            \construct-mem-fill @construct-intrinsic
        } Array:singleton<IntrinsicDescription> @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    &intrinsics make Resolved:Intrinsic.SetStackSize make IntrinsicGroupDescription {
        0 @generic-arguments
        1 @parameter-count
        $arena make IntrinsicDescription {
            block {
                $arena 1 Array:new-with-capacity<Intrinsics:Type> @parameters
                &parameters make Intrinsics:Type.I32 Array:push-assert-no-alloc<_>
                $parameters
            } @parameters
            Array:new<Intrinsics:Type> make IntrinsicReturns.Constant @returns
            \construct-set-stack-size @construct-intrinsic
        } Array:singleton<IntrinsicDescription> @overloadings
    } Map:insert-assert-no-alloc<_, _> Maybe:assert-none<_>

    $intrinsics
}

fn check-intrinsic(
    ctx: .WordCtx,
    stack: .Stack,
    word: .Resolved:IntrinsicWord,
    intrinsic: .IntrinsicGroupDescription
) -> Result<[Word, bool], CheckError> { block (-> Result<[Word, bool], CheckError>) {
    $ctx.temp $intrinsic.parameter-count Array:new-with-capacity<Type> @arguments
    loop (-> Maybe<CheckError>) {
        $arguments.len $intrinsic.parameter-count = if {
            make Maybe<CheckError>.None break
        }
        $ctx $stack pop match {
            case None -> { $ctx.ctx &word.token "more expected" abort-m break }
            case Some -> {}
        } &arguments flip Array:push-assert-no-alloc<_>
    } match {
        case None -> {}
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
    }
    &arguments Array:reverse<_>

    $ctx.temp \ByteSlice:eq-by-ref 2 Map:new-with-capacity<ByteSlice, .Type> @meta-vars

    0 @i
    loop {
        $i $intrinsic.overloadings.len = if {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt "an intrinsic expected any of these stacks:" Fmt:write
            0 @i
            loop {
                $i $intrinsic.overloadings.len = if { break }
                &intrinsic.overloadings $i Array:get<_> @overload
                &fmt "\n  " Fmt:write
                &fmt \Intrinsics:Type-pretty &overload.parameters Array:format<_>
                $i 1 + #i
            }
            &fmt "\nbut got:\n  " Fmt:write
            &fmt $ctx.type-lookup &arguments TypeLookup:Types-pretty-bracketed
            $ctx.ctx &word.token $msg Array:unpack<_> abort<[Word, bool]> break
            $ctx.ctx &word.token
            $ctx.ctx &word.token "TODO: check-intrinsic" abort<[Word, bool]> break
            break
        }
        &intrinsic.overloadings $i Array:get<_> @overload
        &meta-vars &overload.parameters &arguments Intrinsics:Types-compare-to-actual if {
            $ctx $stack
            &overload.returns match {
                case Constant -> { $ctx.persistent flip &meta-vars flip Intrinsics:Types-fill }
                case Dynamic -> { ~ $ctx.persistent flip &word.generic-arguments flip &arguments flip -> }
            } & push-many

            $word.token &word.generic-arguments &arguments $overload.construct-intrinsic -> make IntrinsicWord
            make Word.Intrinsic 0 1 = [,2]
            make Result<[Word, bool], CheckError>.Success break
        }
        $i 1 + #i
    }
} }

fn check-intrinsics(ctx: .WordCtx, stack: .Stack, word: .Resolved:IntrinsicWord) -> Result<[Word, bool], CheckError> {
    &ctx.intrinsics
    &word.intrinsic
    Map:get<_, _> Maybe:assert-some<_>
    $ctx flip $stack flip $word flip check-intrinsic
}

fn maybeify(r: Result<[Word, bool], CheckError>) -> Result<Maybe<[Word, bool]>, CheckError> {
    $r match {
        case Success -> { make Maybe<[Word, bool]>.Some make Result<Maybe<[Word, bool]>, CheckError>.Success }
        case Error -> { make Result<Maybe<[Word, bool]>, CheckError>.Error }
    }
}

struct Stack {
    parent: Maybe<.Stack>
    positive: Array<Type>
    negative: Array<Type>
}
fn Stack-new-root() -> Stack {
    make Maybe<.Stack>.None Array:new<Type> Array:new<Type> make Stack
}
fn Stack-clone(arena: .Arena, self: .Stack) -> Stack {
    $self.parent match {
        case None -> { make Maybe<.Stack>.None }
        case Some -> { $arena flip Stack-clone $arena flip Arena:push<Stack> make Maybe<.Stack>.Some }
    }
    $arena &self.positive Array:clone<Type>
    $arena &self.negative Array:clone<Type>
    make Stack
}
fn push(ctx: .WordCtx, self: .Stack, type: Type) {
    $ctx.temp &self.positive $type Array:push<Type>
}
fn push-many(ctx: .WordCtx, self: .Stack, types: .Array<Type>) {
    0 @i
    loop {
        $i $types.len = if { break }
        $ctx $self $types $i Array:get<Type> ~ push
        $i 1 + #i
    }
}
fn pop(ctx: .WordCtx, self: .Stack) -> Maybe<Type> {
    $self.positive.len 0 = if {
        $self.parent match {
            case None -> { make Maybe<Type>.None }
            case Some -> {
                $ctx flip pop match {
                    case None -> { make Maybe<Type>.None }
                    case Some -> {
                        @type
                        $ctx.temp &self.negative $type Array:push<Type>
                        $type make Maybe<Type>.Some
                    }
                }
            }
        }
    } else {
        &self.positive Array:pop<Type> make Maybe<Type>.Some
    }
}
fn size(self: .Stack) -> i32 {
    $self.positive.len
    $self.parent match {
        case None -> {}
        case Some -> { size + }
    }
}
fn index(self: .Stack, index: i32) -> .Type {
    $index $self.positive.len lt if {
        &self.positive $self.positive.len $index - 1 - Array:get<Type>
    } else {
        $self.parent assert-some<.Stack> $index $self.positive.len - index
    }
}
fn dump(ctx: .WordCtx, self: .Stack) -> Array<Type> {
    $self size @size
    $ctx.temp $size Array:new-with-capacity<Type> @dump
    $size @i
    loop {
        $i 0 = if { break }
        $i 1 - #i
        $ctx.temp &dump $ctx $self pop assert-some<Type> Array:push<Type>
    }
    &dump Array:reverse<Type>
    $dump
}
fn maek-stacks-compatible(ctx: .WordCtx, a: .Stack, b: .Stack) -> bool {
    $ctx $a $b.positive.len use drop
    $ctx $b $a.positive.len use drop

    &a.positive &b.positive Types-eq
    &a.negative &b.negative Types-eq and
}
fn pop-n(ctx: .WordCtx, self: .Stack, n: i32) -> Array<Type> {
    $ctx.temp $n Array:new-with-capacity<Type> @popped
    loop (->) {
        $n 0 = if { break }
        $ctx.temp &popped
        $ctx $self pop match {
            case Some -> {}
            case None -> { break }
        } Array:push<Type>
        $n 1 - #n
    }
    &popped Array:reverse<Type>
    $popped
}
fn drop-n(ctx: .WordCtx, self: .Stack, n: i32) {
    loop {
        $n 0 = if { break }
        $ctx $self pop drop
        $n 1 - #n
    }
}
fn child(ctx: .WordCtx, self: .Stack) -> Stack {
    $ctx.temp $ctx.temp $self Stack-clone Arena:push<Stack> make Maybe<.Stack>.Some
    Array:new<Type>
    Array:new<Type>
    make Stack
}
fn use(ctx: .WordCtx, self: .Stack, n: i32) -> bool {
    $ctx.temp $n Array:new-with-capacity<Type> @popped
    loop (-> bool) {
        $popped.len $n = if { 1 1 = break }
        &popped $ctx $self pop match {
            case None -> { 0 1 = break }
            case Some -> {}
        } Array:push-assert-no-alloc<Type>
    }
    loop (->) {
        $popped.len 0 = if { break }
        $ctx.temp &self.positive
        &popped Array:pop<Type>
        Array:push<Type>
    }
}


fn stack-annotation-mismatch(ctx: .WordCtx, stack: .Stack, annotation: .Resolved:StackAnnotation) -> CheckError {
    $ctx.temp Fmt:into-new-string @msg @fmt
    &fmt "Stack doesn't match annotation:\n  actual:   [" Fmt:write
    $stack size $annotation.types.len 1 + gt if {
        &fmt "..., " Fmt:write
    }
    $ctx $stack $annotation.types.len 1 + pop-n @actual
    &fmt $ctx.type-lookup &actual TypeLookup:Types-pretty
    &fmt "]\n  expected: [" Fmt:write
    &fmt $ctx.type-lookup &annotation.types TypeLookup:Types-pretty
    &fmt "]\n" Fmt:write
    $ctx.ctx &annotation.token $msg Array:unpack<_> error
}

fn check-stack-annotation(ctx: .WordCtx, stack: .Stack, word: .Resolved:StackAnnotation) -> Result<bool, CheckError> { block {
    $word.types.len $stack size gt if {
        $ctx $stack $word stack-annotation-mismatch make Result<bool, CheckError>.Error break
    }
    0 @i
    loop {
        $word.types.len $i = if { 0 1 = make Result<bool, CheckError>.Success break }
        $stack $i index
        &word.types $word.types.len $i - 1 - Array:get<_> Type:eq not if {
            $ctx $stack $word stack-annotation-mismatch make Result<bool, CheckError>.Error break
        }
        $i 1 + #i
    }
} }

fn check-field-init(ctx: .WordCtx, stack: .Stack, word: .Resolved:FieldInit) -> Result<[Word, bool], CheckError> { block {
    $ctx.struc-lit-ctx Maybe:assert-some<_> @struc-lit-ctx

    $struc-lit-ctx $word.field-index Array:get<_> @type
    $ctx $stack &word.name $type "TODO" expect1 match {
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
        case None -> {}
    }

    $word.name $word.struc $type ~ $word.field-index make FieldInit make Word.FieldInit
    0 1 = [,2] make Result<[Word, bool], CheckError>.Success
} }

fn check-matsh-void(ctx: .WordCtx, stack: .Stack, word: .Token) -> Result<[Word, bool], CheckError> { block (-> Result<[Word, bool], CheckError>) {
    $ctx $stack $word "expected a value to match on" pop1 match {
        case Error -> { make Result<[Word, bool], CheckError>.Error break }
        case Success -> {}
    } & match {
        case Ptr -> { ~ }
        case _ -> {}
    } match {
        case Custom -> {
            @type
            $ctx.type-lookup &type.type-definition TypeLookup:lookup match {
                case Variant -> {}
                case _ -> { $ctx.ctx $word "can only match on variants" abort<[Word, bool]> break }
            }
        }
        case _ -> { drop $ctx.ctx $word "can only match on variants" abort<[Word, bool]> break }
    } @varint
    $varint.cases.len 0 /= if {
        $ctx.ctx $word "expected variant with zero cases" abort<[Word, bool]> break
    }
    $word ~ make Word.MatchVoid 1 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-matsh(ctx: .WordCtx, stack: .Stack, word: .Resolved:Match) -> Result<[Word, bool], CheckError> { block (-> Result<[Word, bool], CheckError>) {
    $ctx.persistent $word.cases.len 1 + Array:new-with-capacity<MatchCase> @cases
    1 1 = @match-diverges
    $ctx $stack &word.token "expected a value to match on" pop1 match {
        case Error -> { make Result<[Word, bool], CheckError>.Error break }
        case Success -> {}
    } @arg-item &arg-item match {
        case Ptr -> { ~ 1 1 = }
        case _ -> { 0 1 = }
    } @by-ref @arg
    $arg match {
        case Custom -> {
            @type
            $type
            $ctx.type-lookup &type.type-definition TypeLookup:lookup match {
                case Variant -> {}
                case _ -> {
                    $ctx.ctx &word.token "can only match on variants" abort<[Word, bool]> break
                }
            } $type.generic-arguments
        }
        case _ -> {
            drop $ctx.ctx &word.token "can only match on variants" abort<[Word, bool]> break
        }
    } @generic-arguments @varint ~ @varint-type

    $ctx.temp $varint.cases.len Array:new-with-capacity<bool> @visited-tags
    loop {
        $varint.cases.len $visited-tags.len = if { break }
        &visited-tags 0 1 = Array:push-assert-no-alloc<_>
    }

    $ctx.temp $varint.cases.len 1 + Array:new-with-capacity<[Stack, .Token, bool]> @case-stacks
    0 @i
    loop {
        $i $word.cases.len = if { make Maybe<CheckError>.None break }
        &word.cases $i Array:get<Resolved:MatchCase> @resolved-case
        &varint.cases $resolved-case.tag Array:get<VariantCase> .type @case-type
        $ctx $stack child @case-stack
        $case-type match {
            case None -> { make Maybe<Type>.None }
            case Some -> {
                $by-ref if { make Type.Ptr } else { ~ } @case-type
                $ctx.persistent &generic-arguments &case-type insert-generic-arguments @case-type
                $ctx &case-stack $case-type push
                $case-type make Maybe<Type>.Some
            }
        } @case-type
        $ctx &case-stack &resolved-case.body.words check-words match {
            case Error -> { make Maybe<CheckError>.Some break }
            case Success -> {}
        } [,] @case-diverges @words
        $case-diverges $match-diverges and #match-diverges
        &cases
        $case-type
        $resolved-case.tag
        $resolved-case.body.id $words make Scope
        make MatchCase Array:push-assert-no-alloc<MatchCase>

        &visited-tags $resolved-case.tag Array:get<_> @visited
        $visited ~ if {
            $ctx.temp Fmt:into-new-string @buf @fmt
            &fmt "duplicate case in match:\n\t" Fmt:write
            0 @i
            loop {
                $word.cases.len $i = if { Core:unreachable<.Token> break }
                &word.cases $i Array:get<_> @other-case
                $other-case.tag $resolved-case.tag = if {
                    &other-case.name break
                }
                $i 1 + #i
            } @other
            &fmt $other Token-line i32-format
            &fmt ":" Fmt:write
            &fmt $other Token-column i32-format
            &fmt " " Fmt:write
            &fmt $other Token-lexeme Fmt:write
            &fmt "\n\t" Fmt:write
            &fmt &resolved-case.name Token-line i32-format
            &fmt ":" Fmt:write
            &fmt &resolved-case.name Token-column i32-format
            &fmt " " Fmt:write
            &fmt &resolved-case.name Token-lexeme Fmt:write
            $ctx.ctx &word.token $buf Array:unpack<_> abort-m break
        }
        1 1 = =>visited

        &resolved-case.name Token-lexeme make ByteSlice @name
        &case-stacks $case-stack &resolved-case.name $case-diverges [,3] Array:push-assert-no-alloc<[Stack, .Token, bool]>
        $i 1 + #i
    } match {
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
        case None -> {}
    }
    &word.default match {
        case None -> {
            $ctx.temp Fmt:into-new-string @buf @fmt
            0 1 = @found-missing
            0 @tag
            loop {
                $visited-tags.len $tag = if { break }
                &visited-tags $tag Array:get<_> ~ not if {
                    $found-missing not if {
                        &fmt "missing case in match:" Fmt:write
                    }
                    &fmt "\n\t" Fmt:write
                    &fmt &varint.cases $tag Array:get<_> .name Token-lexeme Fmt:write
                    1 1 = #found-missing
                }
                $tag 1 + #tag
            }
            $found-missing if {
                $ctx.ctx &word.token $buf Array:unpack<_> abort<[Word, bool]> break
            }
            make Maybe<Scope>.None
        }
        case Some -> {
            @default
            $ctx $stack child @def-stack
            $ctx &def-stack $arg-item push
            $ctx &def-stack &default.body.words check-words match {
                case Error -> { make Result<[Word, bool], CheckError>.Error break }
                case Success -> {}
            } [,] @default-diverges $default.body.id flip make Scope make Maybe<Scope>.Some
            $match-diverges $default-diverges and #match-diverges

            &case-stacks $def-stack
            &default.underscore
            $default-diverges [,3] Array:push-assert-no-alloc<[Stack, .Token, bool]>
        }
    } @default

    0 @i
    make Maybe<Stack>.None @first-non-diverging-case
    loop {
        $case-stacks.len $i = if { make Maybe<CheckError>.None break }
        &case-stacks $i Array:get<[Stack, .Token, bool]> ~ [,] @case-diverges @case-token @case-stack
        $i 1 + #i
        $case-diverges not if {
            &first-non-diverging-case match {
                case None -> {
                    $case-stack make Maybe<Stack>.Some #first-non-diverging-case
                }
                case Some -> {
                    @first
                    $ctx $first &case-stack maek-stacks-compatible not if {
                        $ctx.temp Fmt:into-new-string @buf @fmt
                        &fmt "arms of match case have different types:" Fmt:write
                        0 @j
                        loop {
                            $j $case-stacks.len = if { break }
                            &fmt "\n\t" Fmt:write
                            &case-stacks $j Array:get<[Stack, .Token, bool]> ~ [,] drop @case-token @case-stack
                            &fmt $ctx.type-lookup &case-stack.negative Types-pretty-bracketed
                            &fmt " -> " Fmt:write
                            &fmt $ctx.type-lookup &case-stack.positive Types-pretty-bracketed
                            &fmt " in case " Fmt:write
                            &fmt $case-token Token-lexeme Fmt:write
                            $j 1 + #j
                        }
                        $ctx.ctx &word.token $buf Array:unpack<_> abort-m break
                    }
                }
            }
        }
    } match {
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
        case None -> {}
    }

    $case-stacks.len 0 = if {
        Array:new<Type> Array:new<Type>
    } else {
        &case-stacks 0 Array:get<[Stack, .Token, bool]> ~ [,] drop drop @most-params
        1 @i
        loop {
            $i $case-stacks.len = if { break }
            &case-stacks $i Array:get<[Stack, .Token, bool]> ~ [,] drop drop @case-stack
            $case-stack.negative.len
            $most-params.negative.len gt if {
                $case-stack #most-params
            }
            $i 1 + #i
        }
        $ctx.persistent &most-params.negative Array:clone<Type> @parameters
        &parameters Array:reverse<Type>

        // A case without any words, will just return any parameters it got.
        // So, to start, make the returns equal to the parameters.
        $ctx.persistent &parameters Array:clone<Type> @returns


        // Use the stack of the first non-diverging stack, to determine the 
        // return types of the match.
        0 @i
        loop {
            $i $case-stacks.len = if { break }
            &case-stacks $i Array:get<[Stack, .Token, bool]> ~ [,] @case-diverges drop @case-stack

            $case-diverges not if {
                // Since the returns start out being set to the parameters,
                // any actual parameter of the case, will pop one item from the returns.
                &returns $returns.len $case-stack.negative.len - Array:truncate<Type>

                // Any values produced by the case are return values of the match.
                $ctx.persistent &returns &case-stack.positive Array:append<Type>
                break
            }
            $i 1 + #i
        }
        $parameters
        $returns

    } @returns @parameters
    $ctx $stack &word.token &parameters expect match {
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
        case None -> {}
    }
    $ctx $stack &returns push-many
    make Match {
        $word.token @token
        $varint-type @varint
        $by-ref @by-ref
        $cases @cases
        $default @default
        $parameters @parameters
        $match-diverges if { make Maybe<Array<Type>>.None } else { $returns make Maybe<Array<Type>>.Some } @returns
    }
    make Word.Match $match-diverges [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn ifel-stack-mismatch-error(ctx: .WordCtx, word: .Resolved:If, true-stack: .Stack, false-stack: .Stack) -> CheckError {
    $ctx.temp Fmt:into-new-string @msg @fmt
    &fmt "stack mismatch between if and else branch:\n\tif   " Fmt:write
    &fmt $ctx.type-lookup &true-stack.positive Types-pretty-bracketed
    &fmt "\n\telse " Fmt:write
    &fmt $ctx.type-lookup &false-stack.positive Types-pretty-bracketed
    $ctx.ctx &word.token $msg Array:unpack<_> error
}

fn check-iff(ctx: .WordCtx, stack: .Stack, remaining-words: .Array<Resolved:Word>, word: .Resolved:If) -> Result<[Word, bool], CheckError> { block {
    $ctx $stack &word.token $ctx.Bool "expected a bool for `if`" expect1 match {
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
        case None -> {}
    }
    $ctx $stack child @true-stack
    $ctx $stack child @false-stack

    $ctx &true-stack &word.true-branch.words check-words match {
        case Error -> { make Result<[Word, bool], CheckError>.Error break }
        case Success -> {}
    } [,] @true-words-diverge @true-words

    &true-stack.negative @true-parameters

    Array:new<Resolved:Word> @empty-word-array
    $word.false-branch.words.len 0 = $true-words-diverge and if {
        $ctx $stack child @remaining-stack

        // This makes sure, that the parameters of the true-branch and
        // the synthesized false-branch made up of all subsequent words match.
        $ctx &remaining-stack $true-parameters.len use drop

        $ctx &remaining-stack $remaining-words check-words match {
            case Error -> { make Result<[Word, bool], CheckError>.Error break }
            case Success -> {}
        } [,] @remaining-words-diverge @remaining-words

        // This drop-n will always pop enough values from the parent stack
        // even for the true-branch, since the call to `use` above makes sure,
        // that the `negative` of `remaining-stack` is at least as long as
        // that of the true-branch.
        $ctx $stack $remaining-stack.negative.len drop-n

        // The true-branch diverges, so it doesn't produce any return values.
        // The remaining words however might, so push the results up!
        $ctx $stack &remaining-stack.positive push-many

        // Since we are synthesizing this false-branch because the true-branch
        // is diverging, the divergence of the remaining words
        // determines the divergence of the entire if.
        $remaining-words-diverge @diverges

        make If {
            $word.token @token
            $ctx.persistent &remaining-stack.negative Array:clone<Type> @parameters
            $diverges if {
                make Maybe<Array<Type>>.None
            } else {
                $ctx.persistent &remaining-stack.positive Array:clone<Type> make Maybe<Array<Type>>.Some
            } @returns
            $word.true-branch.id  $true-words      make Scope @true-branch
            $word.false-branch.id $remaining-words make Scope @false-branch
        } make Word.If $diverges [,2] make Result<[Word, bool], CheckError>.Success break
    }

    $ctx &false-stack &word.false-branch.words check-words match {
        case Error -> { make Result<[Word, bool], CheckError>.Error break }
        case Success -> {}
    } [,] @false-words-diverge @false-words

    $true-words-diverge not $false-words-diverge not and if {
        $ctx &true-stack &false-stack maek-stacks-compatible not if {
            $ctx $word &true-stack &false-stack ifel-stack-mismatch-error
            make Result<[Word, bool], CheckError>.Error break
        }
        // Because of `maek-stacks-compatible`, the stacks of both branches
        //  must have the same parameters, so always picking the true-stack here is fine.
        $ctx.persistent &true-stack.negative Array:clone<Type>
    } else {
        // Check that the parameters of both branches are the same,
        // or that on is the prefix of the other.
        0 @i
        loop {
            $i  $true-stack.negative.len =
            $i $false-stack.negative.len =
            or if { [,0] make Result<[], CheckError>.Success break }
            &true-stack.negative  $i Array:get<Type>
            &false-stack.negative $i Array:get<Type>
            Type:eq not if {
                $ctx $word &true-stack &false-stack ifel-stack-mismatch-error
                make Result<[], CheckError>.Error break
            }
            $i 1 + #i
        } match {
            case Success -> {}
            case Error -> { make Result<[Word, bool], CheckError>.Error break }
        } drop

        $ctx.persistent $true-stack.negative.len $false-stack.negative.len gt if {
            &true-stack.negative
        } else {
            &false-stack.negative
        } Array:clone<Type>
    } @parameters

    block {
         $true-words-diverge not if { $ctx.persistent  &true-stack.positive Array:clone<Type> make Maybe<Array<Type>>.Some break }
        $false-words-diverge not if { $ctx.persistent &false-stack.positive Array:clone<Type> make Maybe<Array<Type>>.Some break }
        make Maybe<Array<Type>>.None
    } @returns

    $true-stack.negative.len $false-stack.negative.len Core:max @param-count
    $true-words-diverge $false-words-diverge and if {
        // The if diverges, so pop the combined parameters of both branches from the parent.
        $ctx $stack $param-count drop-n
    } else {
        $ctx $stack &word.token &parameters expect match {
            case Some -> { make Result<[Word, bool], CheckError>.Error break }
            case None -> {}
        }
        &returns match {
            case Some -> { $ctx flip $stack flip push-many }
            case None -> {}
        }
    }
    $true-words-diverge $false-words-diverge and @diverges
    make If {
        $word.token @token
        $diverges @diverges
        $parameters @parameters
        $returns @returns
        $word.true-branch.id  $true-words  make Scope @true-branch
        $word.false-branch.id $false-words make Scope @false-branch
    } make Word.If $diverges [,2] make Result<[Word, bool], CheckError>.Success
} }

fn check-lop(ctx: .WordCtx, stack: .Stack, word: .Resolved:Loop) -> Result<[Word, bool], CheckError> { block {
    Array:new<BreakStack> @loop-break-stacks

    $ctx $stack child @loop-stack
    $ctx &loop-break-stacks &word.annotation match {
        case Some -> { .returns make Maybe<.Array<Type>>.Some }
        case None -> { make Maybe<.Array<Type>>.None }
    } with-brek-stacks @loop-ctx

    &loop-ctx &loop-stack &word.body.words check-words match {
        case Error -> { make Result<[Word, bool], CheckError>.Error break }
        case Success -> {}
    } [,] drop @words
    $loop-break-stacks.len 0 = @diverges

    $ctx.persistent &word.annotation match {
        case None -> { &loop-stack.negative }
        case Some -> { .parameters }
    } Array:clone<Type> @parameters

    $loop-break-stacks.len 0 /= if {
        &loop-break-stacks 0 Array:get<BreakStack> @first
        $first.reachable not #diverges

        1 @i
        loop {
            $i $loop-break-stacks.len = if { make Maybe<CheckError>.None break }
            &loop-break-stacks $i Array:get<BreakStack> @break-stack
            $i 1 + #i
            $break-stack.reachable not if { make Maybe<CheckError>.None break }
            \Type:eq &first.types &break-stack.types Array:eq<Type> not if {
                $ctx.temp Fmt:into-new-string @msg @fmt
                &fmt "break stack mismatch:" Fmt:write
                0 @i
                loop {
                    $i $loop-break-stacks.len = if { break }
                    &loop-break-stacks $i Array:get<BreakStack> @break-stack
                    &fmt "\n\t" Fmt:write
                    &fmt &break-stack.token Token-line i32-format
                    &fmt ":" Fmt:write
                    &fmt &break-stack.token Token-column i32-format
                    &fmt " " Fmt:write
                    &fmt $ctx.type-lookup &break-stack.types Types-pretty-bracketed
                    $i 1 + #i
                }
                $ctx.ctx &word.token $msg Array:unpack<_> abort-m break
            }
        } match {
            case None -> {}
            case Some -> { make Result<[Word, bool], CheckError>.Error break }
        }
    }

    // The parameters of the loop must match the values remaining on the
    // stack, at the end of the loop, to supply the next iteration.
    &parameters &loop-stack.positive Types-eq not if {
        $ctx.ctx &word.token "unexpected values remaining on stack at the end of loop" abort<[Word, bool]> break
    }

    &word.annotation match {
        case Some -> { .returns $ctx.persistent flip Array:clone<Type> }
        case None -> {
            $loop-break-stacks.len 0 = if {
                Array:new<Type>
            } else {
                &loop-break-stacks 0 Array:get<BreakStack> .types
                $ctx.persistent flip Array:clone<Type>
            }
        }
    } @returns

    $ctx $stack &word.token &parameters expect match {
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
        case None -> {}
    }
    $ctx $stack &returns push-many
    make Loop {
        $word.token @token
        $parameters @parameters
        $diverges if { make Maybe<Array<Type>>.None } else { $returns make Maybe<Array<Type>>.Some } @returns
        $word.body.id $words make Scope @body
    }
    make Word.Loop $diverges [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-brek(ctx: .WordCtx, stack: .Stack, token: .Token) -> Result<[Word, bool], CheckError> { block (-> Result<[Word, bool], CheckError>) {
    $ctx.persistent $ctx.blok-returns match {
        case None -> { $ctx $stack dump }
        case Some -> { .len ~ $ctx flip $stack flip pop-n }
    } @dump &dump Array:clone<Type> @dump
    $ctx.persistent
    $ctx.brek-stacks match {
        case None -> {
            $ctx.ctx $token "`break` can only be used inside of blocks and loops" abort<[Word, bool]> break
        }
        case Some -> {}
    }
    make BreakStack {
        $token ~ @token
        $dump @types
        $ctx.reachable @reachable
    }
    Array:push<BreakStack>
    $token ~ make Word.Break 1 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn brek-stack-mismatch-error(ctx: .WordCtx, token: .Token, brek-stacks: .Array<BreakStack>) -> CheckError {
    $ctx.temp Fmt:into-new-string @msg @fmt
    &fmt "break stack mismatch:" Fmt:write
    0 @i
    loop {
        $i $brek-stacks.len = if { break }
        $brek-stacks $i Array:get<BreakStack> @brek-stack
        &fmt "\n\t" Fmt:write
        &fmt &brek-stack.token Token-line i32-format
        &fmt ":" Fmt:write
        &fmt &brek-stack.token Token-column i32-format
        &fmt " " Fmt:write
        &fmt $ctx.type-lookup &brek-stack.types Types-pretty-bracketed
        $i 1 + #i
    }
    $ctx.ctx $token $msg Array:unpack<_> error
}

fn check-blok(ctx: .WordCtx, stack: .Stack, word: .Resolved:Block) -> Result<[Word, bool], CheckError> { block {
    Array:new<BreakStack> @block-break-stacks

    $ctx $stack child @block-stack
    $ctx &block-break-stacks &word.annotation match {
        case Some -> { .returns make Maybe<.Array<Type>>.Some }
        case None -> { make Maybe<.Array<Type>>.None }
    } with-brek-stacks @block-ctx

    &block-ctx &block-stack &word.body.words check-words match {
        case Error -> { make Result<[Word, bool], CheckError>.Error break }
        case Success -> {}
    } [,] @diverges @words
    $diverges not @block-end-is-reached

    $ctx.persistent &word.annotation match {
        case None -> { &block-stack.negative }
        case Some -> { .parameters }
    } Array:clone<Type> @parameters

    $block-break-stacks.len 0 /= if {
        &block-break-stacks 0 Array:get<BreakStack> @first
        $first.reachable not #diverges

        1 @i
        loop {
            $i $block-break-stacks.len = if { make Maybe<CheckError>.None break }
            &block-break-stacks $i Array:get<BreakStack> @break-stack
            $i 1 + #i
            $break-stack.reachable not if {
                1 1 = #diverges
                make Maybe<CheckError>.None break
            }
            &first.types &break-stack.types Types-eq not if {
                $block-end-is-reached if {
                    $ctx.persistent &block-break-stacks
                    $word.end $block-stack.positive $diverges make BreakStack
                    Array:push<BreakStack>
                }
                $ctx &word.token &block-break-stacks brek-stack-mismatch-error
                make Maybe<CheckError>.Some break
            }
        } match {
            case None -> {}
            case Some -> { make Result<[Word, bool], CheckError>.Error break }
        }
        $block-end-is-reached if {
            &block-stack.positive &first.types Types-eq not if {
                $ctx.persistent &block-break-stacks
                $word.end $block-stack.positive $diverges make BreakStack
                Array:push<BreakStack>
                $ctx &word.token &block-break-stacks brek-stack-mismatch-error
                make Result<[Word, bool], CheckError>.Error break
            }
        }
    }

    $ctx.persistent &word.annotation match {
        case Some -> { .returns }
        case None -> {
            $block-break-stacks.len 0 = if {
                &block-stack.positive
            } else {
                &block-break-stacks 0 Array:get<BreakStack> .types
            }
        }
    } Array:clone<Type> @returns
    $ctx $stack &word.token &parameters expect match {
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
        case None -> {}
    }
    $ctx $stack &returns push-many
    make Block {
        $word.token @token
        $parameters @parameters
        $returns @returns
        $word.body.id $words make Scope @body
    }
    make Word.Block $diverges [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-fun-ref(ctx: .WordCtx, stack: .Stack, word: .Resolved:FunRef) -> Result<[Word, bool], CheckError> { block {
    $ctx &word.call.function lookup-signature @signature
    $ctx.persistent &signature.parameters \NamedType-type Array:map<NamedType, Type> @parameters
    $ctx $stack $word.call.name $parameters $signature.returns make FunType make Type.Fun push
    $word.call make FunRef
    make Word.FunRef 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-indirect-call(ctx: .WordCtx, stack: .Stack, word: .Resolved:IndirectCall) -> Result<[Word, bool], CheckError> { block {
    $ctx $stack pop match {
        case None -> { $ctx.ctx &word.token "`->` expected a function on the stack, got: []" abort<[Word, bool]> break }
        case Some -> {}
    } @fun-type
    $fun-type match {
        case Fun -> {}
        case _ -> { 
            drop
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt "`->` expected a function on the stack, got: [" Fmt:write
            &fmt &fun-type Type:format
            &fmt "]" Fmt:write
            $ctx.ctx &word.token $msg Array:unpack<_> abort<[Word, bool]> break
        }
    } @fun-type
    $ctx $stack &word.token &fun-type.parameters expect match {
        case None -> {
            $ctx $stack &fun-type.returns 0 !.Array<Type> push-returns
        }
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
    }
    $word.token $fun-type make IndirectCall
    make Word.IndirectCall 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn push-returns(ctx: .WordCtx, stack: .Stack, returns: .Array<Type>, generic-arguments: .Array<Type>) {
    0 @i
    loop {
        $i $returns.len = if { break }
        $returns $i Array:get<Type> @return
        $generic-arguments 0 !.Array<Type> = if {
            $return ~
        } else {
            $ctx.persistent $generic-arguments $return insert-generic-arguments
        } @concrete-return-type
        $ctx $stack $concrete-return-type push
        $i 1 + #i
    }
}

fn check-mk-varint(ctx: .WordCtx, stack: .Stack, word: .Resolved:MakeVariant) -> Result<[Word, bool], CheckError> { block {
    $ctx.type-lookup &word.type.type-definition TypeLookup:lookup match {
        case Variant -> {}
        case Struct -> { drop Core:unreachable<.Variant> }
    } @varint
    &varint.cases $word.tag Array:get<VariantCase> @cays
    &cays.type match {
        case None -> {}
        case Some -> {
            ~ @cays-type
            $ctx.persistent &word.type.generic-arguments &cays-type insert-generic-arguments @expected
            $ctx $stack pop match {
                case None -> {
                    $ctx.temp Fmt:into-new-string @msg @fmt
                    &fmt "make " Fmt:write
                    &fmt $ctx.type-lookup &word.type CustomTypeType-pretty
                    &fmt "expected: " Fmt:write
                    &fmt $ctx.type-lookup &expected TypeLookup:pretty
                    &fmt " but stack is empty\n" Fmt:write
                    $ctx.ctx &word.token $msg Array:unpack<_> abort<[Word, bool]> break
                }
                case Some -> {
                    @actual
                    &actual &expected Type:eq not if {
                        $ctx.temp Fmt:into-new-string @msg @fmt
                        &fmt "make " Fmt:write
                        &fmt $ctx.type-lookup &word.type CustomTypeType-pretty
                        &fmt "expected:\n  " Fmt:write
                        &fmt $ctx.type-lookup &expected TypeLookup:pretty
                        &fmt "\nbut got:\n  " Fmt:write
                        &fmt $ctx.type-lookup &actual TypeLookup:pretty
                        $ctx.ctx &word.token $msg Array:unpack<_> abort<[Word, bool]> break
                    }
                }
            }
        }
    }
    $ctx $stack $word.type make Type.Custom push
    $word.token $word.tag $word.type make VariantWord
    make Word.VariantWord 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-unpack-tuple(ctx: .WordCtx, stack: .Stack, token: .Token) -> Result<[Word, bool], CheckError> { block {
    $ctx $stack pop match {
        case None -> { $ctx.ctx $token "expected a tuple on the stack" abort<[Word, bool]> break }
        case Some -> {}
    } @type
    $type match {
        case Tuple -> {}
        case _ -> { drop $ctx.ctx $token "expected a tuple on the stack" abort<[Word, bool]> break }
    } @tuple
    $ctx $stack &tuple.items push-many
    $token ~ $type
    make UnpackTuple make Word.UnpackTuple 0 1 = [,2] make Result<[Word, bool], CheckError>.Success
} }

fn check-mk-tuple(ctx: .WordCtx, stack: .Stack, word: .P:MakeTuple) -> Result<[Word, bool], CheckError> { block {
    &word.items Token-lexeme Util:parse @num-items
    $ctx.persistent $num-items Array:new-with-capacity<Type> @items
    loop {
        $items.len $num-items = if { make Maybe<CheckError>.None break }
        $ctx $stack pop match {
            case None -> { $ctx.ctx &word.token "expected more" abort-m break }
            case Some -> {}
        } $ctx.persistent flip &items flip Array:push<Type>
    } match {
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
        case None -> {}
    }
    &items Array:reverse<Type>
    $word.token $items make TupleType make Type.Tuple @type
    $ctx $stack $type push
    $word.token $type make MakeTuple
    make Word.MakeTuple 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-mk-struc(ctx: .WordCtx, stack: .Stack, word: .Resolved:MakeStruct) -> Result<[Word, bool], CheckError> { block {
    $ctx.type-lookup &word.type.type-definition TypeLookup:lookup match {
        case Struct -> {}
        case Variant -> { drop Core:unreachable<.Struct> }
    } @struc

    $ctx $stack $struc.fields.len pop-n @arguments
    $ctx &word.token &arguments &struc.fields &word.type.generic-arguments infer-generic-arguments-from-args match {
        case None -> {}
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
    }
    $ctx $stack $word.type make Type.Custom push
    $word.token $word.type make StructWord make Word.StructWord 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-mk-struc-named(ctx: .WordCtx, stack: .Stack, word: .Resolved:MakeStructNamed) -> Result<[Word, bool], CheckError> { block {
    $ctx.type-lookup &word.type.type-definition TypeLookup:lookup match {
        case Struct -> {}
        case Variant -> { drop Core:unreachable<.Struct> }
    } @struc
    $ctx.temp $struc.fields.len Array:new-with-capacity<Type> @fields
    loop {
        $struc.fields.len $fields.len = if { break }
        &struc.fields $fields.len Array:get<NamedType> @field
        &fields
        $ctx.persistent &word.type.generic-arguments &field.type insert-generic-arguments
        Array:push-assert-no-alloc<_>
    }
    $ctx &fields with-struc-lit-ctx @child-ctx
    &child-ctx $stack &word.body.words check-words match {
        case Error -> { make Result<[Word, bool], CheckError>.Error break }
        case Success -> {}
    } [,] @diverges @body
    $ctx $stack $word.type make Type.Custom push

    $word.token $word.type $word.body.id $body make Scope
    make StructWordNamed make Word.StructWordNamed
    $diverges [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-cast(ctx: .WordCtx, stack: .Stack, cast: .Resolved:Cast) -> Result<[Word, bool], CheckError> { block {
    $ctx $stack pop match {
        case None -> { $ctx.ctx &cast.token "cast expected an item" abort<[Word, bool]> break }
        case Some -> {}
    }
    $ctx $stack $cast.dst push
    $cast.token flip
    $cast.dst
    make Cast
    make Word.Cast 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-load(ctx: .WordCtx, stack: .Stack, word: .Resolved:Load) -> Result<[Word, bool], CheckError> { block {
    $ctx $stack pop match {
        case None -> { $ctx.ctx &word.token "`~` expected a ptr, got: []" abort<[Word, bool]> break }
        case Some -> {}
    } match {
        case Ptr -> {}
        case _ -> {
            @actual
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt "~` expected a ptr, got: [" Fmt:write
            &fmt $ctx.type-lookup &actual TypeLookup:pretty
            &fmt "]" Fmt:write
            $ctx.ctx &word.token $msg Array:unpack<_> abort<[Word, bool]> break
        }
    } @type
    $ctx $stack $type ~ push
    $word.token $type ~ make Load
    make Word.Load 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-call(ctx: .WordCtx, stack: .Stack, word: .Resolved:Call) -> Result<[Word, bool], CheckError> { block {
    $ctx &word.function lookup-signature @signature

    $signature.generic-parameters.len $word.generic-arguments.len /= if {
        $ctx.ctx &word.name $signature.generic-parameters.len $word.generic-arguments.len generic-arguments-mismatch-error
        make Result<[Word, bool], CheckError>.Error break
    }

    $ctx $stack $signature.parameters.len pop-n @args

    $ctx &word.name &args &signature.parameters &word.generic-arguments infer-generic-arguments-from-args match {
        case None -> {}
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
    }
    $ctx $stack &signature.returns &word.generic-arguments push-returns

    $word ~ make Word.Call 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success break
} }

fn parameter-argument-mismatch-error(ctx: .WordCtx, token: .Token, arguments: .Array<Type>, parameters: .Array<NamedType>, generic-arguments: .Array<Type>) -> Maybe<CheckError> {
    $ctx.temp $generic-arguments
    $ctx.temp $parameters \NamedType-type Array:map<NamedType, Type> @parameters
    &parameters insert-generic-arguments-all @parameters
    $ctx $token &parameters $arguments type-mismatch-error
}

fn infer-generic-arguments-from-args(
    ctx: .WordCtx,
    token: .Token,
    arguments: .Array<Type>,
    parameters: .Array<NamedType>,
    generic-arguments: .Array<Type>
) -> Maybe<CheckError> { block {
    1 @i
    \Token-eq-by-location Map:new<Token, .Type> @hole-mapping
    loop {
        $i $parameters.len gt if { make Maybe<CheckError>.None break }
        $parameters $parameters.len $i - Array:get<NamedType> .type @parameter
        $arguments.len $i lt if {
            $ctx $token $arguments $parameters $generic-arguments parameter-argument-mismatch-error break
        }
        $arguments $arguments.len $i - Array:get<Type> @argument
        $ctx.persistent $generic-arguments $parameter insert-generic-arguments @parameter

        $ctx &hole-mapping $token $argument &parameter infer-holes match {
            case Error -> { make Maybe<CheckError>.Some break }
            case Success -> {}
        } not if {
            $ctx $token $arguments $parameters $generic-arguments parameter-argument-mismatch-error break
        }
        $i 1 + #i
    } match {
        case None -> {}
        case _ -> { break }
    }

    0 @i
    loop {
        $i $generic-arguments.len = if { make Maybe<CheckError>.None break }
        $generic-arguments $i Array:get<Type> @generic-argument
        $ctx &hole-mapping $generic-argument fill-holes match {
            case Error -> { make Maybe<CheckError>.Some break }
            case Success -> {}
        } =>generic-argument
        $i 1 + #i
    } match {
        case None -> {}
        case _ -> { break }
    }


    $generic-arguments \Type:find-hole Array:findMap<Type, .Token> match {
        case None -> { make Maybe<CheckError>.None }
        case Some -> {
            $ctx.ctx flip "failed to infer type for hole" abort-m
        }
    }
} }

fn insert-generic-arguments(arena: .Arena, generic-arguments: .Array<Type>, type: .Type) -> Type {
    $type match {
        case Hole -> {
            // A parameter cannot contain holes, "fn foo(a: _) {}" is not allowed
            drop 0 0 / drop
            Core:unreachable<Type>
        }
        case Generic -> {
            @generic
            $generic-arguments $generic.index Array:get<Type> ~
        }
        case Bool -> { $type ~ }
        case I8 -> { $type ~ }
        case I32 -> { $type ~ }
        case I64 -> { $type ~ }
        case Ptr -> { ~ $arena flip $generic-arguments flip insert-generic-arguments $arena flip Arena:push<Type> make Type.Ptr }
        case Custom -> {
            @type
            $type.type-definition
            $arena $generic-arguments &type.generic-arguments insert-generic-arguments-all
            make CustomTypeType make Type.Custom
        }
        case Fun -> {
            @fun
            $fun.token
            $arena $generic-arguments &fun.parameters insert-generic-arguments-all
            $arena $generic-arguments &fun.returns    insert-generic-arguments-all
            make FunType make Type.Fun
        }
        case Tuple -> {
            @tuple
            $tuple.token
            $arena $generic-arguments &tuple.items insert-generic-arguments-all
            make TupleType make Type.Tuple
        }
    }
}
fn insert-generic-arguments-all(arena: .Arena, generic-arguments: .Array<Type>, types: .Array<Type>) -> Array<Type> {
    $arena $types.len Array:new-with-capacity<Type> @res
    0 @i
    loop {
        $i $types.len = if { $res break }
        &res
        $arena $generic-arguments $types $i Array:get<Type> insert-generic-arguments
        Array:push-assert-no-alloc<Type>
        $i 1 + #i
    }
}

fn infer-holes(ctx: .WordCtx, mapping: .Map<Token, .Type>, token: .Token, actual: .Type, holy: .Type) 
    -> Result<bool, CheckError> { block (-> Result<bool, CheckError>) {
    $actual match {
        case Hole -> {
            drop 0 0 / drop
            // A type on the stack cannot contain holes, not yet anyway.
            // Once bidirectional type checking is implemented, this will change, somehow
        }
        case _ -> { drop }
    }
    $holy match {
        case Hole -> {
            ~ @hole
            $ctx.temp $mapping $hole $actual Map:insert<Token, .Type> match {
                case None -> {}
                case Some -> {
                    @previously-inferred
                    $previously-inferred $actual Type:eq not if {
                        $ctx.temp Fmt:into-new-string @msg @fmt
                        &fmt "Failed to infer type for hole, contradicting types inferred:\n" Fmt:write
                        &fmt "inferred now:        " Fmt:write
                        &fmt $ctx.type-lookup $actual TypeLookup:pretty
                        &fmt "\ninferred previously: " Fmt:write
                        &fmt $ctx.type-lookup $previously-inferred TypeLookup:pretty
                        &fmt "\n" Fmt:write
                        $ctx.ctx &hole $msg Array:unpack<_> abort<bool> break
                    }
                }
            }
        }
        case Bool -> { $actual match {
            case Bool -> {}
            case _ -> { 0 1 = make Result<bool, CheckError>.Success break }
        } }
        case I8 -> { $actual match {
            case I8 -> {}
            case _ -> { 0 1 = make Result<bool, CheckError>.Success break }
        } }
        case I32 -> { $actual match {
            case I32 -> {}
            case _ -> { 0 1 = make Result<bool, CheckError>.Success break }
        } }
        case I64 -> { $actual match {
            case I64 -> {}
            case _ -> { 0 1 = make Result<bool, CheckError>.Success break }
        } }
        case Generic -> { ~ @holy $actual match {
            case Generic -> {
                ~ @actual
                $holy.index $actual.index /= if {
                    0 1 = make Result<bool, CheckError>.Success break
                }
            }
            case _ -> { 0 1 = make Result<bool, CheckError>.Success break }
        } }
        case Ptr -> { ~ @holy $actual match {
            case Ptr -> {
                ~ @actual
                $ctx $mapping $token $actual $holy infer-holes break
            }
            case _ -> { 0 1 = make Result<bool, CheckError>.Success break }
        } }
        case Tuple -> { ~ @holy $actual match {
            case Tuple -> {
                ~ @actual
                $ctx $mapping $token &actual.items &holy.items infer-holes-all break
            }
            case _ -> { 0 1 = make Result<bool, CheckError>.Success break }
        } }
        case Fun -> { ~ @holy $actual match {
            case Fun -> {
                ~ @actual
                $ctx $mapping $token &actual.parameters &holy.parameters infer-holes-all match {
                    case Error -> { make Result<bool, CheckError>.Error break }
                    case Success -> { if { } else { 0 1 = make Result<bool, CheckError>.Success break } }
                }
                $ctx $mapping $token &actual.returns &holy.returns infer-holes-all break
            }
            case _ -> { 0 1 = make Result<bool, CheckError>.Success break }
        } }
        case Custom -> { @holy $actual match {
            case Custom -> {
                @actual
                $holy.type-definition $actual.type-definition = if {
                    $ctx $mapping $token &actual.generic-arguments &holy.generic-arguments infer-holes-all break
                } else {
                    0 1 = make Result<bool, CheckError>.Success break
                }
            }
            case _ -> { 0 1 = make Result<bool, CheckError>.Success break }
        } }
    }
    1 1 = make Result<bool, CheckError>.Success
} }

fn infer-holes-all(ctx: .WordCtx, mapping: .Map<Token, .Type>, token: .Token, actual: .Array<Type>, holy: .Array<Type>) -> Result<bool, CheckError> {
    $actual.len $holy.len /= if { 0 0 / drop }
    1 1 = @actuals-correct
    0 @i
    loop {
        $i $actual.len = if { $actuals-correct make Result<bool, CheckError>.Success break }
        $ctx $mapping $token
        $actual $i Array:get<Type>
        $holy $i Array:get<Type>
        infer-holes match {
            case Error -> { make Result<bool, CheckError>.Error break }
            case Success -> { $actuals-correct and #actuals-correct }
        }
        $i 1 + #i
    }
}

fn fill-holes(ctx: .WordCtx, mapping: .Map<Token, .Type>, type: .Type) -> Result<Type, CheckError> { block (-> Result<Type, CheckError>) {
    $type match {
        case Hole -> {
            @hole
            $mapping $hole Map:get<Token, .Type> match {
                case None -> {
                    $ctx.ctx $hole "failed to infer type for hole" abort<Type> break
                }
                case Some -> { ~ ~ }
            }
        }
        case Ptr -> {
            ~ $ctx flip $mapping flip fill-holes match {
                case Success -> { $ctx.persistent flip Arena:push<Type> make Type.Ptr }
                case _ -> { break }
            }
        }
        case Tuple -> {
            @tuple
            $tuple.token
            $ctx $mapping &tuple.items fill-holes-all match {
                case Success -> { make TupleType make Type.Tuple }
                case Error -> { make Result<Type, CheckError>.Error break }
            }
        }
        case Fun -> {
            @fun
            $fun.token
            $ctx $mapping &fun.parameters fill-holes-all match {
                case Error -> { make Result<Type, CheckError>.Error break }
                case Success -> {}
            }
            $ctx $mapping &fun.returns    fill-holes-all match {
                case Error -> { make Result<Type, CheckError>.Error break }
                case Success -> {}
            }
            make FunType make Type.Fun
        }
        case Custom -> {
            @custom
            $custom.type-definition
            $ctx $mapping &custom.generic-arguments fill-holes-all match {
                case Error -> { make Result<Type, CheckError>.Error break }
                case Success -> {}
            }
            make CustomTypeType make Type.Custom
        }
        case Bool -> { $type ~ }
        case I8 -> { $type ~ }
        case I32 -> { $type ~ }
        case I64 -> { $type ~ }
        case Generic -> { drop $type ~ }
    } make Result<Type, CheckError>.Success
} }

fn fill-holes-all(ctx: .WordCtx, mapping: .Map<Token, .Type>, types: .Array<Type>) -> Result<Array<Type>, CheckError> {
    $ctx.persistent $types.len Array:new-with-capacity<Type> @filled
    0 @i
    loop (-> Result<Array<Type>, CheckError>) {
        $i $types.len = if { $filled make Result<Array<Type>, CheckError>.Success break }
        &filled $ctx $mapping $types $i Array:get<Type> fill-holes match {
            case Success -> {}
            case Error -> { make Result<Array<Type>, CheckError>.Error break }
        } Array:push-assert-no-alloc<Type>
        $i 1 + #i
    }
}

fn function-not-found-error(ctx: .Ctx, name: .Token) -> CheckError {
    $ctx.temp Fmt:into-new-string @buf @fmt
    &fmt "function `" Fmt:write
    &fmt $name Token-lexeme Fmt:write
    &fmt "` not found" Fmt:write
    $ctx $name $buf Array:unpack<_> error
}

fn pop1(ctx: .WordCtx, stack: .Stack, token: .Token, expected-ptr: .i8, expected-len: i32) -> Result<Type, CheckError> { block {
    $ctx $stack pop match {
        case None -> {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt $expected-ptr $expected-len Fmt:write
            &fmt ", got: []" Fmt:write
            $ctx.ctx $token $msg Array:unpack<_> abort<Type> break
        }
        case Some -> {}
    } make Result<Type, CheckError>.Success
} }

fn pop2(ctx: .WordCtx, stack: .Stack, token: .Token, expected-ptr: .i8, expected-len: i32) -> Result<[Type, Type], CheckError> { block {
    $ctx $stack pop match {
        case None -> {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt $expected-ptr $expected-len Fmt:write
            &fmt ", got: []" Fmt:write
            $ctx.ctx $token $msg Array:unpack<_> abort<[Type, Type]> break
        }
        case Some -> {}
    } @b
    $ctx $stack pop match {
        case None -> {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt $expected-ptr $expected-len Fmt:write
            &fmt ", got: [" Fmt:write
            &fmt $ctx.type-lookup &b TypeLookup:pretty
            &fmt "]" Fmt:write
            $ctx.ctx $token $msg Array:unpack<_> abort<[Type, Type]> break
        }
        case Some -> {}
    } $b [,2] make Result<[Type, Type], CheckError>.Success
} }

fn pop3(ctx: .WordCtx, stack: .Stack, token: .Token, expected-ptr: .i8, expected-len: i32) -> Result<[Type, Type, Type], CheckError> { block {
    $ctx $stack pop match {
        case None -> {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt $expected-ptr $expected-len Fmt:write
            &fmt ", got: []" Fmt:write
            $ctx.ctx $token $msg Array:unpack<_> abort<[Type, Type, Type]> break
        }
        case Some -> {}
    } @c
    $ctx $stack pop match {
        case None -> {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt $expected-ptr $expected-len Fmt:write
            &fmt ", got: [" Fmt:write
            &fmt $ctx.type-lookup &c TypeLookup:pretty
            &fmt "]" Fmt:write
            $ctx.ctx $token $msg Array:unpack<_> abort<[Type, Type, Type]> break
        }
        case Some -> {}
    } @b
    $ctx $stack pop match {
        case None -> {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt $expected-ptr $expected-len Fmt:write
            &fmt ", got: [" Fmt:write
            &fmt $ctx.type-lookup &b TypeLookup:pretty
            &fmt ", " Fmt:write
            &fmt $ctx.type-lookup &c TypeLookup:pretty
            &fmt "]" Fmt:write
            $ctx.ctx $token $msg Array:unpack<_> abort<[Type, Type, Type]> break
        }
        case Some -> {}
    } $b $c [,3] make Result<[Type, Type, Type], CheckError>.Success
} }

fn type-mismatch-error(ctx: .WordCtx, token: .Token, expected: .Array<Type>, actual: .Array<Type>) -> Maybe<CheckError> {
    $ctx.temp Fmt:into-new-string @msg @fmt
    &fmt "expected:\n\t" Fmt:write
    &fmt $ctx.type-lookup $expected Types-pretty-bracketed
    &fmt "\ngot:\n\t" Fmt:write
    &fmt $ctx.type-lookup $actual   Types-pretty-bracketed
    $ctx.ctx $token $msg Array:unpack<_> abort-m
}
fn expect(ctx: .WordCtx, stack: .Stack, token: .Token, expected: .Array<Type>) -> Maybe<CheckError> { block {
    $expected.len @i
    $ctx.temp Arena:temp @temp @save
    $temp $expected.len Array:new-with-capacity<Type> @popped
    loop {
        $i 0 = if { make Maybe<CheckError>.None break }
        $expected $i 1 - Array:get<Type> @expected-type
        $ctx $stack pop match {
            case None -> { 1 1 = }
            case Some -> {
                @popped-type
                &popped-type $expected-type Type:eq not
                &popped $popped-type Array:push-assert-no-alloc<Type>
            }
        } if {
            &popped Array:reverse<Type>
            $ctx $token $expected &popped type-mismatch-error break
        }
        $i 1 - #i
    }
    $temp $save Arena:restore
} }
fn expect-arguments(
    ctx: .WordCtx,
    function-name: .Token,
    generic-arguments: .Array<Type>,
    arguments: .Array<Type>,
    parameters: .Array<NamedType>
) -> Maybe<CheckError> { block {
    $ctx.temp Arena:temp @temp @save

    $parameters.len $arguments.len /= if {
        $ctx $function-name $arguments $parameters $generic-arguments parameter-argument-mismatch-error break
    }

    $parameters.len @i
    loop {
        $i 0 = if { make Maybe<CheckError>.None break }
        $parameters $i 1 - Array:get<NamedType> .type @parameter
        $ctx.persistent $generic-arguments $parameter insert-generic-arguments @expected-type
        $arguments $i 1 - Array:get<Type> @popped-type

        $popped-type &expected-type Type:eq not if {
            $ctx $function-name $arguments $parameters $generic-arguments parameter-argument-mismatch-error break
        }
        $i 1 - #i
    }
    $temp $save Arena:restore
} }
fn expect1(ctx: .WordCtx, stack: .Stack, token: .Token, a: .Type, expected-ptr: .i8, expected-len: i32) -> Maybe<CheckError> { block {
    $ctx $stack $token $expected-ptr $expected-len pop1 match {
        case Error -> { make Maybe<CheckError>.Some break }
        case Success -> {}
    } @actual-a
    &actual-a $a Type:eq not if {
        $ctx.temp Fmt:into-new-string @msg @fmt
        &fmt $expected-ptr $expected-len Fmt:write
        &fmt ", got: [" Fmt:write &fmt $ctx.type-lookup &actual-a TypeLookup:pretty &fmt "]" Fmt:write
        $ctx.ctx $token $msg Array:unpack<_> abort-m
    } else {
        make Maybe<CheckError>.None
    }
} }
fn expect2(ctx: .WordCtx, stack: .Stack, token: .Token, a: .Type, b: .Type, expected-ptr: .i8, expected-len: i32) -> Maybe<CheckError> { block {
    $ctx $stack $token $expected-ptr $expected-len pop2 match {
        case Error -> { make Maybe<CheckError>.Some break }
        case Success -> {}
    } [,] @actual-b @actual-a
    block {
        &actual-b $b Type:eq not if { 1 1 = break }
        &actual-a $a Type:eq not if { 1 1 = break }
        0 1 =
    } if {
        $ctx.temp Fmt:into-new-string @msg @fmt
        &fmt $expected-ptr $expected-len Fmt:write
        &fmt ", got: [" Fmt:write
        &fmt $ctx.type-lookup &actual-a TypeLookup:pretty &fmt ", " Fmt:write
        &fmt $ctx.type-lookup &actual-b TypeLookup:pretty &fmt "]"  Fmt:write
        $ctx.ctx $token $msg Array:unpack<_> abort-m
    } else {
        make Maybe<CheckError>.None
    }
} }
fn expect3(ctx: .WordCtx, stack: .Stack, token: .Token, a: .Type, b: .Type, c: .Type, expected-ptr: .i8, expected-len: i32) -> Maybe<CheckError> { block {
    $ctx $stack $token $expected-ptr $expected-len pop3 match {
        case Error -> { make Maybe<CheckError>.Some break }
        case Success -> {}
    } [,] @actual-c @actual-b @actual-a
    block {
        &actual-c $c Type:eq not if { 1 1 = break }
        &actual-b $b Type:eq not if { 1 1 = break }
        &actual-a $a Type:eq not if { 1 1 = break }
        0 1 =
    } if {
        $ctx.temp Fmt:into-new-string @msg @fmt
        &fmt $expected-ptr $expected-len Fmt:write
        &fmt ", got: [" Fmt:write
        &fmt $ctx.type-lookup &actual-a TypeLookup:pretty &fmt ", " Fmt:write
        &fmt $ctx.type-lookup &actual-b TypeLookup:pretty &fmt ", " Fmt:write
        &fmt $ctx.type-lookup &actual-c TypeLookup:pretty &fmt "]"  Fmt:write
        $ctx.ctx $token $msg Array:unpack<_> abort-m
    } else {
        make Maybe<CheckError>.None
    }
} }

fn check-init-local(ctx: .WordCtx, stack: .Stack, word: .Resolved:InitLocal) -> Result<[Word, bool], CheckError> { block {
    $ctx $stack pop match {
        case None -> { $ctx.ctx &word.name "local init expected item on stack" abort<[Word, bool]> break }
        case Some -> {}
    } @type

    $ctx.persistent $ctx.env $word.local
    make Local {
        // TODO: why does this say Synthetic?
        $word.local.name make LocalName.Synthetic @name
        $type @type
        0 1 = @reffed
        0 1 = @is-parameter
    } Map:insert<LocalId, Local> Maybe:assert-none<_>

    $word.name $type $word.local make InitLocal
    make Word.InitLocal 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-get-field(ctx: .WordCtx, stack: .Stack, word: .P:GetField) -> Result<[Word, bool], CheckError> { block {
    $ctx $stack pop match {
        case None -> { $ctx.ctx &word.token "expected a value on the stack" abort<[Word, bool]> break }
        case Some -> {}
    } @type
    $ctx $type &word.fields resolve-field-accesses match {
        case Error -> { make Result<[Word, bool], CheckError>.Error break }
        case Success -> {}
    } @fields
    $type match {
        case Ptr -> { drop 1 1 = }
        case _ -> { drop 0 1 = }
    } @on-ptr
    &fields $fields.len 1 - Array:get<FieldAccess>.target-type @type
    $on-ptr if { $type make Type.Ptr } else { $type ~ } @type
    $ctx $stack $type push
    $word.token $fields $on-ptr $type make GetField
    make Word.GetField 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-get-local(ctx: .WordCtx, stack: .Stack, word: .Resolved:GetLocal) -> Result<[Word, bool], CheckError> { block {
    &word.var match {
        case VarId.Global -> {
            @global-id
            &ctx.globals.values $global-id.index Array:get<_> .type
        }
        case VarId.Local -> {
            $ctx.env flip Map:get<_, _> Maybe:assert-some<_> .type
        }
    } @var-type
    $ctx $var-type ~ &word.fields resolve-field-accesses match {
        case Error -> { make Result<[Word, bool], CheckError>.Error break }
        case Success -> {}
    } @fields
    $fields.len 0 = if {
        $var-type ~
    } else {
        &fields $fields.len 1 - Array:get<FieldAccess> .target-type ~
    } @type
    $ctx $stack $type push
    $word.name $word.var $var-type ~ $fields $type make GetLocal
    make Word.GetLocal 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-set-local(ctx: .WordCtx, stack: .Stack, word: .Resolved:SetLocal) -> Result<[Word, bool], CheckError> { block {
    &word.var match {
        case VarId.Global -> {
            @global-id
            &ctx.globals.values $global-id.index Array:get<_> .type
        }
        case VarId.Local -> {
            @local-id
            $ctx.env $local-id Map:get<_, _> Maybe:assert-some<_> .type
        }
    } @type
    $ctx $type ~ &word.fields resolve-field-accesses match {
        case Error -> { make Result<[Word, bool], CheckError>.Error break }
        case Success -> {}
    } @fields
    $fields.len 0 = if {
        $type
    } else {
        &fields $fields.len 1 - Array:get<FieldAccess> .target-type
    } @type
    $ctx $stack &word.name $type "TODO" expect1 match {
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
        case None -> {}
    }
    $word.name $word.var $fields $type ~ make SetLocal
    make Word.SetLocal 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn check-store(ctx: .WordCtx, stack: .Stack, word: .Resolved:StoreLocal) -> Result<[Word, bool], CheckError> { block {
    &word.var match {
        case VarId.Global -> {
            @global-id
            &ctx.globals.values $global-id.index Array:get<_> .type
        }
        case VarId.Local -> {
            @local-id
            $ctx.env $local-id Map:get<_, _> Maybe:assert-some<_> .type
        }
    } @type
    $ctx $type ~ &word.fields resolve-field-accesses match {
        case Error -> { make Result<[Word, bool], CheckError>.Error break }
        case Success -> {}
    } @fields
    $fields.len 0 = if {
        $type
    } else {
        &fields $fields.len 1 - Array:get<FieldAccess> .target-type
    } match {
        case Ptr -> { ~ }
        case _ -> { drop $ctx.ctx &word.name "`=>` can only store into ptr types" abort<[Word, bool]> break }
    } @expected-type
    $ctx $stack &word.name $expected-type "TODO" expect1 match {
        case Some -> { make Result<[Word, bool], CheckError>.Error break }
        case None -> {}
    }
    $word.name $word.var $expected-type ~ $fields make StoreLocal
    make Word.StoreLocal 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn fields-go-through-ptr(fields: .Array<FieldAccess>) -> bool {
    0 @i
    loop {
        $i $fields.len = if {
            // No field access went through a pointer,
            0 1 = break
        }
        $fields $i Array:get<FieldAccess> .source-type match {
            case Ptr -> {
                drop
                // At least one field access goes through a pointer,
                1 1 = break
            }
            case _ -> { drop }
        }
        $i 1 + #i
    }
}

fn check-ref-local(ctx: .WordCtx, stack: .Stack, word: .Resolved:RefLocal) -> Result<[Word, bool], CheckError> { block {
    &word.var match {
        case VarId.Global -> {
            @global-id
            &ctx.globals.values $global-id.index Array:get<_> @globl
            &globl.reffed
            $globl.type
        }
        case VarId.Local -> {
            @local-id
            $ctx.env $local-id Map:get<_, _> Maybe:assert-some<_> @local
            &local.reffed
            $local.type
        }
    } @type @reffed-slot
    $ctx $type &word.fields resolve-field-accesses match {
        case Error -> { make Result<[Word, bool], CheckError>.Error break }
        case Success -> {}
    } @fields

    &fields fields-go-through-ptr not if {
        // No field access went through a pointer,
        // therefore this local really was reffed.
        1 1 = =>reffed-slot
    }

    $fields.len 0 = if {
        &type
    } else {
        &fields $fields.len 1 - Array:get<FieldAccess> .target-type
    } $ctx.persistent flip Arena:copy<Type> @result-type
    $ctx $stack $result-type make Type.Ptr push
    $word.name $word.var $fields make RefLocal
    make Word.RefLocal 0 1 = [,2]
    make Result<[Word, bool], CheckError>.Success
} }

fn resolve-field-accesses(ctx: .WordCtx, type: Type, fields: .Array<Token>) -> Result<Array<FieldAccess>, CheckError> { block {
    Array:new<FieldAccess> @resolved
    $fields.len 0 = if { $resolved make Result<Array<FieldAccess>, CheckError>.Success break }
    0 @i
    loop {
        $fields $i Array:get<Token> @field-name
        $type match {
            case Custom -> {
                @custom-type
                $ctx.type-lookup &custom-type.type-definition TypeLookup:lookup match {
                    case Variant -> {
                        drop $ctx.ctx $field-name "variants do not have fields" abort<Array<FieldAccess>> break
                    }
                    case Struct -> {}
                } $custom-type
            }
            case Ptr -> {
                ~ match {
                    case Custom -> {
                        @custom-type
                        $ctx.type-lookup &custom-type.type-definition TypeLookup:lookup match {
                            case Variant -> { drop $ctx.ctx $field-name "variants do not have fields" abort<Array<FieldAccess>> break }
                            case Struct -> {}
                        }
                        $custom-type
                    }
                    case _ -> { drop $ctx.ctx $field-name "TODO" abort<Array<FieldAccess>> break }
                }
            }
            case _ -> { drop $ctx.ctx $field-name "TODO" abort<Array<FieldAccess>> break }
        }
        @custom-type @struc
        0 @field-index
        loop {
            $field-index $struc.fields.len = if {
                $ctx.ctx $field-name "field not found" abort-m break
            }
            &struc.fields $field-index Array:get<NamedType> @field
            &field.name Token-lexeme $field-name Token-lexeme Bytes:eq if {
                $ctx.persistent &resolved
                $ctx.persistent &custom-type.generic-arguments &field.type insert-generic-arguments @target-type
                $field-name ~ $type $target-type $field-index make FieldAccess
                Array:push<FieldAccess>
                $target-type #type
                make Maybe<CheckError>.None break
            }
            $field-index 1 + #field-index
        } match {
            case Some -> { make Result<Array<FieldAccess>, CheckError>.Error break }
            case None -> {}
        }
        $i 1 + #i
        $i $fields.len = if { $resolved make Result<Array<FieldAccess>, CheckError>.Success break }
    }
} }

fn generic-arguments-mismatch-error(ctx: .Ctx, token: .Token, expected: i32, actual: i32) -> CheckError {
    $ctx.temp Fmt:into-new-string @msg @fmt
    &fmt "expected " Fmt:write
    &fmt $expected i32-format
    &fmt " generic arguments, not " Fmt:write
    &fmt $actual i32-format
    $ctx $token $msg Array:unpack<_> error
}

