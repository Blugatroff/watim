import "../../std/maybe.watim" as Maybe (Maybe(None, Some))
import "../../std/array.watim" as Array (Array)
import "../../std/arena.watim" as Arena (Arena)
import "../../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../../std/util.watim" as Util (i32-format)
import "../../std/fmt.watim" as Fmt (Formatter)
import "../../std/io.watim" as IO

import "../lexer.watim" as Lexer (Token, Token-format, Token-lexeme)
import "../parser.watim" as P

import "../resolving/type.watim" as Type (
    Type(Bool, I8, I32, I64, Ptr, Custom, Tuple, Generic, Hole, Fun),
    CustomTypeType-eq, FunType-eq, TupleType-eq,
)

fn eq(a: .Type, b: .Type) -> bool {
    $a match {
        case Bool -> { $b match { case Bool -> { 1 1 = } case _ -> { drop 0 1 = } } }
        case I8 -> { $b match { case I8 -> { 1 1 = } case _ -> { drop 0 1 = } } }
        case I32 -> { $b match { case I32 -> { 1 1 = } case _ -> { drop 0 1 = } } }
        case I64 -> { $b match { case I64 -> { 1 1 = } case _ -> { drop 0 1 = } } }
        case Ptr -> {
            ~ $b match {
                case Ptr -> { ~ eq }
                case _ -> { drop drop 0 1 = }
            }
        }
        case Custom -> {
            $b match {
                case Custom -> { CustomTypeType-eq }
                case _ -> { drop drop 0 1 = }
            }
        }
        case Fun -> {
            $b match {
                case Fun -> { FunType-eq }
                case _ -> { drop drop 0 1 = }
            }
        }
        case Tuple -> {
            $b match {
                case Tuple -> { TupleType-eq }
                case _ -> { drop drop 0 1 = }
            }
        }
        case Generic -> {
            .index ~ $b match {
                case Generic -> { .index ~ = }
                case _ -> { drop drop 0 1 = }
            }
        }
        case Hole -> {
            drop $b match {
                case Hole -> { drop 1 1 = }
                case _ -> { drop 0 1 = }
            }
        }
    }
}
fn find-hole(self: .Type) -> Maybe<.Token> {
    $self match {
        case Type.Bool -> { make Maybe<.Token>.None }
        case Type.I8 -> { make Maybe<.Token>.None }
        case Type.I32 -> { make Maybe<.Token>.None }
        case Type.I64 -> { make Maybe<.Token>.None }
        case Type.Ptr -> { ~ find-hole }
        case Type.Generic -> { drop make Maybe<.Token>.None }
        case Type.Hole -> { make Maybe<.Token>.Some }
        case Type.Tuple -> { .items \find-hole Array:findMap<Type, .Token> }
        case Type.Fun -> {
            @fun
            &fun.parameters \find-hole Array:findMap<Type, .Token> match {
                case None -> { &fun.returns \find-hole Array:findMap<Type, .Token> }
                case _ -> {}
            }
        }
        case Type.Custom -> { .generic-arguments \find-hole Array:findMap<Type, .Token> }
    }
}
fn contains-hole(self: .Type) -> bool {
    $self find-hole @m &m Maybe:is-some<.Token>
}

