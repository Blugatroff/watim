import "../../std/maybe.watim" as Maybe (Maybe(Some, None), assert-some)
import "../../std/array.watim" as Array (Array)
import "../../std/arena.watim" as Arena (Arena)

import "../lexer.watim" as Lexer (Token)

import "./source.watim" as Source (Source)

struct Parent {
    stack: .Stack
    node: i32
    token: Token
}

struct Stack {
    parent: Maybe<Parent>
    positive: Array<Source>
    negative: Array<Source>
}
fn root() -> Stack {
    make Maybe<Parent>.None Array:new<Source> Array:new<Source> make Stack
}
fn child(self: .Stack, parent-node: i32, parent-token: Token) -> Stack {
    $self $parent-node $parent-token make Parent
    make Maybe<Parent>.Some Array:new<Source> Array:new<Source> make Stack
}
fn clone(arena: .Arena, self: .Stack) -> Stack {
    $self.parent match {
        case None -> { make Maybe<Parent>.None }
        case Some -> {
            @parent
            $arena $arena $parent.stack clone Arena:push<Stack>
            $parent.node $parent.token make Parent make Maybe<Parent>.Some
        }
    }
    $arena &self.positive Array:clone<_>
    $arena &self.negative Array:clone<_>
    make Stack
}
fn push(arena: .Arena, self: .Stack, source: Source) {
    $arena &self.positive $source Array:push<_>
}
fn push-many(arena: .Arena, self: .Stack, sources: .Array<Source>) {
    0 @i
    loop {
        $i $sources.len = if { break }
        $arena $self $sources $i Array:get<_> ~ push
        $i 1 + #i
    }
}
fn pop(arena: .Arena, self: .Stack) -> Maybe<Source> {
    $self.positive.len 0 = if {
        $self.parent match {
            case None -> { make Maybe<Source>.None }
            case Some -> {
                @parent
                $parent.stack $arena flip pop match {
                    case None -> { make Maybe<Source>.None }
                    case Some -> {
                        @source
                        $parent.token $parent.node $self.negative.len make Source:FromNode
                        make Source.FromNode make Maybe<Source>.Some
                        $arena &self.negative $source Array:push<_>
                    }
                }
            }
        }
    } else {
        &self.positive Array:pop<_> make Maybe<Source>.Some
    }
}
fn pop-n(arena: .Arena, self: .Stack, n: i32) -> Array<Source> {
    $arena $n Array:new-with-capacity<Source> @popped
    $n loop {
        @n $n 0 = if { break }
        $arena $self pop match {
            case None -> { break }
            case Some -> {}
        }
        &popped flip Array:push-assert-no-alloc<_>
        $n 1 -
    }
    &popped Array:reverse<_>
    $popped
}
fn ensure-negatives(arena: .Arena, self: .Stack, n-negative: i32) {
    loop {
        $self.negative.len $n-negative ge if { break }
        &self.parent match {
            case None -> { break }
            case Some -> { .stack ~ }
        } $arena flip pop match {
            case None -> { break }
            case Some -> {}
        } @type
        $arena &self.negative $type Array:push<_>
        $arena &self.positive $type Array:push-front<_>
    }
}
fn dump(arena: .Arena, self: .Stack) -> Array<Source> {
    $arena $self $self size pop-n
}
fn to-array(arena: .Arena, self: .Stack) -> Array<Source> {
    $arena $self size Array:new-with-capacity<Source> @array
    $self &array to-array-helper
    $array
}
fn to-array-helper(self: .Stack, array: .Array<Source>) {
    &self.parent match {
        case None -> {}
        case Some -> { .stack ~ $array to-array-helper }
    }
    0 loop {
        @i $i $self.positive.len = if { break }
        $array &self.positive $i Array:get<_> ~ Array:push-assert-no-alloc<_>
        $i 1 +
    }
}
fn size(self: .Stack) -> i32 {
    $self.positive.len
    $self.parent match {
        case None -> {}
        case Some -> { .stack size + }
    }
}
fn index(self: .Stack, index: i32) -> .Source {
    $index $self.positive.len lt if {
        &self.positive $self.positive.len $index - 1 - Array:get<_>
    } else {
        &self.parent Maybe:ref<_> assert-some<.Parent> .stack ~ $index $self.positive.len - index
    }
}
