import "../../std/core.watim" as Core
import "../../std/maybe.watim" as Maybe (Maybe(Some, None))
import "../../std/arena.watim" as Arena (Arena)
import "../../std/array.watim" as Array (Array)
import "../../std/map.watim" as Map (Map)
import "../../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../../std/fmt.watim" as Fmt (Formatter)
import "../../std/fmt-utils.watim" as Fmt (ByteSlice-format)
import "../../std/util.watim" as Util (bool-format, i32-format, i32-format-ref)

import "../../std/io.watim" as IO

import "../lexer.watim" as Lexer (Token, Token-format)

import "../resolving/type.watim" as Type (Type, CustomTypeHandle)
import "../resolving/words.watim" as Resolved (VarId, LocalId, LocalId-format)
import "../resolving/intrinsics.watim" as Resolved
import "../resolving/top-items.watim" as Resolved (Signature, Signature-format, LocalName, LocalName-token)
import "../resolving/module.watim" as Resolved

import "./stack.watim" as Stack (Stack)
import "./source.watim" as Source (Source, Source-format, MultiReturnNode)
import "./word.watim" as Word (InferenceHole, InferenceHole-format, InferenceFieldHole, Word, Scope, Scope-format)

struct Module {
    imports: Map<ByteSlice, Array<Resolved:Import>>
    functions: Map<ByteSlice, FunctionOrExtern>
    globals: Array<Resolved:Global>
    type-definitions: Array<Resolved:TypeDefinition>
    static-data: ByteSlice
}
fn Module-format(fmt: .Formatter, self: .Module) {
    $fmt "(Module\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "imports=" Fmt:write
    $fmt \ByteSlice-format \Resolved:format-imprt-array &self.imports Map:format-multi-line<ByteSlice, Array<Resolved:Import>>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "type-definitions=" Fmt:write
    $fmt \Resolved:TypeDefinition-format &self.type-definitions Array:format-multi-line<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "globals=" Fmt:write
    $fmt \Resolved:Global-format &self.globals Array:format-multi-line<Resolved:Global>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "functions=" Fmt:write
    $fmt \ByteSlice-format \FunctionOrExtern-format &self.functions Map:format-multi-line<ByteSlice, FunctionOrExtern>
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}
fn unstack(arena: .Arena, modules: .Map<ByteSlice, Resolved:Module>) -> Map<ByteSlice, Module> {
    $arena \ByteSlice:eq-by-ref $modules.values.len Map:new-with-capacity<ByteSlice, Module> @unstacked
    0 loop {
        @i
        $i $modules.values.len = if { break }
        &unstacked
        &modules.keys $i Array:get<_> ~

        2 "unstack-module: " IO:write-all IO:check
        2 &modules.keys $i Array:get<_> ~ ByteSlice:unpack IO:write-all IO:check
        2 "\n" IO:write-all IO:check

        $arena &modules.values &modules.values $i Array:get<_> unstack-module Map:insert-assert-no-alloc<_, _> drop
        $i 1 +
    }
    $unstacked
}

variant FunctionOrExtern {
    case Extern -> Resolved:Extern
    case Function -> Function
}
fn FunctionOrExtern-format(fmt: .Formatter, self: .FunctionOrExtern) {
    $fmt $self match {
        case Extern -> { Resolved:Extern-format }
        case Function -> { Function-format }
    }
}
fn FunctionOrExtern-signature(self: .FunctionOrExtern) -> .Signature {
    $self match {
        case Extern -> { .signature }
        case Function -> { .signature }
    }
}

fn unstack-module(arena: .Arena, modules: .Array<Resolved:Module>, module: .Resolved:Module) -> Module {
    $arena \ByteSlice:eq-by-ref $module.functions.values.len Map:new-with-capacity<ByteSlice, FunctionOrExtern> @unstacked-functions
    0 loop {
        @i
        $i $module.functions.values.len = if { break }
        &unstacked-functions
        &module.functions.keys $i Array:get<_> ~
        &module.functions.values $i Array:get<_> match {
            case Resolved:FunctionOrExtern.Extern -> {
                ~ make FunctionOrExtern.Extern
            }
            case Resolved:FunctionOrExtern.Function -> {
                $arena flip $modules flip unstack-function make FunctionOrExtern.Function
            }
        } Map:insert-assert-no-alloc<_, _> drop
        $i 1 +
    }
    make Module {
        $module.imports @imports
        $module.type-definitions.values @type-definitions
        $unstacked-functions @functions
        $module.globals.values @globals
        $module.static-data @static-data
    }
}

struct Assignment {
    token: Token
    source: Maybe<Source>
    fields: Array<Word:FieldAccess>
    type: InferenceHole
    is-store: bool
}
fn Assignment-format(fmt: .Formatter, self: .Assignment) {
    $fmt "(Assignment\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "source=" Fmt:write
    $fmt \Source-format &self.source Maybe:format<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "fields=" Fmt:write
    $fmt \Word:FieldAccess-format &self.fields Array:format-multi-line<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "type=" Fmt:write
    $fmt &self.type InferenceHole-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "is-store=" Fmt:write
    $fmt $self.is-store bool-format
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

struct Local {
    name: LocalName
    type: InferenceHole
    // if this local is a parameter, then this will be non-None
    parameter: Maybe<Type>
    assignments: Array<Assignment>
    read: bool
    reffed: bool
}
fn Local-format(fmt: .Formatter, self: .Local) {
    $fmt "(Local\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Resolved:LocalName-format
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "type=" Fmt:write
    $fmt &self.type InferenceHole-format
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameter=" Fmt:write
    $fmt \Type:format &self.parameter Maybe:format<_>
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "read=" Fmt:write
    $fmt $self.read bool-format
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "reffed=" Fmt:write
    $fmt $self.reffed bool-format
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "assignments=" Fmt:write
    $fmt \Assignment-format &self.assignments Array:format-multi-line<_>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

struct IndirectCallVoid {
    token: Token
    function: Maybe<Source>
    parameters: Array<InferenceHole>
    returns: Array<InferenceHole>
}
fn IndirectCallVoid-format(fmt: .Formatter, self: .IndirectCallVoid) {
    $fmt "(IndirectCallVoid\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt \InferenceHole-format &self.parameters Array:format-multi-line<_>
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt \InferenceHole-format &self.returns Array:format-multi-line<_>
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "function=" Fmt:write
    $fmt \Source-format &self.function Maybe:format<_>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

struct SetGlobalVoid {
    token: Token
    global-type: Type
    fields: Array<Word:FieldAccess>
    type: InferenceHole
    source: Maybe<Source>
}
fn SetGlobalVoid-format(fmt: .Formatter, self: .SetGlobalVoid) {
    $fmt "(SetGlobalVoid\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "global-type=" Fmt:write
    $fmt &self.global-type Type:format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "fields=" Fmt:write
    $fmt \Word:FieldAccess-format &self.fields Array:format-multi-line<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "type=" Fmt:write
    $fmt &self.type InferenceHole-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "source=" Fmt:write
    $fmt \Source-format &self.source Maybe:format<_>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

struct CallVoid {
    token: Token
    function: Resolved:FunctionHandle
    arguments: Array<Source>
    generic-arguments: Array<InferenceHole>
}
fn CallVoid-format(fmt: .Formatter, self: .CallVoid) {
    $fmt "(CallVoid\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "function=" Fmt:write
    $fmt &self.function Resolved:FunctionHandle-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "arguments=" Fmt:write
    $fmt \Source-format &self.arguments Array:format-multi-line<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "generic-arguments=" Fmt:write
    $fmt \InferenceHole-format &self.generic-arguments Array:format-multi-line<_>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

variant StackVoid {
    case Store -> StoreVoid
    case NonSpecific -> NonSpecificVoid
    case IndirectCall -> IndirectCallVoid
    case SetGlobal -> SetGlobalVoid
    case Call -> CallVoid
}
fn StackVoid-format(fmt: .Formatter, self: .StackVoid) {
    $fmt $self match {
        case Store -> { StoreVoid-format }
        case NonSpecific -> { NonSpecificVoid-format }
        case IndirectCall -> { IndirectCallVoid-format }
        case SetGlobal -> { SetGlobalVoid-format }
        case Call -> { CallVoid-format }
    }
}

struct StoreVoid {
    token: Token
    dst: Maybe<Source>
    src: Maybe<Source>
    type: InferenceHole
}
fn StoreVoid-format(fmt: .Formatter, self: .StoreVoid) {
    $fmt "(StoreVoid\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "dst=" Fmt:write
    $fmt \Source-format &self.dst Maybe:format<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "src=" Fmt:write
    $fmt \Source-format &self.src Maybe:format<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "type=" Fmt:write
    $fmt &self.type InferenceHole-format
    $fmt Fmt:dedent
    $fmt ")" Fmt:write

}

struct NonSpecificVoid {
    token: Token
    source: Maybe<Source>
    known: Maybe<Type>
    type: Maybe<InferenceHole>
}
fn NonSpecificVoid-format(fmt: .Formatter, self: .NonSpecificVoid) {
    $fmt "(NonSpecificVoid\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "source=" Fmt:write
    $fmt \Source-format &self.source Maybe:format<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "known=" Fmt:write
    $fmt \Type:format &self.known Maybe:format<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "type=" Fmt:write
    $fmt \InferenceHole-format &self.type Maybe:format<_>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

struct Function {
    name: Token
    export: Maybe<Token>
    signature: Signature
    locals: Map<LocalId, Local>
    voids: Array<StackVoid>
    holes: Holes
    nodes: Array<MultiReturnNode>
    body: Scope
    returns: Array<Source>
}
fn Function-format(fmt: .Formatter, self: .Function) {
    $fmt "(Function\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "export=" Fmt:write
    $fmt \Token-format &self.export Maybe:format<_>
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "signature=" Fmt:write
    $fmt &self.signature Signature-format
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "locals=" Fmt:write
    $fmt \LocalId-format \Local-format &self.locals Map:format-multi-line<_, _>
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "voids=" Fmt:write
    $fmt \StackVoid-format &self.voids Array:format-multi-line<_>
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "holes=" Fmt:write
    $fmt &self.holes Holes-format
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "nodes=" Fmt:write
    $fmt \Source:MultiReturnNode-format &self.nodes Array:format-multi-line<_>
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "body=" Fmt:write
    $fmt &self.body Scope-format
    $fmt "\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt \Source:Source-format &self.returns Array:format-multi-line<_>
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct Holes {
    holes: Array<Maybe<Type>>
}
fn Holes-empty() -> Holes {
    Array:new<Maybe<Type>> make Holes
}
fn Holes-clone(arena: .Arena, self: .Holes) -> Holes {
    $arena &self.holes Array:clone<_> make Holes
}
fn Holes-fill(arena: .Arena, self: .Holes, hole: .InferenceHole, known: Type) {
    loop {
        $self.holes.len $hole.index gt if { break }
        $arena &self.holes make Maybe<Type>.None Array:push<_>
    }
    &self.holes $hole.index $known make Maybe<Type>.Some Array:set<_> match {
        case None -> {}
        case Some -> {
            & &known Type:eq not if { 0 0 / drop }
        }
    }
}
fn Holes-lookup(self: .Holes, hole: .InferenceHole) -> Maybe<.Type> {
    $self.holes.len $hole.index le if {
        make Maybe<.Type>.None
    } else {
        &self.holes $hole.index Array:get<_> Maybe:ref<_>
    }
}
fn Holes-format(fmt: .Formatter, self: .Holes) {
    $self.holes.len 0 = if {
        $fmt "(Holes)" Fmt:write
    } else {
        $fmt "(Holes\n" Fmt:write
        $fmt Fmt:indent
        0 loop {
            @i $i $self.holes.len = if { break }
            $fmt Fmt:write-indent
            $fmt $i i32-format
            $fmt "=" Fmt:write
            $fmt \Type:format &self.holes $i Array:get<_> Maybe:format<_>
            $i 1 +
            Core:dup<_> $self.holes.len /= if { $fmt ",\n" Fmt:write }
        }
        $fmt Fmt:dedent
        $fmt ")" Fmt:write
    }
}

struct BreakStack {
    token: Token
    sources: Array<Source>
    reachable: bool
}
fn BreakStack-format(fmt: .Formatter, self: .BreakStack) {
    $fmt "(BreakStack\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "sources=" Fmt:write
    $fmt \Source-format &self.sources Array:format-multi-line<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "reachable=" Fmt:write
    $fmt $self.reachable bool-format
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

struct Unstacker {
    arena: .Arena
    locals: .Map<LocalId, Local>
    modules: .Array<Resolved:Module>
    voids: .Array<StackVoid>
    holes: .Holes
    multi-return-nodes: .Array<Source:MultiReturnNode>
    next-inference-hole-index: .i32
    next-inference-field-hole-index: .i32
    break-stacks: Maybe<.Array<BreakStack>>
    block-returns: Maybe<.Array<InferenceHole>>
    struct-init-type: Maybe<InferenceHole>
    struct-field-init-arguments: .Array<Maybe<Source>>
    reachable: bool
}
fn with-break-stacks(unstacker: .Unstacker, break-stacks: .Array<BreakStack>, block-returns: Maybe<.Array<InferenceHole>>) -> Unstacker {
    $unstacker ~ @new
    $break-stacks make Maybe<.Array<BreakStack>>.Some #new.break-stacks
    $block-returns #new.block-returns
    $new
}
fn with-cleared-reachable-flag(unstacker: .Unstacker) -> Unstacker {
    $unstacker ~ @new
    1 1 = #new.reachable
    $new
}
fn with-struct-init(unstacker: .Unstacker, type: InferenceHole, arguments: .Array<Maybe<Source>>) -> Unstacker {
    $unstacker ~ @new
    $type make Maybe<InferenceHole>.Some #new.struct-init-type
    $arguments #new.struct-field-init-arguments
    $new
}

fn lookup-global(unstacker: .Unstacker, global-id: Resolved:GlobalId) -> .Resolved:Global {
    $unstacker.modules $global-id.module.index Array:get<_> .globals.values $global-id.index Array:get<_>
}

fn fresh-hole(unstacker: .Unstacker, token: Token) -> InferenceHole {
    $token $unstacker.next-inference-hole-index ~ make InferenceHole
    $unstacker.next-inference-hole-index ~ 1 + =>unstacker.next-inference-hole-index
}
fn fresh-holes(unstacker: .Unstacker, token: Token, n: i32) -> Array<InferenceHole> {
    $unstacker.arena $n Array:new-with-capacity<InferenceHole> @holes
    loop {
        $holes.len $n = if { break }
        &holes $unstacker $token fresh-hole Array:push-assert-no-alloc<_>
    }
    $holes
}
fn fresh-field-hole(unstacker: .Unstacker) -> InferenceFieldHole {
    $unstacker.next-inference-field-hole-index ~ make InferenceFieldHole
    $unstacker.next-inference-field-hole-index ~ 1 + =>unstacker.next-inference-field-hole-index
}
fn lookup-type-definition(unstacker: .Unstacker, handle: CustomTypeHandle) -> .Resolved:TypeDefinition {
    $unstacker.modules $handle.module.index Array:get<_> .type-definitions.values $handle.index Array:get<_>
}
fn lookup-signature(unstacker: .Unstacker, handle: Resolved:FunctionHandle) -> .Resolved:Signature {
    $unstacker.modules $handle.module.index Array:get<_>
    .functions.values $handle.index Array:get<_> Resolved:FunctionOrExtern-signature
}
fn pre-add-node(unstacker: .Unstacker) -> i32 {
    $unstacker.multi-return-nodes.len
    $unstacker.arena $unstacker.multi-return-nodes make Source:MultiReturnNode.PlaceHolder Array:push<_>
}
fn add-node(unstacker: .Unstacker, node: Source:MultiReturnNode) -> i32 {
    $unstacker.multi-return-nodes.len
    $unstacker.arena $unstacker.multi-return-nodes $node Array:push<_>
}
fn fill-node(unstacker: .Unstacker, index: i32, node: Source:MultiReturnNode) {
    $unstacker.multi-return-nodes $index Array:get<_> match {
        case Source:MultiReturnNode.PlaceHolder -> {
            $unstacker.multi-return-nodes $index $node Array:set<_> drop
        }
        case _ -> { drop 0 0 / drop }
    }
}

fn unstack-function(arena: .Arena, modules: .Array<Resolved:Module>, function: .Resolved:Function) -> Function {
    Stack:root @stack
    0 $stack.negative.len 0 = !i32 / drop

    $arena \Resolved:LocalId-eq $function.locals.values.len Map:new-with-capacity<LocalId, Local> @locals
    Array:new<StackVoid> @voids
    $arena &locals $modules &voids Holes-empty & Array:new<MultiReturnNode> & 0 & 0 &
    make Maybe<.Array<BreakStack>>.None make Maybe<.Array<InferenceHole>>.None
    make Maybe<InferenceHole>.None
    Array:new<Maybe<Source>> &
    1 1 =
    make Unstacker @unstacker
    0 loop {
        @i $i $function.locals.values.len = if { break }
        &locals
        &function.locals.keys $i Array:get<_> ~
        &function.locals.values $i Array:get<_> @local
        make Local {
            $local.name @name
            $local.parameter @parameter
            &unstacker &local.name LocalName-token ~ fresh-hole @type
            Array:new<Assignment> @assignments
            0 1 = @reffed
            0 1 = @read
        } Map:insert-assert-no-alloc<_, _> drop
        $i 1 +
    }

    &unstacker &stack &function.body unstack-scope @body

    make Function {
        $function.name @name
        $function.export @export
        $locals @locals
        $voids @voids
        $function.signature @signature
        $unstacker.holes ~ @holes
        $unstacker.multi-return-nodes ~ @nodes
        $body @body
        $stack.positive @returns
    }
}

fn unstack-scope(unstacker: .Unstacker, stack: .Stack, scope: .Resolved:Scope) -> Scope {
    $scope.id $unstacker $stack &scope.words unstack-words make Scope
}

fn unstack-words(unstacker: .Unstacker, stack: .Stack, remaining: .Array<Resolved:Word>) -> Array<Word> {
    $unstacker.arena $remaining.len Array:new-with-capacity<Word> @unstacked
    loop (-> Array<Word>) {
        $remaining.len 0 = if { $unstacked break }
        $remaining Array:pop-front<Resolved:Word> @resolved-word
        &unstacked
        $unstacker $stack &resolved-word $remaining unstack-word
        Array:push-assert-no-alloc<_>
    }
}

fn unstack-word(unstacker: .Unstacker, stack: .Stack, word: .Resolved:Word, remaining: .Array<Resolved:Word>) -> Word {
    $word match {
        case Resolved:Word.GetLocal -> { $unstacker flip $stack flip unstack-get-local }
        case Resolved:Word.RefLocal -> { $unstacker flip $stack flip unstack-ref-local }
        case Resolved:Word.Number -> {
            ~ @token
            $token make Word.Number
            $unstacker.arena $stack $token make Source.FromNumber Stack:push
        }
        case Resolved:Word.Intrinsic -> { $unstacker flip $stack flip unstack-intrinsic make Word:Word.Intrinsic }
        case Resolved:Word.MakeStruct -> {
            @word

            $unstacker $word.type.type-definition lookup-type-definition match {
                case Resolved:TypeDefinition.Variant -> { drop Core:unreachable<.Resolved:Struct> }
                case Resolved:TypeDefinition.Struct -> {}
            } @struc

            $unstacker.arena $stack $struc.fields.len Stack:pop-n @arguments
            $unstacker $word.token $struc.generic-parameters.len fresh-holes @generic-arguments

            $unstacker $word.token fresh-hole @type

            0 loop {
                @i $i $word.type.generic-arguments.len = if { break }
                $unstacker.arena $unstacker.holes
                &generic-arguments $i Array:get<_>
                &word.type.generic-arguments $i Array:get<_> ~
                Holes-fill
                $i 1 +
            }

            $unstacker.arena $stack
            make Source:FromMakeStruct {
                $word.token @token
                $word.name @name
                $word.type.type-definition @type-definition
                $type @type
                $generic-arguments @generic-arguments
                $arguments @arguments
            } make Source.FromMakeStruct
            Stack:push

            make Word:MakeStruct {
                $word.token @token
                $word.type.type-definition @struc
                $arguments @arguments
                $type @type
            } make Word:Word.MakeStruct
        }
        case Resolved:Word.InitLocal -> {
            @word
            $unstacker.arena $stack Stack:pop @source
            $unstacker.locals &word.local Map:get<_, _> Maybe:assert-some<_> @local
            $unstacker.arena &local.assignments $word.name $source Array:new<Word:FieldAccess> $local.type
            0 1 =
            make Assignment Array:push<_>

            make Resolved:InitLocal {
                $word.name @name
                $word.local @local
            } make Word:Word.InitLocal
        }
        case Resolved:Word.SetLocal -> { $unstacker flip $stack flip unstack-set-local }
        case Resolved:Word.Call -> { $unstacker flip $stack flip unstack-call make Word:Word.Call }
        case Resolved:Word.Cast -> {
            @word
            $unstacker $word.token fresh-hole @src-type
            $unstacker.arena $stack Stack:pop @src

            $unstacker.arena $stack 
            make Source:FromCast {
                $word.token @token
                $src-type @src-type
                $word.dst @dst-type
                $unstacker.arena $src Arena:push<_> @src
            } make Source.FromCast
            Stack:push

            make Word:Cast {
                $word.token @token
                $src-type @src-type
                $word.dst @dst-type
            } make Word:Word.Cast
        }
        case Resolved:Word.Load -> {
            @word
            $unstacker $word.token fresh-hole @type
            $unstacker.arena $stack Stack:pop @src

            $unstacker.arena $stack
            make Source:FromLoad {
                $word.token @token
                $type @type
                $unstacker.arena $src Arena:push<_> @src
            } make Source.FromLoad
            Stack:push

            make Word:Load {
                $word.token @token
                $type @type
            } make Word:Word.Load
        }
        case Resolved:Word.String -> {
            @word
            $unstacker.arena $stack $word.token make Source.FromString Stack:push
            $unstacker.arena $stack $word.token make Source.FromNumber Stack:push
            $word ~ make Word:Word.String
        }
        case Resolved:Word.StoreLocal -> { $unstacker flip $stack flip unstack-store-local make Word:Word.StoreLocal }
        case Resolved:Word.If -> { $unstacker flip $stack flip $remaining flip unstack-if make Word:Word.If }
        case Resolved:Word.Loop -> { $unstacker flip $stack flip unstack-loop make Word:Word.Loop }
        case Resolved:Word.Block -> { $unstacker flip $stack flip unstack-block make Word:Word.Block }
        case Resolved:Word.Break -> { $unstacker flip $stack flip unstack-break make Word:Word.Break }
        case Resolved:Word.Sizeof -> {
            @word
            $unstacker.arena $stack $word.token make Source.FromNumber Stack:push
            $word ~ make Word.Sizeof
        }
        case Resolved:Word.MakeVariant -> {
            @word
            $unstacker $word.type.type-definition lookup-type-definition match {
                case Resolved:TypeDefinition.Struct -> { drop Core:unreachable<.Resolved:Variant> }
                case Resolved:TypeDefinition.Variant -> {}
            } @varint
            &varint.cases $word.tag Array:get<_> @cays
            &cays.type match {
                case None -> { make Maybe<Source>.None }
                case Some -> { drop $unstacker.arena $stack Stack:pop }
            } @source
            $unstacker $word.token fresh-hole @type

            $unstacker $word.token $varint.generic-parameters.len fresh-holes @generic-arguments

            $unstacker.arena $stack
            make Source:FromMakeVariant {
                $word.token @token
                $word.type.type-definition @type-definition
                $generic-arguments @generic-arguments
                $type @type
                $unstacker.arena $source Arena:push<_> @source
                $word.tag @tag
            } make Source.FromMakeVariant
            Stack:push

            0 loop {
                @i $i $word.type.generic-arguments.len = if { break }
                &word.type.generic-arguments $i Array:get<_> @generic-argument
                $generic-argument Type:contains-hole not if {
                    $unstacker.arena $unstacker.holes
                    &generic-arguments $i Array:get<_>
                    $generic-argument ~ Holes-fill
                }
                $i 1 +
            }

            // $word.type make Type.Custom & Type:contains-generic not if {
            //     $unstacker.arena $unstacker.holes &type $word.type make Type.Custom Holes-fill
            // }

            $word.token $type $word.tag make Word:MakeVariant make Word.MakeVariant
        }
        case Resolved:Word.Match -> { $unstacker flip $stack flip unstack-match make Word.Match }
        case Resolved:Word.IndirectCall -> {
            @word

            $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @function
            $unstacker.arena $stack $word.parameters.len Stack:pop-n @arguments

            $unstacker $word.token $word.parameters.len fresh-holes @parameters
            $unstacker $word.token $word.returns.len fresh-holes @return-types

            $unstacker make Source:FromIndirectCall {
                $word.token @token
                $function @function
                $return-types @return-types
                $arguments @arguments
                $parameters @parameters
            } make Source:MultiReturnNode.IndirectCall add-node @node

            0 loop {
                @i $i $word.returns.len = if { break }
                $unstacker.arena $stack
                $word.token $node $i make Source:FromNode make Source.FromNode
                Stack:push
                $i 1 +
            }

            $word.returns.len 0 = if {
                0 loop {
                    @i $i $arguments.len = if { break }
                    &arguments $i Array:get<_> @argument

                    $unstacker.arena $unstacker.voids
                    make NonSpecificVoid {
                        $word.token @token
                        $argument ~ make Maybe<Source>.Some @source
                        &word.parameters $i Array:get<_> @parameter
                        $parameter Type:contains-hole if {
                            make Maybe<Type>.None
                        } else {
                            $parameter ~ make Maybe<Type>.Some
                        } @known
                        &parameters $i Array:get<_> ~ make Maybe<InferenceHole>.Some @type
                    } make StackVoid.NonSpecific
                    Array:push<_>
                    $i 1 +
                }
                $unstacker.arena $unstacker.voids
                make IndirectCallVoid {
                    $word.token @token
                    $function ~ @function
                    $parameters @parameters
                    $return-types @returns
                } make StackVoid.IndirectCall Array:push<_>
            }

            $word.token $parameters $return-types make Word:IndirectCall make Word:Word.IndirectCall
        }
        case Resolved:Word.MakeStructNamed -> {
            @word

            $unstacker $word.type.type-definition lookup-type-definition match {
                case Resolved:TypeDefinition.Variant -> { drop Core:unreachable<.Resolved:Struct> }
                case Resolved:TypeDefinition.Struct -> {}
            } @struc

            $unstacker $word.token $struc.generic-parameters.len fresh-holes @generic-arguments

            $unstacker $word.token fresh-hole @type

            0 loop {
                @i $i $word.type.generic-arguments.len = if { break }
                $unstacker.arena $unstacker.holes

                // TODO: should we do this, when the generic argument is (or contains) a hole?
                &generic-arguments $i Array:get<_>
                &word.type.generic-arguments $i Array:get<_> ~
                Holes-fill

                $i 1 +
            }

            $unstacker.arena $struc.fields.len Array:new-with-capacity<Maybe<Source>> @argument-slots
            $unstacker $type &argument-slots with-struct-init @unstacker
            &unstacker $stack &word.body unstack-scope @body

            $unstacker.arena $struc.fields.len Array:new-with-capacity<Source> @arguments
            0 loop {
                @i $i $struc.fields.len = if { break }
                &argument-slots $i Array:get<_> Maybe:ref<_> Maybe:assert-some<_> ~
                &arguments flip Array:push-assert-no-alloc<_>
                $i 1 +
            }

            $unstacker.arena $stack
            make Source:FromMakeStruct {
                $word.token @token
                $word.name @name
                $word.type.type-definition @type-definition
                $type @type
                $generic-arguments @generic-arguments
                $arguments @arguments
            } make Source.FromMakeStruct
            Stack:push

            make Word:MakeStructNamed {
                $word.token @token
                $type @type
                $body @body
            } make Word:Word.MakeStructNamed
        }
        case Resolved:Word.FieldInit -> {
            @word

            $unstacker.arena $stack Stack:pop @source
            $unstacker.arena $unstacker.struct-field-init-arguments make Maybe<Source>.None $word.field-index $source Array:extending-set<_>

            $word.name
            $unstacker.struct-init-type Maybe:assert-some<_>
            $word.field-index
            make Word:FieldInit make Word:Word.FieldInit
        }
        case Resolved:Word.FunRef -> {
            .call @word

            $unstacker $word.function lookup-signature @signature
            $unstacker $word.name $signature.generic-parameters.len fresh-holes @generic-arguments

            &word.generic-arguments match {
                case None -> {}
                case Some -> {
                    @given-generic-arguments
                    0 loop {
                        @i $i $given-generic-arguments.len = if { break }
                        $given-generic-arguments $i Array:get<_> @generic-argument
                        $generic-argument Type:contains-hole not if {
                            $unstacker.arena $unstacker.holes &generic-arguments $i Array:get<_> $generic-argument ~ Holes-fill
                        }
                        $i 1 +
                    }
                }
            }

            $unstacker.arena $stack
            make Source:FromFunRef {
                $word.name @token
                $word.function @function
                $generic-arguments @generic-arguments
            } make Source.FromFunRef
            Stack:push

            $word.name $word.function $generic-arguments make Word:FunRef make Word:Word.FunRef
        }
        case Resolved:Word.GetField -> {
            @word

            $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @source

            $unstacker &word.fields unstack-field-accesses @fields

            $unstacker $word.token fresh-hole @base-type

            $unstacker.arena $stack
            $word.token $base-type $source $fields make Source:FromGetField make Source.FromGetField
            Stack:push

            $word.token $base-type $fields make Word:GetField make Word:Word.GetField
        }
        case _ -> {
            @word
            2 Fmt:to-fd @fmt
            &fmt $word Resolved:Word-format
            &fmt "\n" Fmt:write
            Core:unreachable<Word>
        }
    }
}

fn Stack-format(fmt: .Formatter, self: .Stack) {
    $fmt "(Stack\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "positive=" Fmt:write
    $fmt \Source-format &self.positive Array:format-multi-line<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "negative=" Fmt:write
    $fmt \Source-format &self.negative Array:format-multi-line<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parent=" Fmt:write
    $fmt \Stack-format $self.parent match {
        case None -> { make Maybe<Stack>.None }
        case Some -> { .stack ~ make Maybe<Stack>.Some }
    } & Maybe:format<_>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

fn unstack-match(unstacker: .Unstacker, stack: .Stack, word: .Resolved:Match) -> Word:Match {
    $unstacker pre-add-node @entry-node

    $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @scrutinee
    $unstacker $word.token fresh-hole @scrutinee-type

    $unstacker $word.varint lookup-type-definition match {
        case Resolved:TypeDefinition.Struct -> { drop Core:unreachable<.Resolved:Variant> }
        case Resolved:TypeDefinition.Variant -> {}
    } @varint

    $unstacker.arena
    $word.cases.len &word.default Maybe:is-some<_> !i32 + Array:new-with-capacity<MatchCaseUnstacked> @unstacked-cases

    $unstacker $word.token $varint.generic-parameters.len fresh-holes @generic-arguments

    0 loop {
        @i $i $word.cases.len = if { break }
        &word.cases $i Array:get<_> @match-case

        $unstacker.arena $unstacker.arena $stack Stack:clone Arena:push<_> $entry-node $word.token Stack:child @case-stack
        $unstacker with-cleared-reachable-flag @case-unstacker

        &varint.cases $match-case.tag Array:get<_> @variant-case
        &variant-case.type match {
            case None -> {}
            case Some -> {
                drop
                $unstacker.arena &case-stack
                $match-case.name $word.varint $generic-arguments $match-case.tag $scrutinee $scrutinee-type make Source:FromCase make Source.FromCase
                Stack:push
            }
        }

        $match-case.body.id
        &case-unstacker &case-stack &match-case.body.words unstack-words
        make Scope @body

        &unstacked-cases
        $match-case.name $match-case.tag make Maybe<i32>.Some $case-stack $body $case-unstacker.reachable not make MatchCaseUnstacked
        Array:push-assert-no-alloc<_>

        $i 1 +
    }

    &word.default match {
        case None -> {}
        case Some -> {
            @default
            $unstacker.arena $unstacker.arena $stack Stack:clone Arena:push<_> $entry-node $word.token Stack:child @case-stack

            $unstacker with-cleared-reachable-flag @case-unstacker

            $scrutinee match {
                case None -> {}
                case Some -> {
                    $scrutinee-type make Source:FromProxied make Source.FromProxied
                    $unstacker.arena flip &case-stack flip Stack:push
                }
            }

            $default.body.id
            &case-unstacker &case-stack &default.body.words unstack-words
            make Scope @body

            &unstacked-cases
            $default.underscore make Maybe<i32>.None $case-stack $body $case-unstacker.reachable not make MatchCaseUnstacked
            Array:push-assert-no-alloc<_>
        }
    }

    $unstacker $word.token \MatchCaseUnstacked-arguments-len &unstacked-cases Array:max-by<_> drop fresh-holes @parameters

    $unstacker.arena $stack $parameters.len Stack:pop-n @arguments

    $unstacker $entry-node
    $word.token $scrutinee-type $parameters $scrutinee ~ $arguments make Source:FromMatchEntry
    make Source:MultiReturnNode.MatchEntry
    fill-node

    // fixup the stack of cases which do not pop enough.
    // For example in this case:
    //   0 make Maybe<i32>.None match {
    //       case None -> { break }
    //       case Some -> {}
    //   } drop
    // because of the stack-dumping match, the number of
    // parameters of this match is correctly inferred to be 1.
    // But the stack of the Some case is (->).
    // So if we only determine the number of return values by looking at non-diverging
    // cases, then we would incorrectly say, that there are no returns.
    //
    // The solution is to make sure, that every case-stack has the right number of parameters,
    // after doing so, the stack of the Some case would be (i32 -> i32).
    //
    // The history type checker (before it was replaced by the unstacking and inference phases)
    // used a different approach in this scenario: https://github.com/Blugatroff/watim/blob/76c2d97ef64ba62269106f07ae6ac35fdc83fa38/native/checking/checker.watim#L1614
    // Because the return sources of every case need to be gathered in the unstacker, that
    // approach does not work in the unstacker.
    0 loop {
        @i $i $unstacked-cases.len = if { break }
        &unstacked-cases $i Array:get<_> @match-case
        $unstacker.arena &match-case.stack $parameters.len Stack:ensure-negatives
        $i 1 +
    }

    make Maybe<i32>.None 0 loop (Maybe<i32>, i32 -> Maybe<i32>) {
        @i $i $unstacked-cases.len = if { break }
        &unstacked-cases $i Array:get<_> @match-case
        $match-case.diverges if {} else {
                $match-case.stack.positive.len flip match {
                    case Some -> { Core:max make Maybe<i32>.Some }
                    case None -> { make Maybe<i32>.Some } } }
        $i 1 +
    } @n-returns

    $n-returns match {
        case None -> {
            0 1 = #unstacker.reachable
            make Maybe<Array<InferenceHole>>.None
        }
        case Some -> {
            @n-returns
            $unstacker.arena $unstacked-cases.len Array:new-with-capacity<Array<Source>> @returns-per-case
            0 loop {
                @i $i $unstacked-cases.len = if { break }
                &unstacked-cases $i Array:get<_> @match-case
                $match-case.diverges not if {
                    &returns-per-case
                    $unstacker.arena &match-case.stack $n-returns Stack:pop-n
                    Array:push-assert-no-alloc<_>
                }
                $i 1 +
            }
            $unstacker $word.token $n-returns fresh-holes @return-types
            $unstacker make Source:FromMatchExit {
                $word.token @token
                $return-types @return-types
                $returns-per-case @returns
                $scrutinee ~ @scrutinee
                $scrutinee-type @scrutinee-type
            } make Source:MultiReturnNode.MatchExit add-node @exit-node

            0 loop {
                @i $i $return-types.len = if { break }
                $unstacker.arena $stack
                $word.token $exit-node $i make Source:FromNode make Source:Source.FromNode
                Stack:push
                $i 1 +
            }

            $return-types make Maybe<Array<InferenceHole>>.Some
        }
    } @return-types

    $unstacker.arena &unstacked-cases \MatchCaseUnstacked-to-MatchCase Array:map-maybe<_, _> @cases

    &unstacked-cases \MatchCaseUnstacked-to-DefaultCase Array:find-map<_, _> @default

    $word.token $scrutinee-type $parameters $return-types $cases $default make Word:Match
}

fn unstack-loop(unstacker: .Unstacker, stack: .Stack, word: .Resolved:Loop) -> Word:Loop {
    Array:new<BreakStack> @loop-break-stacks

    &word.annotation match {
        case None -> { make Maybe<Array<InferenceHole>>.None }
        case Some -> {
            .returns.len ~ $unstacker flip $word.token flip fresh-holes make Maybe<Array<InferenceHole>>.Some
        }
    } @return-types-annotation

    $unstacker &loop-break-stacks &return-types-annotation Maybe:ref<_> with-break-stacks & @loop-unstacker

    $loop-unstacker pre-add-node @entry-node

    $stack $entry-node $word.token Stack:child @loop-stack

    $loop-unstacker &loop-stack &word.body unstack-scope @body

    $loop-stack.negative @arguments
    $loop-unstacker $word.token $arguments.len fresh-holes @parameters

    $loop-unstacker $entry-node make Source:FromLoopEntry {
        $word.token @token
        $arguments @arguments
        $parameters @parameters
        $loop-stack.positive @next-arguments
    } make Source:MultiReturnNode.LoopEntry fill-node

    $loop-break-stacks.len 0 /= if {
        &loop-break-stacks 0 Array:get<_> @first-break-stack

        $first-break-stack.reachable not if {
            0 1 = #unstacker.reachable
        }

        0 0 loop {
            @i $i $loop-break-stacks.len = if { break }
            &loop-break-stacks $i Array:get<_> .sources.len ~ Core:max
            $i 1 +
        } @n-returns

        $return-types-annotation match {
            case Some -> {}
            case None -> { $loop-unstacker $word.token $n-returns fresh-holes }
        } @return-types

        $loop-unstacker.arena $n-returns Array:new-with-capacity<Source:BreakReturns> @break-returns

        0 loop {
            @return-index $return-index $n-returns = if { break }

            $loop-unstacker.arena $loop-break-stacks.len Array:new-with-capacity<Source:BreakReturnSource> @sources

            0 loop {
                @i $i $loop-break-stacks.len = if { break }
                &loop-break-stacks $i Array:get<_> @break-stack

                &break-stack.sources $return-index Array:get<_> ~ $break-stack.token flip make Source:BreakReturnSource
                &sources flip Array:push-assert-no-alloc<_>
                $i 1 +
            }
            &break-returns $sources make Source:BreakReturns Array:push-assert-no-alloc<_>
            $return-index 1 +
        }

        $loop-unstacker make Source:FromLoopExit {
            $word.token @token
            $return-types @return-types
            $break-returns @break-returns
        } make Source:MultiReturnNode.LoopExit add-node @exit-node

        0 loop {
            @i $i $break-returns.len = if { break }
            $loop-unstacker.arena $stack
            $break-returns.len 1 - $i - @return-depth
            $word.token $exit-node $return-depth make Source:FromNode make Source.FromNode
            Stack:push
            $i 1 +
        }

        $word.token $parameters $return-types make Maybe<Array<InferenceHole>>.Some $body make Word:Loop

        $return-types.len 0 = if {
            0 loop (i32 ->) {
                @i $i $arguments.len = if { break }
                &arguments $i Array:get<_> @argument
                &parameters $i Array:get<_> @parameter

                $loop-unstacker.arena $loop-unstacker.voids
                make NonSpecificVoid {
                    $word.token @token
                    $word.token $entry-node $i make Source:FromNode make Source.FromNode make Maybe<Source>.Some @source
                    make Maybe<Type>.None @known
                    $parameter ~ make Maybe<InferenceHole>.Some @type
                } make StackVoid.NonSpecific
                Array:push<_>
                $i 1 +
            }
        }
    } else {
        $word.token $parameters make Maybe<Array<InferenceHole>>.None $body make Word:Loop
        0 1 = #unstacker.reachable

        0 loop (i32 ->) {
            @i $i $arguments.len = if { break }

            &arguments $i Array:get<_> @argument
            &parameters $i Array:get<_> @parameter

            $loop-unstacker.arena $loop-unstacker.voids
            make NonSpecificVoid {
                $word.token @token
                $word.token $entry-node $i make Source:FromNode make Source.FromNode make Maybe<Source>.Some @source
                make Maybe<Type>.None @known
                $parameter ~ make Maybe<InferenceHole>.Some @type
            } make StackVoid.NonSpecific
            Array:push<_>
            $i 1 +
        }
    }
}

fn unstack-if(unstacker: .Unstacker, stack: .Stack, remaining: .Array<Resolved:Word>, word: .Resolved:If) -> Word:If {
    $unstacker pre-add-node @entry-node

    $unstacker.arena $stack Stack:pop Maybe:assert-some<_> @condition

    $unstacker.arena $stack Stack:clone & $entry-node $word.token Stack:child @true-stack

    $unstacker with-cleared-reachable-flag @true-unstacker
    &true-unstacker &true-stack &word.true-branch unstack-scope @true-body

    $word.false-branch.words.len 0 = $true-unstacker.reachable not and if {
        $unstacker.arena $stack Stack:clone & $entry-node $word.token Stack:child @remaining-stack

        // This makes sure, that the parameters of the true-branch and
        // the synthesized false-branch made up of all subsequent words match.
        $unstacker.arena &remaining-stack $true-stack.negative.len Stack:ensure-negatives

        $unstacker with-cleared-reachable-flag @remaining-unstacker
        &remaining-unstacker &remaining-stack $remaining unstack-words @remaining-words
        $word.false-branch.id $remaining-words make Scope @remaining-body

        $unstacker $word.token $true-stack.negative.len $remaining-stack.negative.len Core:max fresh-holes @parameters

        $unstacker.arena $stack $parameters.len Stack:pop-n @arguments

        $unstacker.arena &true-stack $parameters.len Stack:ensure-negatives
        $unstacker.arena &remaining-stack $parameters.len Stack:ensure-negatives

        // The true-branch already diverges.
        // If the false-branch diverges, then nothing after this if is reachable.
        $remaining-unstacker.reachable #unstacker.reachable

        $unstacker $entry-node
        $word.token $condition $parameters $arguments make Source:FromIfEntry
        make Source:MultiReturnNode.IfEntry fill-node

        $unstacker.reachable if {
            $unstacker $word.token $remaining-stack.positive.len fresh-holes
            make Maybe<Array<InferenceHole>>.Some
        } else {
            make Maybe<Array<InferenceHole>>.None
        } @return-types

        &return-types match {
            case None -> { 1 1 = }
            case Some -> {
                @return-types
                $return-types.len 0 /= if {
                    $unstacker make Source:FromIfExit {
                        $word.token @token
                        $condition @condition
                        $arguments @arguments
                        $return-types ~ @return-types
                        make Maybe<Array<Source>>.None @true-branch-returns
                        $remaining-stack.positive @false-branch-returns
                    } make Source:MultiReturnNode.IfExit add-node @exit-node

                    0 loop {
                        @i $i $remaining-stack.positive.len = if {
                            break
                        }
                        $remaining-stack.positive.len $i - 1 - @return-depth
                        $unstacker.arena $stack
                        $word.token $exit-node $return-depth make Source:FromNode make Source:Source.FromNode
                        Stack:push
                        $i 1 +
                    }
                    0 1 =
                } else {
                    1 1 =
                }
            }
        } if {
            0 loop (i32 ->) {
                @i $i $arguments.len = if { break }
                &arguments $i Array:get<_> @argument
                &parameters $i Array:get<_> @parameter

                $unstacker.arena $unstacker.voids
                make NonSpecificVoid {
                    $word.token @token
                    $word.token $entry-node $i make Source:FromNode make Source.FromNode make Maybe<Source>.Some @source
                    make Maybe<Type>.None @known
                    $parameter ~ make Maybe<InferenceHole>.Some @type
                } make StackVoid.NonSpecific
                Array:push<_>
                $i 1 +
            }
            $unstacker.arena $unstacker.voids
            make NonSpecificVoid {
                $word.token @token
                $condition make Maybe<Source>.Some @source
                make Type.Bool make Maybe<Type>.Some @known
                make Maybe<InferenceHole>.None @type
            } make StackVoid.NonSpecific Array:push<_>
        }

        $word.token $parameters $return-types $true-body $remaining-body make Word:If
    } else {
        $unstacker with-cleared-reachable-flag @false-unstacker
        $unstacker.arena $stack Stack:clone & $entry-node $word.token Stack:child @false-stack

        &false-unstacker &false-stack &word.false-branch unstack-scope @false-body

        $unstacker.arena $stack
        $true-stack.negative.len $false-stack.negative.len Core:max
        Stack:pop-n @arguments

        $unstacker $word.token $arguments.len fresh-holes @parameters
        $unstacker $word.token $true-stack.positive.len $false-stack.positive.len Core:max fresh-holes @return-types

        $unstacker $entry-node
        $word.token $condition $parameters $arguments make Source:FromIfEntry
        make Source:MultiReturnNode.IfEntry fill-node

        $arguments.len 0 = $return-types.len 0 = and if {
            $unstacker.arena $unstacker.voids
            $word.token
            $condition make Maybe<Source>.Some
            make Type.Bool make Maybe<Type>.Some
            make Maybe<InferenceHole>.None
            make NonSpecificVoid
            make StackVoid.NonSpecific
            Array:push<_>
        } else {
            $unstacker make Source:FromIfExit {
                $word.token @token
                $condition @condition
                $arguments @arguments
                $return-types @return-types
                $unstacker.arena &true-stack $return-types.len Stack:pop-n make Maybe<Array<Source>>.Some @true-branch-returns
                $unstacker.arena &false-stack $return-types.len Stack:pop-n @false-branch-returns
            } make Source:MultiReturnNode.IfExit add-node @exit-node

            0 loop {
                @i $i $return-types.len = if {
                    break
                }
                $return-types.len 1 - $i - @return-depth
                $unstacker.arena $stack
                $word.token $exit-node $return-depth make Source:FromNode make Source:Source.FromNode
                Stack:push
                $i 1 +
            }
        }

        $word.token $parameters $return-types make Maybe<Array<InferenceHole>>.Some $true-body $false-body make Word:If
    }
}

fn unstack-store-local(unstacker: .Unstacker, stack: .Stack, word: .Resolved:StoreLocal) -> Word:StoreLocal {
    $unstacker.arena $stack Stack:pop @source
    $unstacker &word.fields unstack-field-accesses @fields
    $unstacker $word.name fresh-hole @field-type
    $word.var match {
        case VarId.Local -> {
            @local-id
            $unstacker.locals &local-id Map:get<_, _> Maybe:assert-some<_> @local
            $unstacker.arena &local.assignments
            $word.name $source $fields $field-type 1 1 = make Assignment
            Array:push<_>

            make Word:StoreLocal {
                $local-id @local
                $local-id @var
                $word.name @name
                $fields @fields
                $field-type @field-type
            }
        }
        case VarId.Global -> {
            @global-id
            Core:unreachable<Word:StoreLocal>
        }
    }
}

fn unstack-call(unstacker: .Unstacker, stack: .Stack, word: .Resolved:Call) -> Word:Call {
    $unstacker $word.function lookup-signature @signature

    $unstacker.arena $stack $signature.parameters.len Stack:pop-n @arguments

    $unstacker $word.name $signature.generic-parameters.len fresh-holes @generic-arguments
    // $unstacker $word.name $signature.parameters.len fresh-holes @parameters
    //
    // 0 loop {
    //     @i $i $arguments.len = if { break }
    //     &arguments $i
    //     $unstacker.arena &arguments $i Array:get<_> ~ Arena:push<_>
    //     &parameters $i Array:get<_> ~ make Source:FromProxied make Source.FromProxied
    //     Array:set<_> drop
    //     $i 1 +
    // }

    &word.generic-arguments match {
        case None -> {}
        case Some -> {
            @annotated-generic-arguments
            0 loop {
                @i $i $annotated-generic-arguments.len = if { break }
                $annotated-generic-arguments $i Array:get<_> match {
                    case Type.Hole -> { drop }
                    case _ -> {
                        $unstacker.arena flip
                        $unstacker.holes flip
                        &generic-arguments $i Array:get<_> flip
                        ~ Holes-fill
                    }
                }
                $i 1 +
            }
        }
    }

    $unstacker
    $word.name $word.function $generic-arguments $arguments make Source:FromCall make Source:MultiReturnNode.Call
    add-node @node-index

    0 loop {
        @i $i $signature.returns.len = if { break }
        $unstacker.arena $stack $word.name $node-index $i make Source:FromNode make Source.FromNode Stack:push
        $i 1 +
    }

    $signature.returns.len 0 = if {
        $unstacker.arena $unstacker.voids
        make CallVoid {
            $word.name @token
            $word.function @function
            $arguments @arguments
            $generic-arguments @generic-arguments
        } make StackVoid.Call
        Array:push<_>
    }

    make Word:Call {
        $word.name @name
        $word.function @function
        $generic-arguments @generic-arguments
        $arguments @arguments
    }
}

fn unstack-set-local(unstacker: .Unstacker, stack: .Stack, word: .Resolved:SetLocal) -> Word:Word {
    $unstacker.arena $stack Stack:pop @source
    $unstacker &word.fields unstack-field-accesses @fields
    $fields.len 0 = if {
        $unstacker $word.name fresh-hole
    } else {
        &fields $fields.len 1 - Array:get<_> .target-type ~
    } @field-type
    $word.var match {
        case VarId.Local -> {
            @local-id

            $unstacker.locals &local-id Map:get<_, _> Maybe:assert-some<_> @local
            $unstacker.arena &local.assignments
            $word.name $source $fields $field-type 0 1 = make Assignment
            Array:push<_>

            make Word:SetLocal {
                $local-id @local
                $word.var @var
                $word.name @name
                $fields @fields
                $field-type @field-type
            } make Word:Word.SetLocal
        }
        case VarId.Global -> {
            @global-id

            make Word:SetGlobal {
                $global-id @globl
                $word.name @name
                $fields @fields
                $field-type @field-type
            } make Word:Word.SetGlobal

            $unstacker.arena $unstacker.voids
            make SetGlobalVoid {
                $word.name @token
                $unstacker $global-id lookup-global .type ~ @global-type
                $fields @fields
                $source @source
                $field-type @type
            } make StackVoid.SetGlobal
            Array:push<_>
        }
    }
}

fn unstack-intrinsic(unstacker: .Unstacker, stack: .Stack, word: .Resolved:IntrinsicWord) -> Word:Intrinsic {
    $word.intrinsic match {
        case Resolved:Intrinsic.Add -> {
            make Word:Add {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-add/sub @type
            } make Word:Intrinsic.Add
        }
        case Resolved:Intrinsic.Sub -> {
            make Word:Sub {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-add/sub @type
            } make Word:Intrinsic.Sub
        }
        case Resolved:Intrinsic.Eq -> {
            make Word:Eq {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-eq/noteq @type
            } make Word:Intrinsic.Eq
        }
        case Resolved:Intrinsic.NotEq -> {
            make Word:NotEq {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-eq/noteq @type
            } make Word:Intrinsic.NotEq
        }
        case Resolved:Intrinsic.Uninit -> {
            $unstacker &word.token &word.generic-arguments 1 unstack-generic-arguments @generic-arguments
            make Source:FromUninit {
                $word.token @token
                $generic-arguments @generic-arguments
            } make Source:FromIntrinsic.Uninit make Source.FromIntrinsic
            $unstacker.arena flip $stack flip Stack:push
            make Word:Uninit {
                $word.token @token
                &generic-arguments 0 Array:get<_> ~ @type
            } make Word:Intrinsic.Uninit
        }
        case Resolved:Intrinsic.Drop -> {
            $unstacker $word.token fresh-hole @type
            $unstacker.arena $stack Stack:pop @src
            $unstacker.arena $unstacker.voids
            $word.token $src make Maybe<Type>.None $type make Maybe<InferenceHole>.Some make NonSpecificVoid make StackVoid.NonSpecific
            Array:push<_>
            make Word:Drop {
                $word.token @token
                $type @type
            } make Word:Intrinsic.Drop
        }
        case Resolved:Intrinsic.Mod -> {
            make Word:Mod {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-mul/div/mod @type
            } make Word:Intrinsic.Mod
        }
        case Resolved:Intrinsic.Mul -> {
            make Word:Mul {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-mul/div/mod @type
            } make Word:Intrinsic.Mul
        }
        case Resolved:Intrinsic.Div -> {
            make Word:Div {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-mul/div/mod @type
            } make Word:Intrinsic.Div
        }
        case Resolved:Intrinsic.Ge -> {
            make Word:Ge {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-lt/gt/le/ge @type
            } make Word:Intrinsic.Ge
        }
        case Resolved:Intrinsic.Le -> {
            make Word:Le {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-lt/gt/le/ge @type
            } make Word:Intrinsic.Le
        }
        case Resolved:Intrinsic.Gt -> {
            make Word:Gt {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-lt/gt/le/ge @type
            } make Word:Intrinsic.Gt
        }
        case Resolved:Intrinsic.Lt -> {
            make Word:Lt {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-lt/gt/le/ge @type
            } make Word:Intrinsic.Lt
        }
        case Resolved:Intrinsic.Store -> {
            make Word:Store {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-store @type
            } make Word:Intrinsic.Store
        }
        case Resolved:Intrinsic.And -> {
            make Word:And {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-and/or @type
            } make Word:Intrinsic.And
        }
        case Resolved:Intrinsic.Or -> {
            make Word:Or {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-and/or @type
            } make Word:Intrinsic.Or
        }
        case Resolved:Intrinsic.MemCopy -> {
            $unstacker $stack &word.token unstack-intrinsic-mem-copy
            $word.token make Word:Intrinsic.MemCopy
        }
        case Resolved:Intrinsic.MemFill -> {
            $unstacker $stack &word.token unstack-intrinsic-mem-fill
            $word.token make Word:Intrinsic.MemFill
        }
        case Resolved:Intrinsic.MemGrow -> {
            $unstacker $stack &word.token unstack-intrinsic-mem-grow
            $word.token make Word:Intrinsic.MemGrow
        }
        case Resolved:Intrinsic.Flip -> {
            $unstacker.arena $stack Stack:pop @a
            $unstacker.arena $stack Stack:pop @b

            $unstacker $word.token fresh-hole @lower
            $unstacker $word.token fresh-hole @upper

            $a match {
                case Some -> {
                    $unstacker.arena flip Arena:push<_>
                    $lower make Source:FromProxied make Source.FromProxied
                    $unstacker.arena flip $stack flip Stack:push
                }
                case None -> {}
            }
            $b match {
                case Some -> {
                    $unstacker.arena flip Arena:push<_>
                    $upper make Source:FromProxied make Source.FromProxied
                    $unstacker.arena flip $stack flip Stack:push
                }
                case None -> {}
            }
            $word.token $lower $upper make Word:Flip make Word:Intrinsic.Flip
        }
        case Resolved:Intrinsic.Shl -> {
            make Word:Shl {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-mul/div/mod @type
            } make Word:Intrinsic.Shl
        }
        case Resolved:Intrinsic.Shr -> {
            make Word:Shr {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-mul/div/mod @type
            } make Word:Intrinsic.Shr
        }
        case Resolved:Intrinsic.Rotl -> {
            make Word:Rotl {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-mul/div/mod @type
            } make Word:Intrinsic.Rotl
        }
        case Resolved:Intrinsic.Rotr -> {
            make Word:Rotr {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-mul/div/mod @type
            } make Word:Intrinsic.Rotr
        }
        case Resolved:Intrinsic.Not -> {
            make Word:Not {
                $word.token @token
                $unstacker $stack &word.token unstack-intrinsic-not @type
            } make Word:Intrinsic.Not
        }
        case Resolved:Intrinsic.SetStackSize -> {
            $unstacker $stack &word.token unstack-intrinsic-set-stack-size
            $word.token make Word:Intrinsic.SetStackSize
        }
    }
}

fn unstack-get-local(unstacker: .Unstacker, stack: .Stack, word: .Resolved:GetLocal) -> Word:Word {
    $word.var match {
        case VarId.Local -> {
            @local-id
            $unstacker.locals &local-id Map:get<_, _> Maybe:assert-some<_> @local
            $unstacker $word.name fresh-hole @result-type

            $unstacker &word.fields unstack-field-accesses @fields

            $word.name $local-id $local.type $fields $result-type 0 1 = make Source:FromLocal
            make Source.FromLocal
            $unstacker.arena flip $stack flip Stack:push

            make Word:GetLocal {
                $word.name @name
                $word.var @var
                $local.type @var-type
                $fields @fields
                $result-type @result-type
            } make Word.GetLocal
        }
        case VarId.Global -> {
            @global-id
            $unstacker $global-id lookup-global @globl

            $unstacker $word.name fresh-hole @var-type
            $unstacker.arena $unstacker.holes &var-type $globl.type Holes-fill
            $unstacker $word.name fresh-hole @result-type
            $unstacker &word.fields unstack-field-accesses @fields

            $word.name $global-id $globl.type $fields $result-type 0 1 = make Source:FromGlobal
            make Source.FromGlobal
            $unstacker.arena flip $stack flip Stack:push

            make Word:GetLocal {
                $word.name @name
                $word.var @var
                $var-type @var-type
                $fields @fields
                $result-type @result-type
            } make Word.GetLocal
        }
    }
}
fn unstack-ref-local(unstacker: .Unstacker, stack: .Stack, word: .Resolved:RefLocal) -> Word:Word {
    $word.var match {
        case VarId.Local -> {
            @local-id
            $unstacker.locals &local-id Map:get<_, _> Maybe:assert-some<_> @local
            1 1 = #local.reffed
            $unstacker $word.name fresh-hole @result-type

            $unstacker &word.fields unstack-field-accesses @fields

            $word.name $local-id $local.type $fields $result-type 1 1 = make Source:FromLocal
            make Source.FromLocal
            $unstacker.arena flip $stack flip Stack:push

            make Word:RefLocal {
                $word.name @name
                $word.var @var
                $local.type @var-type
                $fields @fields
                $result-type @result-type
            } make Word.RefLocal
        }
        case VarId.Global -> {
            @global-id
            $unstacker $global-id lookup-global @globl

            $unstacker $word.name fresh-hole @var-type
            $unstacker.arena $unstacker.holes &var-type $globl.type Holes-fill
            $unstacker $word.name fresh-hole @result-type
            $unstacker &word.fields unstack-field-accesses @fields

            $word.name $global-id $globl.type $fields $result-type 1 1 = make Source:FromGlobal
            make Source.FromGlobal
            $unstacker.arena flip $stack flip Stack:push

            make Word:RefLocal {
                $word.name @name
                $word.var @var
                $var-type @var-type
                $fields @fields
                $result-type @result-type
            } make Word.RefLocal
        }
    }
}

fn unstack-block(unstacker: .Unstacker, stack: .Stack, word: .Resolved:Block) -> Word:Block {
    Array:new<BreakStack> @block-break-stacks

    &word.annotation match {
        case None -> { make Maybe<Array<InferenceHole>>.None }
        case Some -> {
            .returns.len ~ $unstacker flip $word.token flip fresh-holes make Maybe<Array<InferenceHole>>.Some
        }
    } @return-types-annotation

    $unstacker &block-break-stacks &return-types-annotation Maybe:ref<_> with-break-stacks & @unstacker

    $unstacker pre-add-node @entry-node

    $stack $entry-node $word.token Stack:child @block-stack

    $unstacker with-cleared-reachable-flag @loop-unstacker

    &loop-unstacker &block-stack &word.body unstack-scope @body

    $loop-unstacker.reachable if {
        $unstacker.arena &block-break-stacks make BreakStack {
            $word.end @token
            $block-stack.positive @sources
            1 1 = @reachable
        } Array:push<_>
    }

    $block-stack.negative @arguments
    $unstacker $word.token $arguments.len fresh-holes @parameters

    $unstacker $entry-node make Source:FromBlockEntry {
        $word.token @token
        $arguments @arguments
        $parameters @parameters
    } make Source:MultiReturnNode.BlockEntry fill-node

    $return-types-annotation match {
        case Some -> { @return-types $return-types $return-types.len }
        case None -> {
            0 0 loop {
                @i $i $block-break-stacks.len = if { break }
                &block-break-stacks $i Array:get<_> .sources.len ~ Core:max
                $i 1 +
            } @n-returns
            $unstacker $word.token $n-returns fresh-holes
            $n-returns
        }
    } @n-returns @return-types

    $unstacker.arena $n-returns Array:new-with-capacity<Source:BreakReturns> @break-returns
    0 loop {
        @return-index $return-index $n-returns = if { break }

        $unstacker.arena $block-break-stacks.len Array:new-with-capacity<Source:BreakReturnSource> @returns

        0 loop {
            @i $i $block-break-stacks.len = if { break }
            &block-break-stacks $i Array:get<_> @break-stack

            &break-stack.sources $return-index Array:get<_> ~ $break-stack.token flip make Source:BreakReturnSource
            &returns flip Array:push-assert-no-alloc<_>
            $i 1 +
        }
        &break-returns $returns make Source:BreakReturns Array:push-assert-no-alloc<_>
        $return-index 1 +
    }

    $return-types.len 0 /= if {
        $unstacker make Source:FromBlockExit {
            $word.token @token
            $return-types @return-types
            $break-returns @break-returns
        } make Source:MultiReturnNode.BlockExit add-node @exit-node
        0 loop {
            @i $i $break-returns.len = if { break }
            $unstacker.arena $stack
            $break-returns.len 1 - $i - @return-depth
            $word.token $exit-node $return-depth make Source:FromNode make Source.FromNode
            Stack:push
            $i 1 +
        }
    }
    $word.token $parameters $return-types $body make Word:Block
}

fn unstack-break(unstacker: .Unstacker, stack: .Stack, token: .Token) -> Token {
    $unstacker.block-returns match {
        case None -> {
            $unstacker.arena $stack Stack:dump
        }
        case Some -> {
            .len ~ $unstacker.arena flip $stack flip Stack:pop-n

            $stack Stack:size loop (i32 ->) {
                @size $size 0 = if { break }

                $token ~
                $stack $size 1 - Stack:index ~ make Maybe<Source>.Some
                make Maybe<Type>.None
                make Maybe<InferenceHole>.None
                make NonSpecificVoid make StackVoid.NonSpecific
                $unstacker.arena flip $unstacker.voids flip Array:push<_>

                $size 1 -
            }
        }
    } @dump

    $unstacker.arena
    &unstacker.break-stacks Maybe:ref<_> Maybe:assert-some<_> ~
    make BreakStack {
        $token ~ @token
        $dump @sources
        $unstacker.reachable @reachable
    } Array:push<BreakStack>

    0 1 = #unstacker.reachable
    $token ~
}

struct MatchCaseUnstacked {
    name: Token
    tag: Maybe<i32> // only the default case doesn't have a tag
    stack: Stack
    body: Scope
    diverges: bool
}
fn MatchCaseUnstacked-arguments-len(self: .MatchCaseUnstacked) -> i32 { $self.stack.negative.len }
fn MatchCaseUnstacked-to-MatchCase(self: .MatchCaseUnstacked) -> Maybe<Word:MatchCase> {
    $self.tag match {
        case None -> { make Maybe<Word:MatchCase>.None }
        case Some -> {
            $self.name flip $self.body make Word:MatchCase make Maybe<Word:MatchCase>.Some } }
}
fn MatchCaseUnstacked-to-DefaultCase(self: .MatchCaseUnstacked) -> Maybe<Word:DefaultCase> {
    $self.tag match {
        case None -> {
            $self.name $self.body make Word:DefaultCase make Maybe<Word:DefaultCase>.Some
        }
        case Some -> { drop make Maybe<Word:DefaultCase>.None }
    }
}
fn MatchCaseUnstacked-format(fmt: .Formatter, self: .MatchCaseUnstacked) {
    $fmt "(MatchCaseUnstacked\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "tag=" Fmt:write
    $fmt \i32-format-ref &self.tag Maybe:format<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "stack-positive=" Fmt:write
    $fmt \Source-format &self.stack.positive Array:format-multi-line<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "stack-negative=" Fmt:write
    $fmt \Source-format &self.stack.negative Array:format-multi-line<_>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "body=" Fmt:write
    $fmt &self.body Scope-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "diverges=" Fmt:write
    $fmt $self.diverges bool-format
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

fn unstack-intrinsic-add/sub(unstacker: .Unstacker, stack: .Stack, token: .Token) -> InferenceHole {
    $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @addition
    $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @base

    $unstacker $token ~ fresh-hole @type

    $token ~ $base $addition $type make Source:FromAdd make Source:FromIntrinsic.Add make Source.FromIntrinsic
    $unstacker.arena flip $stack flip Stack:push
    $type
}

fn unstack-intrinsic-mul/div/mod(unstacker: .Unstacker, stack: .Stack, token: .Token) -> InferenceHole {
    $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @addition
    $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @base

    $unstacker $token ~ fresh-hole @type

    $token ~ $base $addition $type make Source:FromMul make Source:FromIntrinsic.Mul make Source.FromIntrinsic
    $unstacker.arena flip $stack flip Stack:push
    $type
}

fn unstack-intrinsic-not(unstacker: .Unstacker, stack: .Stack, token: .Token) -> InferenceHole {
    $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @source
    $unstacker $token ~ fresh-hole @type
    $token ~ $type $source make Source:FromNot make Source:FromIntrinsic.Not make Source.FromIntrinsic
    $unstacker.arena flip $stack flip Stack:push
    $type
}

fn unstack-intrinsic-eq/noteq(unstacker: .Unstacker, stack: .Stack, token: .Token) -> InferenceHole {
    $unstacker $token ~ fresh-hole @type
    $unstacker.arena $stack make Source:FromEq {
        $token ~ @token
        $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @a
        $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @b
        $type @type
    } make Source:FromIntrinsic.Eq make Source.FromIntrinsic Stack:push
    $type
}

fn unstack-intrinsic-lt/gt/le/ge(unstacker: .Unstacker, stack: .Stack, token: .Token) -> InferenceHole {
    $unstacker $token ~ fresh-hole @type
    $unstacker.arena $stack make Source:FromGe {
        $token ~ @token
        $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @a
        $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @b
        $type @type
    } make Source:FromIntrinsic.Ge make Source.FromIntrinsic Stack:push
    $type
}

fn unstack-intrinsic-and/or(unstacker: .Unstacker, stack: .Stack, token: .Token) -> InferenceHole {
    $unstacker $token ~ fresh-hole @type
    $unstacker.arena $stack make Source:FromAnd {
        $token ~ @token
        $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @a
        $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @b
        $type @type
    } make Source:FromIntrinsic.And make Source.FromIntrinsic Stack:push
    $type
}

fn unstack-intrinsic-store(unstacker: .Unstacker, stack: .Stack, token: .Token) -> InferenceHole {
    $unstacker $token ~ fresh-hole @type

    $unstacker.arena $unstacker.voids
    make StoreVoid {
        $token ~ @token
        $unstacker.arena $stack Stack:pop @src
        $unstacker.arena $stack Stack:pop @dst
        $type @type
    } make StackVoid.Store Array:push<_>

    $type
}

fn unstack-intrinsic-mem-copy(unstacker: .Unstacker, stack: .Stack, token: .Token) {
    $unstacker.arena make Type.I8 Arena:push<_> make Type.Ptr @ptr-i8

    $unstacker.arena $unstacker.voids make NonSpecificVoid {
        $token ~ @token
        $unstacker.arena $stack Stack:pop @source
        make Type.I32 make Maybe<Type>.Some @known
        make Maybe<InferenceHole>.None @type
    } make StackVoid.NonSpecific Array:push<_>

    $unstacker.arena $unstacker.voids make NonSpecificVoid {
        $token ~ @token
        $unstacker.arena $stack Stack:pop @source
        $ptr-i8 make Maybe<Type>.Some @known
        make Maybe<InferenceHole>.None @type
    } make StackVoid.NonSpecific Array:push<_>

    $unstacker.arena $unstacker.voids make NonSpecificVoid {
        $token ~ @token
        $unstacker.arena $stack Stack:pop @source
        $ptr-i8 make Maybe<Type>.Some @known
        make Maybe<InferenceHole>.None @type
    } make StackVoid.NonSpecific Array:push<_>
}

fn unstack-intrinsic-mem-fill(unstacker: .Unstacker, stack: .Stack, token: .Token) {
    $unstacker.arena $unstacker.voids make NonSpecificVoid {
        $token ~ @token
        $unstacker.arena $stack Stack:pop @source
        make Type.I32 make Maybe<Type>.Some @known
        make Maybe<InferenceHole>.None @type
    } make StackVoid.NonSpecific Array:push<_>

    $unstacker.arena $unstacker.voids make NonSpecificVoid {
        $token ~ @token
        $unstacker.arena $stack Stack:pop @source
        make Type.I8 make Maybe<Type>.Some @known
        make Maybe<InferenceHole>.None @type
    } make StackVoid.NonSpecific Array:push<_>

    $unstacker.arena $unstacker.voids make NonSpecificVoid {
        $token ~ @token
        $unstacker.arena $stack Stack:pop @source
        $unstacker.arena make Type.I8 Arena:push<_> make Type.Ptr make Maybe<Type>.Some @known
        make Maybe<InferenceHole>.None @type
    } make StackVoid.NonSpecific Array:push<_>
}

fn unstack-intrinsic-mem-grow(unstacker: .Unstacker, stack: .Stack, token: .Token) {
    $unstacker.arena $unstacker.arena $stack Stack:pop Arena:push<_> @source

    $unstacker.arena $stack
    $token ~ $source make Source:FromMemGrow make Source:FromIntrinsic.MemGrow make Source.FromIntrinsic
    Stack:push
}

fn unstack-intrinsic-set-stack-size(unstacker: .Unstacker, stack: .Stack, token: .Token) {
    $unstacker.arena $unstacker.voids make NonSpecificVoid {
        $token ~ @token
        $unstacker.arena $stack Stack:pop @source
        make Type.I32 make Maybe<Type>.Some @known
        make Maybe<InferenceHole>.None @type
    } make StackVoid.NonSpecific Array:push<_>
}

fn unstack-generic-arguments(unstacker: .Unstacker, token: .Token, generic-arguments: .Array<Type>, expected-arguments: i32) -> Array<InferenceHole> {
    $unstacker.arena $generic-arguments.len $expected-arguments Core:max Array:new-with-capacity<InferenceHole> @holes
    0 loop {
        @i $i $expected-arguments = if { $holes break }
        $i $generic-arguments.len lt if {
            $generic-arguments $i Array:get<_> @generic-argument
            $generic-argument match {
                case Type.Hole -> {
                    $unstacker flip ~ fresh-hole
                }
                case _ -> {
                    $unstacker $token ~ fresh-hole @hole
                    $unstacker.arena flip $unstacker.holes flip &hole flip ~ Holes-fill
                    $hole
                }
            }
        } else {
            $unstacker $token ~ fresh-hole
        }
        &holes flip Array:push-assert-no-alloc<_>
        $i 1 +
    }
}

fn unstack-field-accesses(unstacker: .Unstacker, accesses: .Array<Token>) -> Array<Word:FieldAccess> {
    $unstacker.arena $accesses.len Array:new-with-capacity<Word:FieldAccess> @unstacked-accesses
    0 loop {
        @i $i $accesses.len = if { break }
        &unstacked-accesses
        $unstacker $accesses $i Array:get<_> unstack-field-access
        Array:push-assert-no-alloc<_>
        $i 1 +
    }
    $unstacked-accesses
}

fn unstack-field-access(unstacker: .Unstacker, access: .Token) -> Word:FieldAccess {
    make Word:FieldAccess {
        $access ~ @name
        $unstacker fresh-field-hole @field-index
        $unstacker $access ~ fresh-hole @source-type
        $unstacker $access ~ fresh-hole @target-type
    }
}

