import "../std/alloc.watim" as A
import "../std/i32vec.watim" as IV
import "./ast.watim" as AST

struct BreakStack {
    word: .AST:Word
    types: .AST:Types
}
fn BreakStack-new(word: .AST:Word, types: .AST:Types) -> .BreakStack {
    local self: .BreakStack
    8 A:alloc !.BreakStack #self
    $self.word $word store32
    $self.types $types store32
    $self
}
fn BreakStack-free(self: .BreakStack) {
    $self.types load32 AST:Types-free-container
    $self !.i32 A:free
}
fn BreakStack-word(self: .BreakStack) -> .AST:Word {
    $self.word load32
}
fn BreakStack-types(self: .BreakStack) -> .AST:Types {
    $self.types load32
}

struct BreakStacks {
    inner: .IV:I32Vec
}
fn BreakStacks-new() -> .BreakStacks {
    local self: .BreakStacks
    4 A:alloc !.BreakStacks #self
    $self.inner IV:I32Vec-new store32
    $self
}
fn BreakStacks-len(self: .BreakStacks) -> i32 {
    $self.inner load32 IV:I32Vec-len
}
fn BreakStacks-get(self: .BreakStacks, index: i32) -> .BreakStack {
    $self.inner load32 $index IV:I32Vec-get !.BreakStack
}
fn BreakStacks-free(self: .BreakStacks) {
    local i: i32
    loop {
        $i $self BreakStacks-len = if { break }
        $self $i BreakStacks-get BreakStack-free
        $i 1 + #i
    }
    $self.inner load32 IV:I32Vec-free
    $self !.i32 A:free
}
fn BreakStacks-push(self: .BreakStacks, bs: .BreakStack) {
    $self.inner load32 $bs !i32 IV:I32Vec-push
}

