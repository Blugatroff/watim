import "../../std/core.watim" as Core
import "../../std/result.watim" as Result (Result)
import "../../std/bytes.watim" as Bytes
import "../../std/io.watim" as IO
import "../../std/maybe.watim" as Maybe (Maybe, assert-some)
import "../../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../../std/byte-array.watim" as ByteArray (ByteArray)
import "../../std/array.watim" as Array (Array)
import "../../std/map.watim" as Map (Map)
import "../../std/arena.watim" as Arena (Arena)
import "../../std/fs.watim" as FS
import "../../std/util.watim" as Util (i32-format, bool-format)
import "../../std/fmt.watim" as Fmt (Formatter, ByteSlice-format)
import "../../std/list.watim" as List (List)

import "../logging.watim" as Logging
import "../lexer.watim" as Lexer (
    Token, Token-lexeme, Token-location, Token-line, Token-column,
    Token-eq-to-lexeme, Token-string-content, Token-format
)
import "../parser.watim" as P (TopItem)
import "../type.watim" as Type (
    Type, Type-eq, Type-format, Type-pretty,
    Types-eq, Types-format, Types-pretty, Types-pretty-bracketed,
    CustomTypeType, CustomTypeType-format, CustomType, CustomType-name, CustomType-format, CustomType-generic-parameters,
    FunType, FunType-format, TupleType,  VariantCase-name,
    NamedType, NamedType-format, NamedType-type,
    ModuleId, TypeLookup, lookup-type,
    Struct, Variant, VariantCase,
    CustomTypeHandle, CustomTypeHandle-eq, CustomTypeHandle-format
)
import "../env.watim" as Env (Env, new, child, Local, ScopeId, ScopeId-format, LocalId, LocalId-format, Local-format)

struct FunctionHandle { module: ModuleId index: i32 }
fn FunctionHandle-format(fmt: .Formatter, self: .FunctionHandle) {
    $fmt "(FunctionHandle " Fmt:write
    $fmt $self.module.index i32-format
    $fmt " " Fmt:write
    $fmt $self.index i32-format
    $fmt ")" Fmt:write
}
fn FunctionHandle-eq(self: .FunctionHandle, other: .FunctionHandle) -> bool {
    $self.module.index $other.module.index =
    $self.index $other.index = and
}

variant ImportItemItem {
    case Function -> FunctionHandle
    case CustomType -> CustomTypeHandle
}

struct ImportItem {
    name: Token
    handle: ImportItemItem
}
fn ImportItem-format(fmt: .Formatter, self: .ImportItem) {
    $fmt "(ImportItem " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.handle match {
        case Function -> { FunctionHandle-format }
        case CustomType -> { CustomTypeHandle-format }
    }
    $fmt ")" Fmt:write
}

struct Import {
    token: Token
    module: ModuleId
    path: ByteSlice
    qualifier: Token
    items: Array<ImportItem>
}
fn Import-format(fmt: .Formatter, self: .Import) {
    $fmt "(Import " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt $self.module.index i32-format
    $fmt " " Fmt:write
    $fmt &self.path ByteSlice-format
    $fmt " " Fmt:write
    $fmt &self.qualifier Token-format
    $fmt " " Fmt:write
    $fmt \ImportItem-format &self.items Array:format-multi-line<ImportItem>
    $fmt ")" Fmt:write
}

struct Global {
    name: Token
    type: Type
    reffed: bool
}
fn Global-format(fmt: .Formatter, self: .Global) {
    $fmt "(Global " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt " " Fmt:write
    $fmt $self.reffed bool-format
    $fmt ")" Fmt:write
}

struct Signature {
    generic-parameters: Array<Token>
    parameters: Array<NamedType>
    returns: Array<Type>
}
fn Signature-format(fmt: .Formatter, self: .Signature) {
    $fmt "(Signature\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "generic-parameters=" Fmt:write
    $fmt \Token-format &self.generic-parameters Array:format<Token>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt \NamedType-format &self.parameters Array:format<NamedType>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt &self.returns Types-format
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct Extern {
    name: Token
    extrn-module: ByteSlice
    extrn-name: ByteSlice
    signature: Signature
}
fn Extern-format(fmt: .Formatter, self: .Extern) {
    $fmt "(Extern " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.extrn-module ByteSlice-format
    $fmt " " Fmt:write
    $fmt &self.extrn-name ByteSlice-format
    $fmt " " Fmt:write
    $fmt &self.signature Signature-format
    $fmt ")" Fmt:write
}

struct GlobalId {
    name: Token
    module: ModuleId
    index: i32
}
fn GlobalId-format(fmt: .Formatter, self: .GlobalId) {
    $fmt "(GlobalId " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt $self.module.index i32-format
    $fmt " " Fmt:write
    $fmt $self.index i32-format
    $fmt ")" Fmt:write
}

variant VarId {
    case Local -> LocalId
    case Global -> GlobalId
}
fn VarId-format(fmt: .Formatter, self: .VarId) {
    $self match {
        case Local -> { $fmt flip LocalId-format }
        case Global -> { $fmt flip GlobalId-format }
    }
}

struct FieldAccess {
    name: Token
    source-type: Type
    target-type: Type
    field-index: i32
}
fn FieldAccess-format(fmt: .Formatter, self: .FieldAccess) {
    $fmt "(FieldAccess " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.source-type Type-format
    $fmt " " Fmt:write
    $fmt &self.target-type Type-format
    $fmt " " Fmt:write
    $fmt $self.field-index i32-format
    $fmt ")" Fmt:write
}

struct InitLocal {
    name: Token
    type: Type
    local: LocalId
}
fn InitLocal-format(fmt: .Formatter, self: .InitLocal) {
    $fmt "(InitLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt " " Fmt:write
    $fmt &self.local LocalId-format
    $fmt ")" Fmt:write
}

struct GetLocal {
    name: Token
    var: VarId
    var-type: Type
    fields: Array<FieldAccess>
    result-taip: Type
}
fn GetLocal-format(fmt: .Formatter, self: .GetLocal) {
    $fmt "(GetLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt &self.var-type Type-format
    $fmt " " Fmt:write
    $fmt &self.result-taip Type-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt ")" Fmt:write
}

struct SetLocal {
    name: Token
    var: VarId
    fields: Array<FieldAccess>
    target-type: Type
}
fn SetLocal-format(fmt: .Formatter, self: .SetLocal) {
    $fmt "(SetLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt " " Fmt:write
    $fmt &self.target-type Type-format
    $fmt ")" Fmt:write
}

struct StoreLocal {
    name: Token
    var: VarId
    type: Type
    fields: Array<FieldAccess>
}
fn StoreLocal-format(fmt: .Formatter, self: .StoreLocal) {
    $fmt "(StoreLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt ")" Fmt:write
}

struct RefLocal {
    name: Token
    var: VarId
    fields: Array<FieldAccess>
}
fn RefLocal-format(fmt: .Formatter, self: .RefLocal) {
    $fmt "(RefLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt ")" Fmt:write
}

struct StringWord {
    token: Token
    offset: i32
    len: i32
}
fn StringWord-format(fmt: .Formatter, self: .StringWord) {
    $fmt "(StringWord " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt $self.offset i32-format
    $fmt " " Fmt:write
    $fmt $self.len i32-format
    $fmt ")" Fmt:write
}

struct Cast {
    token: Token
    src: Type
    dst: Type
}
fn Cast-format(fmt: .Formatter, self: .Cast) {
    $fmt "(Cast " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.src Type-format
    $fmt " " Fmt:write
    $fmt &self.dst Type-format
    $fmt ")" Fmt:write
}

struct Sizeof {
    token: Token
    type: Type
}
fn Sizeof-format(fmt: .Formatter, self: .Sizeof) {
    $fmt "(Sizeof " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

variant Intrinsic {
    case Gt -> Type
    case Lt -> Type
    case Add -> Type
    case Sub -> Type
    case Mul -> Type
    case Div -> Type
    case Mod -> Type
    case Eq -> Type
    case NotEq -> Type
    case MemGrow
    case MemCopy
    case MemFill
    case Shl -> Type
    case Shr -> Type
    case Rotl -> Type
    case Rotr -> Type
    case And -> Type
    case Or -> Type
    case Ge -> Type
    case Le -> Type
    case Not -> Type
    case Store -> Type
    case SetStackSize
}
fn Intrinsic-format(fmt: .Formatter, self: .Intrinsic) {
    $self match {
        case Gt -> { $fmt "(Gt " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Lt -> { $fmt "(Lt " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Add -> { $fmt "(Add " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Sub -> { $fmt "(Sub " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Mul -> { $fmt "(Mul " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Div -> { $fmt "(Div " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Mod -> { $fmt "(Mod " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Eq -> { $fmt "(Eq " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case NotEq -> { $fmt "(NotEq " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case MemGrow -> { $fmt "MemGrow" Fmt:write }
        case MemCopy -> { $fmt "MemCopy" Fmt:write }
        case MemFill -> { $fmt "MemFill" Fmt:write }
        case Shl -> { $fmt "(Shl " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Shr -> { $fmt "(Shr " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Rotl -> { $fmt "(Rotl " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Rotr -> { $fmt "(Rotr " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case And -> { $fmt "(And " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Or -> { $fmt "(Or " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Ge -> { $fmt "(Ge " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Le -> { $fmt "(Le " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Not -> { $fmt "(Not " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case Store -> { $fmt "(Store " Fmt:write $fmt flip Type-format $fmt ")" Fmt:write }
        case SetStackSize -> { $fmt "SetStackSize" Fmt:write }
    }
}

struct IntrinsicWord {
    token: Token
    intrinsic: Intrinsic
}
fn IntrinsicWord-format(fmt: .Formatter, self: .IntrinsicWord) {
    $fmt "(Intrinsic " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.intrinsic Intrinsic-format
    $fmt ")" Fmt:write
}

struct Flip {
    token: Token
    lower: Type
    upper: Type
}
fn Flip-format(fmt: .Formatter, self: .Flip) {
    $fmt "(Flip " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.lower Type-format
    $fmt " " Fmt:write
    $fmt &self.upper Type-format
    $fmt ")" Fmt:write
}

struct Call {
    name: Token
    function: FunctionHandle
    generic-arguments: Array<Type>
}
fn Call-format(fmt: .Formatter, self: .Call) {
    $fmt "(Call " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.function FunctionHandle-format
    $fmt " " Fmt:write
    $fmt &self.generic-arguments Types-format
    $fmt ")" Fmt:write
}

struct FunRef {
    call: Call
}
fn FunRef-format(fmt: .Formatter, self: .FunRef) {
    $fmt "(FunRef " Fmt:write
    $fmt &self.call Call-format
    $fmt ")" Fmt:write
}

struct Uninit {
    token: Token
    type: Type
}
fn Uninit-format(fmt: .Formatter, self: .Uninit) {
    $fmt "(Uninit " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

struct FieldInit {
    name: Token
    struc: CustomTypeHandle
    type: Type
    field-index: i32
}
fn FieldInit-format(fmt: .Formatter, self: .FieldInit) {
    $fmt "(FieldInit " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.struc CustomTypeHandle-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt " " Fmt:write
    $fmt $self.field-index i32-format
    $fmt ")" Fmt:write
}

struct StructWordNamed {
    token: Token
    type: CustomTypeType
    body: Scope
}
fn StructWordNamed-format(fmt: .Formatter, self: .StructWordNamed) {
    $fmt "(StructWordNamed\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt "type=" Fmt:write
    $fmt &self.type CustomTypeType-format
    $fmt ",\n" Fmt:write
    $fmt "body=" Fmt:write
    $fmt &self.body Scope-format
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct StructWord {
    token: Token
    type: CustomTypeType
}
fn StructWord-format(fmt: .Formatter, self: .StructWord) {
    $fmt "(StructWord\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt "type=" Fmt:write
    $fmt &self.type CustomTypeType-format
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct Scope {
    id: ScopeId
    words: Array<Word>
}
fn Scope-format(fmt: .Formatter, self: .Scope) {
    $fmt "(Scope " Fmt:write
    $fmt &self.id ScopeId-format
    $fmt " " Fmt:write
    $fmt &self.words Words-format
    $fmt ")" Fmt:write
}

struct If {
    token: Token
    parameters: Array<Type>
    returns: Maybe<Array<Type>>
    true-branch: Scope
    false-branch: Scope
}
fn If-format(fmt: .Formatter, self: .If) {
    $fmt "(If\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt &self.parameters Types-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt \Types-format &self.returns Maybe:format<Array<Type>>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "true-branch=" Fmt:write
    $fmt &self.true-branch Scope-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "false-branch=" Fmt:write
    $fmt &self.false-branch Scope-format
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct BlockAnnotation {
    parameters: Array<Type>
    returns: Array<Type>
}

struct Loop {
    token: Token
    parameters: Array<Type>
    returns: Maybe<Array<Type>>
    body: Scope
}
fn Loop-format(fmt: .Formatter, self: .Loop) {
    $fmt "(Loop\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt &self.parameters Types-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt \Types-format &self.returns Maybe:format<Array<Type>>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "body=" Fmt:write
    $fmt &self.body Scope-format
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}
struct Block {
    token: Token
    parameters: Array<Type>
    returns: Array<Type>
    body: Scope
}
fn Block-format(fmt: .Formatter, self: .Block) {
    $fmt "(Block\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt &self.parameters Types-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt &self.returns Types-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "body=" Fmt:write
    $fmt &self.body Scope-format
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct IndirectCall {
    token: Token
    type: FunType
}
fn IndirectCall-format(fmt: .Formatter, self: .IndirectCall) {
    $fmt "(IndirectCall " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type FunType-format
    $fmt ")" Fmt:write
}

struct Load {
    token: Token
    type: Type
}
fn Load-format(fmt: .Formatter, self: .Load) {
    $fmt "(Load " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

struct MatchCase {
    type: Maybe<Type>
    tag: i32
    body: Scope
}
fn MatchCase-format(fmt: .Formatter, self: .MatchCase) {
    $fmt "(MatchCase " Fmt:write
    $fmt \Type-format &self.type Maybe:format<Type>
    $fmt " " Fmt:write
    $fmt $self.tag i32-format
    $fmt " " Fmt:write
    $fmt &self.body Scope-format
    $fmt ")" Fmt:write
}
struct Match {
    token: Token
    varint: CustomTypeType
    by-ref: bool
    cases: Array<MatchCase>
    default: Maybe<Scope>
    parameters: Array<Type>
    returns: Maybe<Array<Type>>
}
fn Match-format(fmt: .Formatter, self: .Match) {
    $fmt "(Match\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "varint=" Fmt:write
    $fmt &self.varint CustomTypeType-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "by-ref=" Fmt:write
    $fmt $self.by-ref bool-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "cases=" Fmt:write
    $fmt \MatchCase-format &self.cases Array:format-multi-line<MatchCase>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "default=" Fmt:write
    $fmt \Scope-format &self.default Maybe:format<Scope>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt &self.parameters Types-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt \Types-format &self.returns Maybe:format<Array<Type>>
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct VariantWord {
    token: Token
    tag: i32
    type: CustomTypeType
}
fn VariantWord-format(fmt: .Formatter, self: .VariantWord) {
    $fmt "(VariantWord\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt "tag=" Fmt:write
    $fmt $self.tag i32-format
    $fmt ",\n" Fmt:write
    $fmt "type=" Fmt:write
    $fmt &self.type CustomTypeType-format
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct GetField {
    token: Token
    fields: Array<FieldAccess>
    on-ptr: bool
    type: Type
}
fn GetField-format(fmt: .Formatter, self: .GetField) {
    $fmt "(GetField " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format<FieldAccess>
    $fmt " " Fmt:write
    $fmt $self.on-ptr bool-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

struct MakeTuple {
    token: Token
    type: Type
}
fn MakeTuple-format(fmt: .Formatter, self: .MakeTuple) {
    $fmt "(MakeTuple " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

struct UnpackTuple {
    token: Token
    type: Type
}
fn UnpackTuple-format(fmt: .Formatter, self: .UnpackTuple) {
    $fmt "(UnpackTuple " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

variant Word {
    case Number -> Token
    case GetLocal -> GetLocal
    case RefLocal -> RefLocal
    case InitLocal -> InitLocal
    case SetLocal -> SetLocal
    case StoreLocal -> StoreLocal
    case String -> StringWord
    case Intrinsic -> IntrinsicWord
    case Cast -> Cast
    case Sizeof -> Sizeof
    case Call -> Call
    case Drop -> Token
    case Flip -> Flip
    case Uninit -> Uninit
    case FieldInit -> FieldInit
    case StructWord -> StructWord
    case StructWordNamed -> StructWordNamed
    case FunRef -> FunRef
    case If -> If
    case Loop -> Loop
    case Break -> Token
    case Block -> Block
    case IndirectCall -> IndirectCall
    case Load -> Load
    case Match -> Match
    case VariantWord -> VariantWord
    case GetField -> GetField
    case MakeTuple -> MakeTuple
    case UnpackTuple -> UnpackTuple
}
fn Word-format(fmt: .Formatter, self: .Word) {
    $self match {
        case Number -> { $fmt "(Number " Fmt:write $fmt flip Token-format $fmt ")" Fmt:write }
        case GetLocal -> { $fmt flip GetLocal-format }
        case RefLocal -> { $fmt flip RefLocal-format }
        case InitLocal -> { $fmt flip InitLocal-format }
        case SetLocal -> { $fmt flip SetLocal-format }
        case StoreLocal -> { $fmt flip StoreLocal-format }
        case String -> { $fmt flip StringWord-format }
        case Intrinsic -> { $fmt flip IntrinsicWord-format }
        case Cast -> { $fmt flip Cast-format }
        case Sizeof -> { $fmt flip Sizeof-format }
        case Call -> { $fmt flip Call-format }
        case Drop -> { $fmt "(Drop " Fmt:write $fmt flip Token-format $fmt ")" Fmt:write }
        case Flip -> { $fmt flip Flip-format }
        case Uninit -> { $fmt flip Uninit-format }
        case FieldInit -> { $fmt flip FieldInit-format }
        case StructWord -> { $fmt flip StructWord-format }
        case StructWordNamed -> { $fmt flip StructWordNamed-format }
        case FunRef -> { $fmt flip FunRef-format }
        case If -> { $fmt flip If-format }
        case Loop -> { $fmt flip Loop-format }
        case Break -> { $fmt "(Break " Fmt:write $fmt flip Token-format $fmt ")" Fmt:write }
        case Block -> { $fmt flip Block-format }
        case IndirectCall -> { $fmt flip IndirectCall-format }
        case Load -> { $fmt flip Load-format }
        case Match -> { $fmt flip Match-format }
        case VariantWord -> { $fmt flip VariantWord-format }
        case GetField -> { $fmt flip GetField-format }
        case MakeTuple -> { $fmt flip MakeTuple-format }
        case UnpackTuple -> { $fmt flip UnpackTuple-format }
    }
}
fn Words-format(fmt: .Formatter, self: .Array<Word>) {
    $fmt \Word-format $self Array:format-multi-line<Word>
}

variant FunctionOrExtern {
    case Extern -> Extern
    case Function -> Function
}
fn FunctionOrExtern-format(fmt: .Formatter, self: .FunctionOrExtern) {
    $fmt $self match {
        case Extern -> { Extern-format }
        case Function -> { Function-format }
    }
}
fn FunctionOrExtern-signature(self: .FunctionOrExtern) -> .Signature {
    $self match {
        case Extern -> { .signature }
        case Function -> { .signature }
    }
}

struct Function {
    name: Token
    export: Maybe<Token>
    signature: Signature
    locals: Map<LocalId, Local>
    body: Scope
}
fn Function-format(fmt: .Formatter, self: .Function) {
    $fmt "(Function\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "export=" Fmt:write
    $fmt \Token-format &self.export Maybe:format<Token>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "signature=" Fmt:write
    $fmt &self.signature Signature-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "locals=" Fmt:write
    $fmt \LocalId-format \Local-format &self.locals Map:format-multi-line<LocalId, Local>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "body=" Fmt:write
    $fmt &self.body Scope-format
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct Module {
    imports: Map<ByteSlice, Array<Import>>
    custom-types: Map<ByteSlice, CustomType>
    globals: Map<ByteSlice, Global>
    functions: Map<ByteSlice, FunctionOrExtern>
    static-data: ByteSlice
}
fn format-import-array(fmt: .Formatter, self: .Array<Import>) {
    $fmt \Import-format $self Array:format<Import>
}
fn Module-format(fmt: .Formatter, self: .Module) {
    $fmt "(Module\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "imports=" Fmt:write
    $fmt \Fmt:ByteSlice-format \format-import-array &self.imports Map:format-multi-line<ByteSlice, Array<Import>>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "custom-types=" Fmt:write
    $fmt \ByteSlice-format \CustomType-format &self.custom-types Map:format-multi-line<ByteSlice, CustomType>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "globals=" Fmt:write
    $fmt \ByteSlice-format \Global-format &self.globals Map:format-multi-line<ByteSlice, Global>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "functions=" Fmt:write
    $fmt \ByteSlice-format \FunctionOrExtern-format &self.functions Map:format-multi-line<ByteSlice, FunctionOrExtern>
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct ResolveError {
    module: ModuleId
    line: i32
    column: i32
    message: ByteArray
}
fn ResolveError-print(fd: i32, self: ResolveError, modules: .Map<ByteSlice, Array<TopItem>>) -> i32 { block {
    &modules.keys $self.module.index Array:get<ByteSlice> @file-path
    $fd $file-path ~ ByteSlice:unpack IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd ":" IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.line IO:print Core:dup<i32> 0 /= if { break } drop
    $fd ":" IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.column IO:print Core:dup<i32> 0 /= if { break } drop
    $fd " " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.message ByteArray:unpack IO:write-all
} }
fn error(ctx: .Ctx, token: .Token, message-ptr: .i8, message-len: i32) -> ResolveError {
    $ctx.module-id $token Token-location $ctx.persistent $message-ptr $message-len ByteArray:copy make ResolveError
}
fn abort<T>(ctx: .Ctx, token: .Token, message-ptr: .i8, message-len: i32) -> Result<T, ResolveError> {
    $ctx $token $message-ptr $message-len error
    make Result<T, ResolveError>.Error
}
fn abort-m(ctx: .Ctx, token: .Token, message-ptr: .i8, message-len: i32) -> Maybe<ResolveError> {
    $ctx.module-id $token Token-location $ctx.persistent $message-ptr $message-len ByteArray:copy make ResolveError
    make Maybe<ResolveError>.Some
}

struct Ctx {
    temp: .Arena
    persistent: .Arena
    parsed-modules: .Map<ByteSlice, Array<TopItem>>
    resolved-modules: .Array<Module>
    top-items: .Array<TopItem>
    module-id: ModuleId
    static-data: ByteArray
}

fn resolve-modules(arena: .Arena, modules: .Map<ByteSlice, Array<TopItem>>) -> Result<Map<ByteSlice, Module>, ResolveError> {
    $arena \ByteSlice:eq-by-ref $modules.values.len Map:new-with-capacity<ByteSlice, Module> @resolved-modules
    Array:new<.Array<CustomType>> @other-module-types
    $arena Arena:temp @temp @save
    0 @id
    loop {
        $id $modules.keys.len = if { $resolved-modules make Result<Map<ByteSlice, Module>, ResolveError>.Success break }
        &modules.keys $id Array:get<ByteSlice> @module-path
        &modules.values $id Array:get<Array<TopItem>> @top-items

        Logging:enabled if {
            2 "Checking module: " IO:write-all IO:check
            2 $module-path ~ ByteSlice:unpack IO:write-all IO:check
            2 "\n" IO:write-all IO:check
        }
        $temp Arena:save @save
        $temp $arena $modules &resolved-modules.values $top-items $id make ModuleId ByteArray:new make Ctx @ctx
        &ctx resolve-imports match {
            case Error -> { make Result<Map<ByteSlice, Module>, ResolveError>.Error break }
            case Success -> {}
        } @imports
        &ctx &imports resolve-custom-types match {
            case Error -> { make Result<Map<ByteSlice, Module>, ResolveError>.Error break }
            case Success -> {}
        } @custom-types
        &ctx &imports resolve-globals match {
            case Error -> { make Result<Map<ByteSlice, Module>, ResolveError>.Error break }
            case Success -> {}
        } @globals
        &ctx &imports resolve-signatures match {
            case Error -> { make Result<Map<ByteSlice, Module>, ResolveError>.Error break }
            case Success -> {}
        } @signatures

        make TypeLookup {
            $ctx.module-id @module-id
            &custom-types.values @types
            &other-module-types @other-modules
        } @type-lookup
        &ctx &imports &type-lookup &signatures &globals resolve-functions match {
            case Error -> { make Result<Map<ByteSlice, Module>, ResolveError>.Error break }
            case Success -> {}
        } @functions

        &ctx &type-lookup forbid-directly-recursive-types match {
            case Some -> { make Result<Map<ByteSlice, Module>, ResolveError>.Error break }
            case None -> {}
        }

        &resolved-modules $module-path ~
        $imports $custom-types $globals $functions &ctx.static-data ByteArray:to-slice make Module
        Map:insert-assert-no-alloc<ByteSlice, Module> drop
        $arena &other-module-types &resolved-modules.values $id Array:get<Module> .custom-types.values Array:push<.Array<CustomType>>
        $id 1 + #id
        $temp $save Arena:restore
    }
    $temp $save Arena:restore
}

fn forbid-directly-recursive-types(ctx: .Ctx, type-lookup: .TypeLookup) -> Maybe<ResolveError> {
    0 @i
    loop {
        $i $type-lookup.types.len = if { make Maybe<ResolveError>.None break }
        $type-lookup.module-id $i make CustomTypeHandle @handle
        $ctx $type-lookup &handle List:empty<CustomTypeHandle> @stack &stack is-directly-recursive if {
            $type-lookup &handle lookup-type CustomType-name @token
            $ctx $token "structs and variants cannot be recursive" abort-m break
        }
        $i 1 + #i
    }
}

fn is-directly-recursive(ctx: .Ctx, type-lookup: .TypeLookup, handle: .CustomTypeHandle, stack: .List<CustomTypeHandle>) -> bool { block {
    \CustomTypeHandle-eq $stack $handle List:contains<CustomTypeHandle> if {
        1 1 = break
    }
    $type-lookup $handle lookup-type match {
        case Struct -> {
            @struc
            0 @i
            loop {
                $i $struc.fields.len = if { 0 1 = break }
                &struc.fields $i Array:get<NamedType> .type match {
                    case Custom -> {
                        @custom-type
                        $handle ~ $stack List:cons<CustomTypeHandle> @stack'
                        $ctx $type-lookup &custom-type.type-definition &stack' is-directly-recursive if {
                            1 1 = break
                        }
                    }
                    case _ -> { drop }
                }
                $i 1 + #i
            }
        }
        case Variant -> {
            @varint
            0 @i
            loop {
                $i $varint.cases.len = if { 0 1 = break }
                &varint.cases $i Array:get<VariantCase> .type match {
                    case None -> {}
                    case Some -> { match {
                        case Custom -> {
                            @custom-type
                            $handle ~ $stack List:cons<CustomTypeHandle> @stack'
                            $ctx $type-lookup &custom-type.type-definition &stack' is-directly-recursive if {
                                1 1 = break
                            }
                        }
                        case _ -> { drop }
                    } }
                }
                $i 1 + #i
            }
        }
    }
} }

fn resolve-globals(ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>) -> Result<Map<ByteSlice, Global>, ResolveError> {
    \ByteSlice:eq-by-ref Map:new<ByteSlice, Global> @globals
    0 @i
    loop (-> Result<Map<ByteSlice, Global>, ResolveError>) {
        $ctx.top-items.len $i = if { $globals make Result<Map<ByteSlice, Global>, ResolveError>.Success break }
        $ctx.top-items $i Array:get<TopItem> match {
            case Global -> {
                @globl
                $ctx.persistent &globals &globl.name Token-lexeme make ByteSlice
                $globl.name
                $ctx $imports &globl.type resolve-type match {
                    case Error -> { make Result<Map<ByteSlice, Global>, ResolveError>.Error break }
                    case Success -> {}
                }
                0 1 = // whether this Global was reffed using `&`
                make Global
                Map:insert<ByteSlice, Global> drop
            }
            case _ -> { drop }
        }
        $i 1 + #i
    }
}

fn resolve-functions(ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>, type-lookup: .TypeLookup, signatures: .Array<Signature>, globals: .Map<ByteSlice, Global>) -> Result<Map<ByteSlice, FunctionOrExtern>, ResolveError> {
    $ctx.persistent \ByteSlice:eq-by-ref $ctx.top-items.len
    Map:new-with-capacity<ByteSlice, FunctionOrExtern> @functions
    0 @i
    loop (-> Result<Map<ByteSlice, FunctionOrExtern>, ResolveError>) {
        $ctx.top-items.len $i = if { $functions make Result<Map<ByteSlice, FunctionOrExtern>, ResolveError>.Success break }
        $ctx.top-items $i Array:get<TopItem> match {
            case Function -> {
                @fun
                $fun.name $fun.export
                $ctx $imports &fun.signature resolve-signature match {
                    case Error -> { make Result<Map<ByteSlice, FunctionOrExtern>, ResolveError>.Error break }
                    case Success -> {}
                } @signature
                $ctx.temp Env:new @env
                $ctx.temp &env &signature.parameters Env:insert-parameters
                Stack-new-root @stack
                $ctx.temp $ctx $imports $env $type-lookup $signatures $globals WordCtx-new @ctx
                $signature
                &ctx &stack &fun.body.words resolve-words match {
                    case Error -> { make Result<Map<ByteSlice, FunctionOrExtern>, ResolveError>.Error break }
                    case Success -> {}
                } [,] @diverges
                $diverges not if {
                    &stack.positive &signature.returns Types-eq not if {
                        $ctx.temp Fmt:into-new-string @msg @fmt
                        &fmt "unexpected return values:\n\texpected: " Fmt:write
                        &fmt $ctx.type-lookup &signature.returns Types-pretty-bracketed
                        &fmt "\n\tactual:   " Fmt:write
                        &fmt $ctx.type-lookup &stack.positive Types-pretty-bracketed
                        $ctx.ctx &fun.name $msg ~ ByteArray:unpack abort<Map<ByteSlice, FunctionOrExtern>> break
                    }
                }
                $ctx.persistent $env.vars-by-id Map:clone<LocalId, Local>
                flip $env.scope-id flip make Scope
                make Function
                make FunctionOrExtern.Function
                &functions flip
                &fun.name Token-lexeme make ByteSlice flip
                Map:insert-assert-no-alloc<ByteSlice, FunctionOrExtern> drop
            }
            case Extern -> {
                @extrn
                &functions
                &extrn.name Token-lexeme make ByteSlice
                $extrn.name
                &extrn.extrn-module Token-lexeme 2 - flip 1 + flip make ByteSlice
                &extrn.extrn-name Token-lexeme 2 - flip 1 + flip make ByteSlice
                $ctx $imports &extrn.signature resolve-signature match {
                    case Error -> { make Result<Map<ByteSlice, FunctionOrExtern>, ResolveError>.Error break }
                    case Success -> {}
                }
                make Extern make FunctionOrExtern.Extern
                Map:insert-assert-no-alloc<ByteSlice, FunctionOrExtern> drop
            }
            case _ -> { drop }
        }
        $i 1 + #i
    }
}

struct StructLitCtx {
    struc: CustomTypeHandle
    generic-arguments: Array<Type>
    fields: Map<ByteSlice, [i32, Type]>
}

struct BreakStack {
    token: Token
    types: Array<Type>
    reachable: bool
}

struct WordCtx {
    temp: .Arena
    persistent: .Arena
    ctx: .Ctx
    imports: .Map<ByteSlice, Array<Import>>
    env: Env
    type-lookup: .TypeLookup
    ptr-I8: .Type
    ptr-I32: .Type
    I32: .Type
    Bool: .Type
    signatures: .Array<Signature>
    globals: .Map<ByteSlice, Global>
    struc-lit-ctx: Maybe<.StructLitCtx>
    brek-stacks: Maybe<.Array<BreakStack>>
    blok-returns: Maybe<.Array<Type>>
    reachable: bool
}
fn WordCtx-new(temp: .Arena, ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>, env: Env, type-lookup: .TypeLookup, signatures: .Array<Signature>, globals: .Map<ByteSlice, Global>) -> WordCtx {
    make WordCtx {
        $temp @temp
        $ctx.persistent @persistent
        $ctx @ctx
        $imports @imports
        $env @env
        $type-lookup @type-lookup
        $ctx.persistent make Type.I8 Arena:push<Type> @i8_
        $ctx.persistent make Type.I32 Arena:push<Type> @i32_
        $i32_ @I32
        $ctx.persistent $i8_ make Type.Ptr Arena:push<Type> @ptr-I8
        $ctx.persistent $i32_ make Type.Ptr Arena:push<Type> @ptr-I32
        $ctx.persistent make Type.Bool Arena:push<Type> @Bool
        $signatures @signatures
        $globals @globals
        make Maybe<.StructLitCtx>.None @struc-lit-ctx
        make Maybe<.Array<BreakStack>>.None @brek-stacks
        make Maybe<.Array<Type>>.None @blok-returns
        1 1 = @reachable
    }
}
fn with-struc-lit-ctx(ctx: .WordCtx, struc-lit-ctx: .StructLitCtx) -> WordCtx {
    $ctx ~ @new
    $struc-lit-ctx make Maybe<.StructLitCtx>.Some #new.struc-lit-ctx
    $new
}
fn with-env(ctx: .WordCtx, env: Env) -> WordCtx {
    $ctx ~ @new $env #new.env $new
}
fn with-brek-stacks(ctx: .WordCtx, brek-stacks: .Array<BreakStack>, blok-returns: Maybe<.Array<Type>>) -> WordCtx {
    $ctx ~ @new
    $brek-stacks make Maybe<.Array<BreakStack>>.Some #new.brek-stacks
    $blok-returns #new.blok-returns
    $new
}

fn lookup-signature(ctx: .WordCtx, function: .FunctionHandle) -> .Signature {
    $function.module $ctx.ctx.module-id = if {
        $ctx.signatures $function.index Array:get<Signature>
    } else {
        $ctx.ctx.resolved-modules $function.module.index Array:get<Module> @module
        &module.functions.values $function.index Array:get<FunctionOrExtern> FunctionOrExtern-signature
    }
}

fn resolve-words(ctx: .WordCtx, stack: .Stack, remaining-words: .Array<P:Word>) -> Result<[Array<Word>, bool], ResolveError> {
    0 1 = @diverges
    Array:new<Word> @resolved
    loop (-> Result<[Array<Word>, bool], ResolveError>) {
        $remaining-words.len 0 = if { $resolved $diverges [,2] make Result<[Array<Word>, bool], ResolveError>.Success break }
        $remaining-words Array:pop-front<P:Word> @parsed-word
        $ctx $stack $remaining-words &parsed-word resolve-word match {
            case Error -> { make Result<[Array<Word>, bool], ResolveError>.Error break }
            case Success -> {}
        } match {
            case None -> {}
            case Some -> {
                [,] $diverges or #diverges @word
                $diverges not #ctx.reachable
                $ctx.persistent &resolved $word Array:push<Word>
            }
        }
    }
}

fn resolve-word(ctx: .WordCtx, stack: .Stack, remaining-words: .Array<P:Word>, word: .P:Word) -> Result<Maybe<[Word, bool]>, ResolveError> { block {
    $word match {
        case Number -> {
            $ctx $stack make Type.I32 push
            ~ make Word.Number 0 1 = [,2]
        }
        case String -> {
            @word
            $ctx $stack $ctx.ptr-I8 ~ push
            $ctx $stack make Type.I32 push
            $word.token
            $ctx.ctx $word.data ByteSlice:unpack allocate-static-data
            make StringWord
            make Word.String 0 1 = [,2]
        }
        case GetLocal -> { $ctx flip $stack flip resolve-get-local maybeify break }
        case RefLocal -> { $ctx flip $stack flip resolve-ref-local maybeify break }
        case InitLocal -> { $ctx flip $stack flip resolve-init-local maybeify break }
        case Call -> { $ctx flip $stack flip resolve-call maybeify break }
        case Cast -> { $ctx flip $stack flip resolve-cast maybeify break }
        case Sizeof -> { $ctx flip $stack flip resolve-sizeof maybeify break }
        case MakeStruct -> { $ctx flip $stack flip resolve-mk-struc maybeify break }
        case MakeStructNamed -> { $ctx flip $stack flip resolve-mk-struc-named maybeify break }
        case FunRef -> { $ctx flip $stack flip resolve-fun-ref maybeify break }
        case If -> { $ctx flip $stack flip $remaining-words flip resolve-iff maybeify break }
        case Loop -> { $ctx flip $stack flip resolve-lop maybeify break }
        case Break -> { $ctx flip $stack flip resolve-brek maybeify break }
        case SetLocal -> { $ctx flip $stack flip resolve-set-local maybeify break }
        case Block -> { $ctx flip $stack flip resolve-blok maybeify break }
        case IndirectCall -> { $ctx flip $stack flip resolve-indirect-call maybeify break }
        case Store -> { $ctx flip $stack flip resolve-store maybeify break }
        case Load -> { $ctx flip $stack flip resolve-load maybeify break }
        case Match -> { $ctx flip $stack flip resolve-matsh maybeify break }
        case MakeVariant -> { $ctx flip $stack flip resolve-mk-varint maybeify break }
        case GetField -> { $ctx flip $stack flip resolve-get-field maybeify break }
        case MakeTuple -> { $ctx flip $stack flip resolve-mk-tuple maybeify break }
        case UnpackTuple -> { $ctx flip $stack flip resolve-unpack-tuple maybeify break }
        case StackAnnotation -> {
            $ctx flip $stack flip resolve-stack-annotation match {
                case Success -> {
                    drop
                    make Maybe<[Word, bool]>.None
                    make Result<Maybe<[Word, bool]>, ResolveError>.Success
                }
                case Error -> { make Result<Maybe<[Word, bool]>, ResolveError>.Error }
            } break // TODO: moving this break into both branches results in miscompilation
        }
    } make Maybe<[Word, bool]>.Some make Result<Maybe<[Word, bool]>, ResolveError>.Success
} }

fn maybeify(r: Result<[Word, bool], ResolveError>) -> Result<Maybe<[Word, bool]>, ResolveError> {
    $r match {
        case Success -> { make Maybe<[Word, bool]>.Some make Result<Maybe<[Word, bool]>, ResolveError>.Success }
        case Error -> { make Result<Maybe<[Word, bool]>, ResolveError>.Error }
    }
}

fn allocate-static-data(ctx: .Ctx, ptr: .i8, len: i32) -> i32, i32 {
    $ctx.static-data.ptr $ctx.static-data.len $ptr $len Bytes:find-seq
    if { $len } else {
        drop
        $ctx.static-data.len
        $ctx.persistent &ctx.static-data $ptr $len ByteArray:push
        $len
    }
}

struct Stack {
    parent: Maybe<.Stack>
    positive: Array<Type>
    negative: Array<Type>
}
fn Stack-new-root() -> Stack {
    make Maybe<.Stack>.None Array:new<Type> Array:new<Type> make Stack
}
fn Stack-clone(arena: .Arena, self: .Stack) -> Stack {
    $self.parent match {
        case None -> { make Maybe<.Stack>.None }
        case Some -> { $arena flip Stack-clone $arena flip Arena:push<Stack> make Maybe<.Stack>.Some }
    }
    $arena &self.positive Array:clone<Type>
    $arena &self.negative Array:clone<Type>
    make Stack
}
fn push(ctx: .WordCtx, self: .Stack, type: Type) {
    $ctx.temp &self.positive $type Array:push<Type>
}
fn push-many(ctx: .WordCtx, self: .Stack, types: .Array<Type>) {
    0 @i
    loop {
        $i $types.len = if { break }
        $ctx $self $types $i Array:get<Type> ~ push
        $i 1 + #i
    }
}
fn pop(ctx: .WordCtx, self: .Stack) -> Maybe<Type> {
    $self.positive.len 0 = if {
        $self.parent match {
            case None -> { make Maybe<Type>.None }
            case Some -> {
                $ctx flip pop match {
                    case None -> { make Maybe<Type>.None }
                    case Some -> {
                        @type
                        $ctx.temp &self.negative $type Array:push<Type>
                        $type make Maybe<Type>.Some
                    }
                }
            }
        }
    } else {
        &self.positive Array:pop<Type> make Maybe<Type>.Some
    }
}
fn size(self: .Stack) -> i32 {
    $self.positive.len
    $self.parent match {
        case None -> {}
        case Some -> { size + }
    }
}
fn index(self: .Stack, index: i32) -> .Type {
    $index $self.positive.len lt if {
        &self.positive $self.positive.len $index - 1 - Array:get<Type>
    } else {
        $self.parent assert-some<.Stack> $index $self.positive.len - index
    }
}
fn dump(ctx: .WordCtx, self: .Stack) -> Array<Type> {
    $self size @size
    $ctx.temp $size Array:new-with-capacity<Type> @dump
    $size @i
    loop {
        $i 0 = if { break }
        $i 1 - #i
        $ctx.temp &dump $ctx $self pop assert-some<Type> Array:push<Type>
    }
    &dump Array:reverse<Type>
    $dump
}
fn maek-stacks-compatible(ctx: .WordCtx, a: .Stack, b: .Stack) -> bool {
    $ctx $a $b.positive.len use drop
    $ctx $b $a.positive.len use drop

    &a.positive &b.positive Types-eq
    &a.negative &b.negative Types-eq and
}
fn pop-n(ctx: .WordCtx, self: .Stack, n: i32) -> Array<Type> {
    $ctx.temp $n Array:new-with-capacity<Type> @popped
    loop (->) {
        $n 0 = if { break }
        $ctx.temp &popped
        $ctx $self pop match {
            case Some -> {}
            case None -> { break }
        } Array:push<Type>
        $n 1 - #n
    }
    &popped Array:reverse<Type>
    $popped
}
fn drop-n(ctx: .WordCtx, self: .Stack, n: i32) {
    loop {
        $n 0 = if { break }
        $ctx $self pop drop
        $n 1 - #n
    }
}
fn child(ctx: .WordCtx, self: .Stack) -> Stack {
    $ctx.temp $ctx.temp $self Stack-clone Arena:push<Stack> make Maybe<.Stack>.Some
    Array:new<Type>
    Array:new<Type>
    make Stack
}
fn use(ctx: .WordCtx, self: .Stack, n: i32) -> bool {
    $ctx.temp $n Array:new-with-capacity<Type> @popped
    loop (-> bool) {
        $popped.len $n = if { 1 1 = break }
        &popped $ctx $self pop match {
            case None -> { 0 1 = break }
            case Some -> {}
        } Array:push-assert-no-alloc<Type>
    }
    loop (->) {
        $popped.len 0 = if { break }
        $ctx.temp &self.positive
        &popped Array:pop<Type>
        Array:push<Type>
    }
}

fn resolve-matsh(ctx: .WordCtx, stack: .Stack, word: .P:Match) -> Result<[Word, bool], ResolveError> { block (-> Result<[Word, bool], ResolveError>) {
    $ctx.persistent $word.cases.len 1 + Array:new-with-capacity<MatchCase> @cases
    1 1 = @match-diverges
    $ctx $stack &word.token "expected a value to match on" pop1 match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @arg-item &arg-item match {
        case Ptr -> { ~ 1 1 = }
        case _ -> { 0 1 = }
    } @by-ref @arg
    $arg match {
        case Custom -> {
            @type
            $type
            $ctx.type-lookup &type.type-definition lookup-type match {
                case Variant -> {}
                case _ -> {
                    $ctx.ctx &word.token "can only match on variants" abort<[Word, bool]> break
                }
            } $type.generic-arguments
        }
        case _ -> {
            drop $ctx.ctx &word.token "can only match on variants" abort<[Word, bool]> break
        }
    } @generic-arguments @varint ~ @varint-type
    $ctx.temp &varint.cases \VariantCase-name Array:map<VariantCase, ByteSlice> @remaining-cases
    $ctx.temp $varint.cases.len 1 + Array:new-with-capacity<[Stack, .Token, bool]> @case-stacks
    $ctx.temp $varint.cases.len Array:new-with-capacity<Token> @visited-cases
    0 @i
    loop {
        $i $word.cases.len = if { make Maybe<ResolveError>.None break }
        &word.cases $i Array:get<P:MatchCase> @parsed-case
        0 @j
        loop {
            $j $varint.cases.len = if {
                $ctx.ctx &parsed-case.token "not part of variant" abort<i32> break
            }
            &varint.cases $j Array:get<VariantCase> .name Token-lexeme
            &parsed-case.name Token-lexeme Bytes:eq if {
                $j make Result<i32, ResolveError>.Success break
            }
            $j 1 + #j
        } match {
            case Error -> { make Maybe<ResolveError>.Some break }
            case Success -> {}
        } @tag
        &varint.cases $tag Array:get<VariantCase> .type @case-type
        $ctx $stack child @case-stack
        $case-type match {
            case None -> { make Maybe<Type>.None }
            case Some -> {
                $by-ref if { make Type.Ptr } else { ~ } @case-type
                $ctx &generic-arguments &case-type resolve-generic @case-type
                $ctx &case-stack $case-type push
                $case-type make Maybe<Type>.Some
            }
        } @case-type
        &ctx.env Env:child @case-env
        $ctx $case-env with-env @case-ctx
        &case-ctx &case-stack &parsed-case.body.words resolve-words match {
            case Error -> { make Maybe<ResolveError>.Some break }
            case Success -> {}
        } [,] @case-diverges @words
        $case-diverges $match-diverges and #match-diverges
        &cases
        $case-type
        $tag
        $case-env.scope-id $words make Scope
        make MatchCase Array:push-assert-no-alloc<MatchCase>

        &parsed-case.name Token-lexeme make ByteSlice @name
        &remaining-cases \ByteSlice:eq-by-ref &name Array:find-remove<ByteSlice, .ByteSlice> match {
            case Some -> { drop }
            case None -> {
                &visited-cases \Token-eq-to-lexeme &name Array:find-ref<Token, .ByteSlice> if {
                    @other
                    $ctx.temp Fmt:into-new-string @msg @fmt
                    &fmt "duplicate case in match:\n\t" Fmt:write
                    &fmt $other Token-line i32-format
                    &fmt ":" Fmt:write
                    &fmt $other Token-column i32-format
                    &fmt " " Fmt:write
                    &fmt $name.ptr $name.len Fmt:write
                    &fmt "\n\t" Fmt:write
                    &fmt &parsed-case.name Token-line i32-format
                    &fmt ":" Fmt:write
                    &fmt &parsed-case.name Token-column i32-format
                    &fmt " " Fmt:write
                    &fmt $name.ptr $name.len Fmt:write
                    $ctx.ctx &word.token $msg ~ ByteArray:unpack abort-m break
                } else {
                    drop
                }
            }
        }
        &visited-cases $parsed-case.name Array:push-assert-no-alloc<Token>
        &case-stacks $case-stack &parsed-case.name $case-diverges [,3] Array:push-assert-no-alloc<[Stack, .Token, bool]>
        $i 1 + #i
    } match {
        case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        case None -> {}
    }
    &word.default match {
        case None -> {
            // Check that no case is missing.
            $remaining-cases.len 0 /= if {
                $ctx.temp Fmt:into-new-string @msg @fmt
                &fmt "missing case in match:" Fmt:write
                0 @i
                loop {
                    $i $remaining-cases.len = if { break }
                    &fmt "\n\t" Fmt:write
                    &fmt &remaining-cases $i Array:get<ByteSlice> ~ ByteSlice:unpack Fmt:write
                    $i 1 + #i
                }
                $ctx.ctx &word.token $msg ~ ByteArray:unpack abort<[Word, bool]> break
            }
            make Maybe<Scope>.None
        }
        case Some -> {
            @default
            $ctx $stack child @def-stack
            &ctx.env Env:child @def-env
            $def-env.scope-id
            $ctx $def-env with-env @def-ctx
            &def-ctx &def-stack $arg-item push
            &def-ctx &def-stack &default.body.words resolve-words match {
                case Error -> { make Result<[Word, bool], ResolveError>.Error break }
                case Success -> {}
            } [,] @default-diverges make Scope make Maybe<Scope>.Some
            $match-diverges $default-diverges and #match-diverges
            &case-stacks $def-stack &default.name $default-diverges [,3] Array:push-assert-no-alloc<[Stack, .Token, bool]>
        }
    } @default

    0 @i
    make Maybe<Stack>.None @first-non-diverging-case
    loop {
        $case-stacks.len $i = if { make Maybe<ResolveError>.None break }
        &case-stacks $i Array:get<[Stack, .Token, bool]> ~ [,] @case-diverges @case-token @case-stack
        $i 1 + #i
        $case-diverges not if {
            &first-non-diverging-case match {
                case None -> {
                    $case-stack make Maybe<Stack>.Some #first-non-diverging-case
                }
                case Some -> {
                    @first
                    $ctx $first &case-stack maek-stacks-compatible not if {
                        $ctx.temp Fmt:into-new-string @buf @fmt
                        &fmt "arms of match case have different types:" Fmt:write
                        0 @j
                        loop {
                            $j $case-stacks.len = if { break }
                            &fmt "\n\t" Fmt:write
                            &case-stacks $j Array:get<[Stack, .Token, bool]> ~ [,] drop @case-token @case-stack
                            &fmt $ctx.type-lookup &case-stack.negative Types-pretty-bracketed
                            &fmt " -> " Fmt:write
                            &fmt $ctx.type-lookup &case-stack.positive Types-pretty-bracketed
                            &fmt " in case " Fmt:write
                            &fmt $case-token Token-lexeme Fmt:write
                            $j 1 + #j
                        }
                        $ctx.ctx &word.token $buf ~ ByteArray:unpack abort-m break
                    }
                }
            }
        }
    } match {
        case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        case None -> {}
    }

    $case-stacks.len 0 = if {
        Array:new<Type> Array:new<Type>
    } else {
        &case-stacks 0 Array:get<[Stack, .Token, bool]> ~ [,] drop drop @most-params
        1 @i
        loop {
            $i $case-stacks.len = if { break }
            &case-stacks $i Array:get<[Stack, .Token, bool]> ~ [,] drop drop @case-stack
            $case-stack.negative.len
            $most-params.negative.len gt if {
                $case-stack #most-params
            }
            $i 1 + #i
        }
        $ctx.persistent &most-params.negative Array:clone<Type> @parameters
        &parameters Array:reverse<Type>

        // A case without any words, will just return any parameters it got.
        // So, to start, make the returns equal to the parameters.
        $ctx.persistent &parameters Array:clone<Type> @returns


        // Use the stack of the first non-diverging stack, to determine the 
        // return types of the match.
        0 @i
        loop {
            $i $case-stacks.len = if { break }
            &case-stacks $i Array:get<[Stack, .Token, bool]> ~ [,] @case-diverges drop @case-stack

            $case-diverges not if {
                // Since the returns start out being set to the parameters,
                // any actual parameter of the case, will pop one item from the returns.
                &returns $returns.len $case-stack.negative.len - Array:truncate<Type>

                // Any values produced by the case are return values of the match.
                $ctx.persistent &returns &case-stack.positive Array:append<Type>
                break
            }
            $i 1 + #i
        }
        $parameters
        $returns

    } @returns @parameters
    $ctx $stack &word.token &parameters expect match {
        case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        case None -> {}
    }
    $ctx $stack &returns push-many
    make Match {
        $word.token @token
        $varint-type @varint
        $by-ref @by-ref
        $cases @cases
        $default @default
        $parameters @parameters
        $match-diverges if { make Maybe<Array<Type>>.None } else { $returns make Maybe<Array<Type>>.Some } @returns
    }
    make Word.Match $match-diverges [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn ifel-stack-mismatch-error(ctx: .WordCtx, word: .P:If, true-stack: .Stack, false-stack: .Stack) -> ResolveError {
    $ctx.temp Fmt:into-new-string @msg @fmt
    &fmt "stack mismatch between if and else branch:\n\tif   " Fmt:write
    &fmt $ctx.type-lookup &true-stack.positive Types-pretty-bracketed
    &fmt "\n\telse " Fmt:write
    &fmt $ctx.type-lookup &false-stack.positive Types-pretty-bracketed
    $ctx.ctx &word.token $msg ~ ByteArray:unpack error
}

fn resolve-iff(ctx: .WordCtx, stack: .Stack, remaining-words: .Array<P:Word>, word: .P:If) -> Result<[Word, bool], ResolveError> { block {
    $ctx $stack &word.token $ctx.Bool "expected a bool for `if`" expect1 match {
        case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        case None -> {}
    }
    &ctx.env Env:child @true-env
    $ctx $stack child @true-stack
    $ctx $true-env with-env @true-ctx

    &ctx.env Env:child @false-env
    $false-env.scope-id @false-scope
    $ctx $stack child @false-stack
    $ctx $false-env with-env @false-ctx

    &true-ctx &true-stack &word.true-words.words resolve-words match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } [,] @true-words-diverge @true-words

    &true-stack.negative @true-parameters

    Array:new<P:Word> @empty-word-array
    &word.false-words match {
        case None -> {
            $true-words-diverge not if {
                &empty-word-array
            } else {
                $ctx $stack child @remaining-stack

                // This makes sure, that the parameters of the true-branch and
                // the synthesized false-branch made up of all subsequent words match.
                $ctx &remaining-stack $true-parameters.len use drop

                $false-ctx @remaining-ctx

                &remaining-ctx &remaining-stack $remaining-words resolve-words match {
                    case Error -> { make Result<[Word, bool], ResolveError>.Error break }
                    case Success -> {}
                } [,] @remaining-words-diverge @remaining-words

                // This drop-n will always pop enough values from the parent stack
                // even for the true-branch, since the call to `use` above makes sure,
                // that the `negative` of `remaining-stack` is at least as long as
                // that of the true-branch.
                $ctx $stack $remaining-stack.negative.len drop-n

                // The true-branch diverges, so it doesn't produce any return values.
                // The remaining words however might, so push the results up!
                $ctx $stack &remaining-stack.positive push-many

                // Since we are synthesizing this false-branch because the true-branch
                // is diverging, the divergence of the remaining words
                // determines the divergence of the entire if.
                $remaining-words-diverge @diverges

                make If {
                    $word.token @token
                    $ctx.persistent &remaining-stack.negative Array:clone<Type> @parameters
                    $diverges if {
                        make Maybe<Array<Type>>.None
                    } else {
                        $ctx.persistent &remaining-stack.positive Array:clone<Type> make Maybe<Array<Type>>.Some
                    } @returns
                    $true-ctx.env.scope-id      $true-words      make Scope @true-branch
                    $remaining-ctx.env.scope-id $remaining-words make Scope @false-branch
                } make Word.If $diverges [,2] make Result<[Word, bool], ResolveError>.Success break
            }
        }
        case Some -> { .words }
    } @false-words

    &false-ctx &false-stack $false-words resolve-words match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } [,] @false-words-diverge @false-words

    $true-words-diverge not $false-words-diverge not and if {
        $ctx &true-stack &false-stack maek-stacks-compatible not if {
            $ctx $word &true-stack &false-stack ifel-stack-mismatch-error
            make Result<[Word, bool], ResolveError>.Error break
        }
        // Because of `maek-stacks-compatible`, the stacks of both branches
        //  must have the same parameters, so always picking the true-stack here is fine.
        $ctx.persistent &true-stack.negative Array:clone<Type>
    } else {
        // Check that the parameters of both branches are the same,
        // or that on is the prefix of the other.
        0 @i
        loop {
            $i  $true-stack.negative.len =
            $i $false-stack.negative.len =
            or if { [,0] make Result<[], ResolveError>.Success break }
            &true-stack.negative  $i Array:get<Type>
            &false-stack.negative $i Array:get<Type>
            Type-eq not if {
                $ctx $word &true-stack &false-stack ifel-stack-mismatch-error
                make Result<[], ResolveError>.Error break
            }
            $i 1 + #i
        } match {
            case Success -> {}
            case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        } drop

        $ctx.persistent $true-stack.negative.len $false-stack.negative.len gt if {
            &true-stack.negative
        } else {
            &false-stack.negative
        } Array:clone<Type>
    } @parameters

    block {
         $true-words-diverge not if { $ctx.persistent  &true-stack.positive Array:clone<Type> make Maybe<Array<Type>>.Some break }
        $false-words-diverge not if { $ctx.persistent &false-stack.positive Array:clone<Type> make Maybe<Array<Type>>.Some break }
        make Maybe<Array<Type>>.None
    } @returns

    $true-stack.negative.len $false-stack.negative.len Core:max @param-count
    $true-words-diverge $false-words-diverge and if {
        // The if diverges, so pop the combined parameters of both branches from the parent.
        $ctx $stack $param-count drop-n
    } else {
        $ctx $stack &word.token &parameters expect match {
            case Some -> { make Result<[Word, bool], ResolveError>.Error break }
            case None -> {}
        }
        &returns match {
            case Some -> { $ctx flip $stack flip push-many }
            case None -> {}
        }
    }
    $true-words-diverge $false-words-diverge and @diverges
    make If {
        $word.token @token
        $diverges @diverges
        $parameters @parameters
        $returns @returns
        $true-ctx.env.scope-id  $true-words  make Scope @true-branch
        $false-ctx.env.scope-id $false-words make Scope @false-branch
    } make Word.If $diverges [,2] make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-blok-annotation(ctx: .WordCtx, annotation: .P:BlockAnnotation) -> Result<BlockAnnotation, ResolveError> { block {
    make BlockAnnotation {
        $ctx.ctx $ctx.imports &annotation.parameters resolve-types match {
            case Error -> { make Result<BlockAnnotation, ResolveError>.Error break }
            case Success -> {}
        } @parameters
        $ctx.ctx $ctx.imports &annotation.returns resolve-types match {
            case Error -> { make Result<BlockAnnotation, ResolveError>.Error break }
            case Success -> {}
        } @returns
    } make Result<BlockAnnotation, ResolveError>.Success
} }

fn resolve-lop(ctx: .WordCtx, stack: .Stack, word: .P:Loop) -> Result<[Word, bool], ResolveError> { block {
    &word.annotation match {
        case None -> { make Maybe<BlockAnnotation>.None }
        case Some -> { $ctx flip resolve-blok-annotation match {
            case Error -> { make Result<[Word, bool], ResolveError>.Error break }
            case Success -> { make Maybe<BlockAnnotation>.Some }
        } }
    } @annotation

    Array:new<BreakStack> @loop-break-stacks

    &ctx.env Env:child @loop-env
    $ctx $stack child @loop-stack
    $ctx $loop-env with-env @loop-ctx
    &loop-ctx &loop-break-stacks &annotation match {
        case Some -> { .returns make Maybe<.Array<Type>>.Some }
        case None -> { make Maybe<.Array<Type>>.None }
    } with-brek-stacks @loop-ctx

    &loop-ctx &loop-stack &word.words.words resolve-words match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } [,] drop @words
    $loop-break-stacks.len 0 = @diverges

    $ctx.persistent &annotation match {
        case None -> { &loop-stack.negative }
        case Some -> { .parameters }
    } Array:clone<Type> @parameters

    $loop-break-stacks.len 0 /= if {
        &loop-break-stacks 0 Array:get<BreakStack> @first
        $first.reachable not #diverges

        1 @i
        loop {
            $i $loop-break-stacks.len = if { make Maybe<ResolveError>.None break }
            &loop-break-stacks $i Array:get<BreakStack> @break-stack
            $i 1 + #i
            $break-stack.reachable not if { make Maybe<ResolveError>.None break }
            \Type-eq &first.types &break-stack.types Array:eq<Type> not if {
                $ctx.temp Fmt:into-new-string @msg @fmt
                &fmt "break stack mismatch:" Fmt:write
                0 @i
                loop {
                    $i $loop-break-stacks.len = if { break }
                    &loop-break-stacks $i Array:get<BreakStack> @break-stack
                    &fmt "\n\t" Fmt:write
                    &fmt &break-stack.token Token-line i32-format
                    &fmt ":" Fmt:write
                    &fmt &break-stack.token Token-column i32-format
                    &fmt " " Fmt:write
                    &fmt $ctx.type-lookup &break-stack.types Types-pretty-bracketed
                    $i 1 + #i
                }
                $ctx.ctx &word.token $msg ~ ByteArray:unpack abort-m break
            }
        } match {
            case None -> {}
            case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        }
    }

    // The parameters of the loop must match the values remaining on the
    // stack, at the end of the loop, to supply the next iteration.
    &parameters &loop-stack.positive Types-eq not if {
        $ctx.ctx &word.token "unexpected values remaining on stack at the end of loop" abort<[Word, bool]> break
    }

    &annotation match {
        case Some -> { .returns $ctx.persistent flip Array:clone<Type> }
        case None -> {
            $loop-break-stacks.len 0 = if {
                Array:new<Type>
            } else {
                &loop-break-stacks 0 Array:get<BreakStack> .types
                $ctx.persistent flip Array:clone<Type>
            }
        }
    } @returns

    $ctx $stack &word.token &parameters expect match {
        case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        case None -> {}
    }
    $ctx $stack &returns push-many
    make Loop {
        $word.token @token
        $parameters @parameters
        $diverges if { make Maybe<Array<Type>>.None } else { $returns make Maybe<Array<Type>>.Some } @returns
        $loop-env.scope-id $words make Scope @body
    }
    make Word.Loop $diverges [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-brek(ctx: .WordCtx, stack: .Stack, token: .Token) -> Result<[Word, bool], ResolveError> { block (-> Result<[Word, bool], ResolveError>) {
    $ctx.persistent $ctx.blok-returns match {
        case None -> { $ctx $stack dump }
        case Some -> { .len ~ $ctx flip $stack flip pop-n }
    } @dump &dump Array:clone<Type> @dump
    $ctx.persistent
    $ctx.brek-stacks match {
        case None -> {
            $ctx.ctx $token "`break` can only be used inside of blocks and loops" abort<[Word, bool]> break
        }
        case Some -> {}
    }
    make BreakStack {
        $token ~ @token
        $dump @types
        $ctx.reachable @reachable
    }
    Array:push<BreakStack>
    $token ~ make Word.Break 1 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn brek-stack-mismatch-error(ctx: .WordCtx, token: .Token, brek-stacks: .Array<BreakStack>) -> ResolveError {
    $ctx.temp Fmt:into-new-string @msg @fmt
    &fmt "break stack mismatch:" Fmt:write
    0 @i
    loop {
        $i $brek-stacks.len = if { break }
        $brek-stacks $i Array:get<BreakStack> @brek-stack
        &fmt "\n\t" Fmt:write
        &fmt &brek-stack.token Token-line i32-format
        &fmt ":" Fmt:write
        &fmt &brek-stack.token Token-column i32-format
        &fmt " " Fmt:write
        &fmt $ctx.type-lookup &brek-stack.types Types-pretty-bracketed
        $i 1 + #i
    }
    $ctx.ctx $token $msg ~ ByteArray:unpack error
}

fn resolve-blok(ctx: .WordCtx, stack: .Stack, word: .P:Block) -> Result<[Word, bool], ResolveError> { block {
    &word.annotation match {
        case None -> { make Maybe<BlockAnnotation>.None }
        case Some -> { $ctx flip resolve-blok-annotation match {
            case Error -> { make Result<[Word, bool], ResolveError>.Error break }
            case Success -> { make Maybe<BlockAnnotation>.Some }
        } }
    } @annotation

    Array:new<BreakStack> @block-break-stacks

    &ctx.env Env:child @block-env
    $ctx $stack child @block-stack
    $ctx $block-env with-env @block-ctx
    &block-ctx &block-break-stacks &annotation match {
        case Some -> { .returns make Maybe<.Array<Type>>.Some }
        case None -> { make Maybe<.Array<Type>>.None }
    } with-brek-stacks @block-ctx

    &block-ctx &block-stack &word.words.words resolve-words match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } [,] @diverges @words
    $diverges not @block-end-is-reached

    $ctx.persistent &annotation match {
        case None -> { &block-stack.negative }
        case Some -> { .parameters }
    } Array:clone<Type> @parameters

    $block-break-stacks.len 0 /= if {
        &block-break-stacks 0 Array:get<BreakStack> @first
        $first.reachable not #diverges

        1 @i
        loop {
            $i $block-break-stacks.len = if { make Maybe<ResolveError>.None break }
            &block-break-stacks $i Array:get<BreakStack> @break-stack
            $i 1 + #i
            $break-stack.reachable not if {
                1 1 = #diverges
                make Maybe<ResolveError>.None break
            }
            &first.types &break-stack.types Types-eq not if {
                $block-end-is-reached if {
                    $ctx.persistent &block-break-stacks
                    $word.words.end $block-stack.positive $diverges make BreakStack
                    Array:push<BreakStack>
                }
                $ctx &word.token &block-break-stacks brek-stack-mismatch-error
                make Maybe<ResolveError>.Some break
            }
        } match {
            case None -> {}
            case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        }
        $block-end-is-reached if {
            &block-stack.positive &first.types Types-eq not if {
                $ctx.persistent &block-break-stacks
                $word.words.end $block-stack.positive $diverges make BreakStack
                Array:push<BreakStack>
                $ctx &word.token &block-break-stacks brek-stack-mismatch-error
                make Result<[Word, bool], ResolveError>.Error break
            }
        }
    }

    $ctx.persistent &annotation match {
        case Some -> { .returns }
        case None -> {
            $block-break-stacks.len 0 = if {
                &block-stack.positive
            } else {
                &block-break-stacks 0 Array:get<BreakStack> .types
            }
        }
    } Array:clone<Type> @returns
    $ctx $stack &word.token &parameters expect match {
        case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        case None -> {}
    }
    $ctx $stack &returns push-many
    make Block {
        $word.token @token
        $parameters @parameters
        $returns @returns
        $block-env.scope-id $words make Scope @body
    }
    make Word.Block $diverges [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-fun-ref(ctx: .WordCtx, stack: .Stack, word: .P:FunRef) -> Result<[Word, bool], ResolveError> { block {
    $ctx &word.function resolve-call-word match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @word
    $ctx &word.function lookup-signature @signature
    $ctx.persistent &signature.parameters \NamedType-type Array:map<NamedType, Type> @parameters
    $ctx $stack $word.name $parameters $signature.returns make FunType make Type.Fun push
    $word make FunRef
    make Word.FunRef 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-indirect-call(ctx: .WordCtx, stack: .Stack, token: .Token) -> Result<[Word, bool], ResolveError> { block {
    $ctx $stack pop match {
        case None -> { $ctx.ctx $token "`->` expected a function on the stack, got: []" abort<[Word, bool]> break }
        case Some -> {}
    } @fun-type
    $fun-type match {
        case Fun -> {}
        case _ -> { 
            drop
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt "`->` expected a function on the stack, got: [" Fmt:write
            &fmt &fun-type Type-format
            &fmt "]" Fmt:write
            $ctx.ctx $token $msg ~ ByteArray:unpack abort<[Word, bool]> break
        }
    } @fun-type
    $ctx $stack $token 0 !.Array<Type> &fun-type.parameters &fun-type.returns type-check-call-unnamed match {
        case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        case None -> {}
    }
    $token ~ $fun-type make IndirectCall
    make Word.IndirectCall 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn type-check-call(ctx: .WordCtx, stack: .Stack, token: .Token, generic-arguments: .Array<Type>, parameters: .Array<NamedType>, returns: .Array<Type>) -> Maybe<ResolveError> {
    $ctx $stack $token $generic-arguments $parameters expect-arguments match {
        case None -> {
            $ctx $stack $returns $generic-arguments push-returns
            make Maybe<ResolveError>.None
        }
        case Some -> { make Maybe<ResolveError>.Some }
    }
}
fn type-check-call-unnamed(ctx: .WordCtx, stack: .Stack, token: .Token, generic-arguments: .Array<Type>, parameters: .Array<Type>, returns: .Array<Type>) -> Maybe<ResolveError> {
    $ctx $stack $token $parameters expect match {
        case None -> {
            $ctx $stack $returns $generic-arguments push-returns
            make Maybe<ResolveError>.None
        }
        case Some -> { make Maybe<ResolveError>.Some }
    }
}

fn push-returns(ctx: .WordCtx, stack: .Stack, returns: .Array<Type>, generic-arguments: .Array<Type>) {
    0 @i
    loop {
        $i $returns.len = if { break }
        $returns $i Array:get<Type> @return
        $generic-arguments 0 !.Array<Type> = if {
            $return ~
        } else {
            $ctx $generic-arguments $return resolve-generic
        } @concrete-return-type
        $ctx $stack $concrete-return-type push
        $i 1 + #i
    }
}

fn resolve-mk-varint(ctx: .WordCtx, stack: .Stack, word: .P:MakeVariant) -> Result<[Word, bool], ResolveError> { block {
    $ctx.ctx $ctx.imports &word.type resolve-custom-type match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @varint-type
    $ctx.type-lookup &varint-type.type-definition lookup-type match {
        case Variant -> {}
        case Struct -> {
            drop
            $ctx.ctx &word.token "can not make this type" abort<[Word, bool]> break
        }
    } @varint
    0 @i
    loop {
        $i $varint.cases.len = if {
            $ctx.ctx &word.token "case is not part of variant" abort<i32> break
        }
        &varint.cases $i Array:get<VariantCase> @cays
        &cays.name Token-lexeme &word.cays Token-lexeme Bytes:eq if {
            $i make Result<i32, ResolveError>.Success break
        }
        $i 1 + #i
    } match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @tag
    &varint.cases $tag Array:get<VariantCase> @cays
    &cays.type match {
        case None -> {}
        case Some -> {
            ~ @cays-type
            $ctx &varint-type.generic-arguments &cays-type resolve-generic @expected
            $ctx $stack &word.token &expected "TODO" expect1 match {
                case Some -> { make Result<[Word, bool], ResolveError>.Error break }
                case None -> {}
            }
        }
    }
    $ctx $stack $varint-type make Type.Custom push
    $word.token $tag $varint-type make VariantWord
    make Word.VariantWord 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-unpack-tuple(ctx: .WordCtx, stack: .Stack, token: .Token) -> Result<[Word, bool], ResolveError> { block {
    $ctx $stack pop match {
        case None -> { $ctx.ctx $token "expected a tuple on the stack" abort<[Word, bool]> break }
        case Some -> {}
    } @type
    $type match {
        case Tuple -> {}
        case _ -> { drop $ctx.ctx $token "expected a tuple on the stack" abort<[Word, bool]> break }
    } @tuple
    $ctx $stack &tuple.items push-many
    $token ~ $type
    make UnpackTuple make Word.UnpackTuple 0 1 = [,2] make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-mk-tuple(ctx: .WordCtx, stack: .Stack, word: .P:MakeTuple) -> Result<[Word, bool], ResolveError> { block {
    &word.items Token-lexeme Util:parse @num-items
    $ctx.persistent $num-items Array:new-with-capacity<Type> @items
    loop {
        $items.len $num-items = if { make Maybe<ResolveError>.None break }
        $ctx $stack pop match {
            case None -> { $ctx.ctx &word.token "expected more" abort-m break }
            case Some -> {}
        } $ctx.persistent flip &items flip Array:push<Type>
    } match {
        case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        case None -> {}
    }
    &items Array:reverse<Type>
    $word.token $items make TupleType make Type.Tuple @type
    $ctx $stack $type push
    $word.token $type make MakeTuple
    make Word.MakeTuple 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-mk-struc(ctx: .WordCtx, stack: .Stack, word: .P:MakeStruct) -> Result<[Word, bool], ResolveError> { block {
    $ctx.ctx $ctx.imports &word.type resolve-custom-type match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @struct-type
    $ctx.type-lookup &struct-type.type-definition lookup-type match {
        case Struct -> {}
        case Variant -> {
            drop
            $ctx.ctx &word.token "can not make this type" abort<[Word, bool]> break
        }
    } @struc

    $ctx $stack &word.token &struct-type.generic-arguments &struc.fields expect-arguments match {
        case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        case None -> {}
    }
    $ctx $stack $struct-type make Type.Custom push
    $word.token $struct-type make StructWord make Word.StructWord 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-mk-struc-named(ctx: .WordCtx, stack: .Stack, word: .P:MakeStructNamed) -> Result<[Word, bool], ResolveError> { block {
    $ctx.ctx $ctx.imports &word.type resolve-custom-type match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @struct-type
    $ctx.type-lookup &struct-type.type-definition lookup-type match {
        case Struct -> {}
        case Variant -> {
            drop
            $ctx.ctx &word.token "can not make this type" abort<[Word, bool]> break
        }
    } @struc
    \ByteSlice:eq-by-ref Map:new<ByteSlice, [i32, Type]> @fields
    0 @i
    loop {
        $struc.fields.len $i = if { break }
        &struc.fields $i Array:get<NamedType> @field
        $ctx.temp &fields &field.name Token-lexeme make ByteSlice
        $i $ctx &struct-type.generic-arguments &field.type resolve-generic [,2]
        Map:insert<ByteSlice, [i32, Type]> drop
        $i 1 + #i
    }
    make StructLitCtx {
        $struct-type.type-definition @struc
        $struct-type.generic-arguments @generic-arguments
        $fields @fields
    } @struc-lit-ctx
    &ctx.env Env:child @env
    $ctx &struc-lit-ctx with-struc-lit-ctx @child-ctx
    &child-ctx $env with-env @child-ctx
    &child-ctx $stack &word.body.words resolve-words match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } [,] @diverges @body
    $struc-lit-ctx.fields.values.len 0 /= if {
        $ctx.temp Fmt:into-new-string @msg @fmt
        &fmt "missing fields in struct literal:" Fmt:write
        0 @i
        loop {
            $i $struc-lit-ctx.fields.values.len = if { break }
            &fmt "\n\t" Fmt:write
            &fmt &struc-lit-ctx.fields.keys $i Array:get<ByteSlice> ~ ByteSlice:unpack Fmt:write
            &fmt ": " Fmt:write

            &fmt
            $ctx.type-lookup
            &struc-lit-ctx.fields.values $i Array:get<[i32, Type]> !.Type sizeof(i32) +
            Type-pretty

            $i 1 + #i
        }
        $ctx.ctx &word.token $msg ~ ByteArray:unpack abort<[Word, bool]> break
    }
    $ctx $stack $struct-type make Type.Custom push

    $word.token $struct-type $env.scope-id $body make Scope make StructWordNamed make Word.StructWordNamed
    $diverges [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-sizeof(ctx: .WordCtx, stack: .Stack, word: .P:Sizeof) -> Result<[Word, bool], ResolveError> { block (-> Result<[Word, bool], ResolveError>) {
    $ctx $stack make Type.I32 push
    $word.token
    $ctx.ctx $ctx.imports &word.type resolve-type match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    }
    make Sizeof
    make Word.Sizeof 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-cast(ctx: .WordCtx, stack: .Stack, word: .P:Cast) -> Result<[Word, bool], ResolveError> { block {
    $ctx $stack pop match {
        case None -> { $ctx.ctx &word.token "cast expected a value, got []" abort<[Word, bool]> break }
        case Some -> {}
    } @src
    $ctx.ctx $ctx.imports &word.type resolve-type match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @dst
    $ctx $stack $dst push
    $word.token $src $dst make Cast
    make Word.Cast 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-load(ctx: .WordCtx, stack: .Stack, token: .Token) -> Result<[Word, bool], ResolveError> { block {
    $ctx $stack pop match {
        case None -> { $ctx.ctx $token "`~` expected a ptr, got: []" abort<[Word, bool]> break }
        case Some -> {}
    } match {
        case Ptr -> {}
        case _ -> {
            @actual
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt "~` expected a ptr, got: [" Fmt:write
            &fmt $ctx.type-lookup &actual Type-pretty
            &fmt "]" Fmt:write
            $ctx.ctx $token $msg ~ ByteArray:unpack abort<[Word, bool]> break
        }
    } @type
    $ctx $stack $type ~ push
    $token ~ $type ~ make Load
    make Word.Load 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-call(ctx: .WordCtx, stack: .Stack, parsed-word: .P:Call) -> Result<[Word, bool], ResolveError> { block {
    $parsed-word match {
        case Local -> {
            @word
            &word.name Token-lexeme @name-len @name-ptr
            $name-ptr $name-len "gt" Bytes:eq
            $name-ptr $name-len "lt" Bytes:eq or
            $name-ptr $name-len "ge" Bytes:eq or
            $name-ptr $name-len "le" Bytes:eq or
            if {
                $ctx $stack pop match {
                    case None -> {
                        "`" ByteArray:init @msg
                        $ctx.temp &msg $name-ptr $name-len ByteArray:push
                        $ctx.temp &msg "` expected two values on the stack, got []" ByteArray:push
                        $ctx.ctx &word.name $msg ByteArray:unpack abort<[Word, bool]> break
                    }
                    case Some -> {}
                } @a
                $ctx $stack pop match {
                    case None -> {
                        $ctx.temp Fmt:into-new-string @msg @fmt
                        &fmt "`" Fmt:write
                        &fmt $name-ptr $name-len Fmt:write
                        &fmt "` expected two values on the stack, got [" Fmt:write
                        &fmt $ctx.type-lookup &a Type-pretty
                        &fmt "]" Fmt:write
                        $ctx.ctx &word.name $msg ~ ByteArray:unpack abort<[Word, bool]> break
                    }
                    case Some -> {}
                } @b
                &a &b Type-eq not if {
                    $ctx.temp Fmt:into-new-string @msg @fmt
                    &fmt "`" Fmt:write
                    &fmt $name-ptr $name-len Fmt:write
                    &fmt "` expected two values of the same type, got [" Fmt:write
                    &fmt $ctx.type-lookup &a Type-pretty
                    &fmt ", " Fmt:write
                    &fmt $ctx.type-lookup &b Type-pretty
                    &fmt "]" Fmt:write
                    $ctx.ctx &word.name $msg ~ ByteArray:unpack abort<[Word, bool]> break
                }
                $a match {
                    case I8 -> {}
                    case I32 -> {}
                    case I64 -> {}
                    case _ -> {
                        drop
                        $ctx.temp Fmt:into-new-string @msg @fmt
                        &fmt "`" Fmt:write
                        &fmt $name-ptr $name-len Fmt:write
                        &fmt "` expected [i8, i8] or [i32, i32] or [i64, i64], got [" Fmt:write
                        &fmt $ctx.type-lookup &a Type-pretty
                        &fmt ", " Fmt:write
                        &fmt $ctx.type-lookup &b Type-pretty
                        &fmt "]" Fmt:write
                        $ctx.ctx &word.name $msg ~ ByteArray:unpack abort<[Word, bool]> break
                    }
                }
                $a
                block {
                    $name-ptr $name-len "gt" Bytes:eq if { make Intrinsic.Gt break }
                    $name-ptr $name-len "lt" Bytes:eq if { make Intrinsic.Lt break }
                    $name-ptr $name-len "ge" Bytes:eq if { make Intrinsic.Ge break }
                    make Intrinsic.Le
                }
                $ctx $stack $ctx.Bool ~ push
                $word.name flip make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "%" Bytes:eq
            $name-ptr $name-len "*" Bytes:eq or
            $name-ptr $name-len "/" Bytes:eq or
            if {
                $ctx $stack pop match {
                    case None -> {
                        "`" ByteArray:init @msg
                        $ctx.temp &msg $name-ptr $name-len ByteArray:push
                        $ctx.temp &msg "` expected two values on the stack, got []" ByteArray:push
                        $ctx.ctx &word.name $msg ByteArray:unpack abort<[Word, bool]> break
                    }
                    case Some -> {}
                } @a
                $ctx $stack pop match {
                    case None -> {
                        $ctx.temp Fmt:into-new-string @msg @fmt
                        &fmt "`" Fmt:write
                        &fmt $name-ptr $name-len Fmt:write
                        &fmt "` expected two values on the stack, got [" Fmt:write
                        &fmt $ctx.type-lookup &a Type-pretty
                        &fmt "]" Fmt:write
                        $ctx.ctx &word.name $msg ~ ByteArray:unpack abort<[Word, bool]> break
                    }
                    case Some -> {}
                } @b
                &a &b Type-eq not if {
                    $ctx.temp Fmt:into-new-string @msg @fmt
                    &fmt "`" Fmt:write
                    &fmt $name-ptr $name-len Fmt:write
                    &fmt "` expected two values of the same type, got [" Fmt:write
                    &fmt $ctx.type-lookup &a Type-pretty
                    &fmt ", " Fmt:write
                    &fmt $ctx.type-lookup &b Type-pretty
                    &fmt "]" Fmt:write
                    $ctx.ctx &word.name $msg ~ ByteArray:unpack abort<[Word, bool]> break
                }
                $a match {
                    case I32 -> {}
                    case I64 -> {}
                    case _ -> {
                        drop
                        $ctx.temp Fmt:into-new-string @msg @fmt
                        &fmt "`" Fmt:write
                        &fmt $name-ptr $name-len Fmt:write
                        &fmt "` expected [i32, i32] or [i64, i64], got [" Fmt:write
                        &fmt $ctx.type-lookup &a Type-pretty
                        &fmt ", " Fmt:write
                        &fmt $ctx.type-lookup &b Type-pretty
                        &fmt "]" Fmt:write
                        $ctx.ctx &word.name $msg ~ ByteArray:unpack abort<[Word, bool]> break
                    }
                }
                $ctx $stack $a push
                $a
                block {
                    $name-ptr $name-len "%"  Bytes:eq if { make Intrinsic.Mod break }
                    $name-ptr $name-len "*"  Bytes:eq if { make Intrinsic.Mul break }
                    make Intrinsic.Div
                }
                $word.name flip make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "-" Bytes:eq
            $name-ptr $name-len "+" Bytes:eq or
            if {
                $ctx $stack pop match {
                    case None -> {
                        "`" ByteArray:init @msg
                        $ctx.temp &msg $name-ptr $name-len ByteArray:push
                        $ctx.temp &msg "` expected two values on the stack, got []" ByteArray:push
                        $ctx.ctx &word.name $msg ByteArray:unpack abort<[Word, bool]> break
                    }
                    case Some -> {}
                } @b
                $ctx $stack pop match {
                    case None -> {
                        $ctx.temp Fmt:into-new-string @msg @fmt
                        &fmt "`" Fmt:write
                        &fmt $name-ptr $name-len Fmt:write
                        &fmt "` expected two values on the stack, got [" Fmt:write
                        &fmt $ctx.type-lookup &b Type-pretty
                        &fmt "]" Fmt:write
                        $ctx.ctx &word.name $msg ~ ByteArray:unpack abort<[Word, bool]> break
                    }
                    case Some -> {}
                } @a
                &a match {
                    case I8 -> { &a &b Type-eq }
                    case I32 -> { &a &b Type-eq }
                    case I64 -> { &a &b Type-eq }
                    case Ptr -> { drop &b match {
                        case I32 -> { 1 1 = }
                        case _ -> { drop 0 1 = }
                    } }
                    case _ -> { drop 0 1 = }
                } not if {
                    $ctx.temp Fmt:into-new-string @msg @fmt
                    &fmt "`" Fmt:write
                    &fmt $name-ptr $name-len Fmt:write
                    &fmt "` expected [i8, i8], [i32, i32], [.{any}, i32] or [i64, i64], got [" Fmt:write
                    &fmt $ctx.type-lookup &a Type-pretty
                    &fmt ", " Fmt:write
                    &fmt $ctx.type-lookup &b Type-pretty
                    &fmt "]" Fmt:write
                    $ctx.ctx &word.name $msg ~ ByteArray:unpack abort<[Word, bool]> break
                }
                $ctx $stack $a push
                block {
                    $name-ptr $name-len "-" Bytes:eq if {
                        $b make Intrinsic.Sub break
                    }
                    $b make Intrinsic.Add break
                }
                $word.name flip make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "mem-copy" Bytes:eq if {
                $ctx $stack &word.name $ctx.ptr-I8 $ctx.ptr-I8 $ctx.I32 "`mem-copy` expected [.i8, .i8, i32]" expect3 match {
                    case Some -> { make Result<[Word, bool], ResolveError>.Error break }
                    case None -> {}
                }
                $word.name make Intrinsic.MemCopy make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "mem-fill" Bytes:eq if {
                $ctx $stack &word.name $ctx.ptr-I32 $ctx.I32 $ctx.I32 "`mem-fill` expected [.i32, i32, i32]" expect3 match {
                    case Some -> { make Result<[Word, bool], ResolveError>.Error break }
                    case None -> {}
                }
                $word.name make Intrinsic.MemFill make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "mem-grow" Bytes:eq if {
                $ctx $stack &word.name $ctx.I32 "`mem-grow` expected [i32]" expect1 match {
                    case Some -> { make Result<[Word, bool], ResolveError>.Error break }
                    case None -> {}
                }
                $ctx $stack make Type.I32 push
                make Intrinsic.MemGrow
                $word.name flip make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "=" Bytes:eq
            $name-ptr $name-len "/=" Bytes:eq or if {
                $ctx $stack &word.name "expected [a, a]" pop2 match {
                    case Error -> { make Result<[Word, bool], ResolveError>.Error break }
                    case Success -> {}
                } [,] @a @b
                &a &b Type-eq not if {
                    $ctx.ctx &word.name "cannot compare two different types" abort<[Word, bool]> break
                }
                $ctx $stack make Type.Bool push
                $word.name
                $a $name-ptr ~ "=" drop ~ = if { make Intrinsic.Eq } else { make Intrinsic.NotEq }
                make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "drop" Bytes:eq if {
                $ctx $stack &word.name "drop expected a value" pop1 match {
                    case Error -> { make Result<[Word, bool], ResolveError>.Error break }
                    case Success -> {}
                } drop
                $word.name make Word.Drop 0 1 = [,2] make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "flip" Bytes:eq if {
                $ctx $stack &word.name "drop expected two values" pop2 match {
                    case Error -> { make Result<[Word, bool], ResolveError>.Error break }
                    case Success -> {}
                } [,] @upper @lower
                $ctx $stack $upper push
                $ctx $stack $lower push
                $word.name $lower $upper make Flip make Word.Flip
                0 1 = [,2] make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "not" Bytes:eq if {
                "`not` expected [bool | i32 | i64]" @msg-len @msg-ptr
                $ctx $stack &word.name $msg-ptr $msg-len pop1 match {
                    case Error -> { make Result<[Word, bool], ResolveError>.Error break }
                    case Success -> {}
                } @a
                &a match {
                    case Bool -> {}
                    case I32 -> {}
                    case I64 -> {}
                    case _ -> { drop $ctx.ctx &word.name $msg-ptr $msg-len abort<[Word, bool]> break }
                }
                $ctx $stack $a push
                $word.name $a make Intrinsic.Not make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "and" Bytes:eq if {
                "`and` expected [bool, bool] or [i32, i32] or [i64, i64]" @msg-len @msg-ptr
                $ctx $stack &word.name $msg-ptr $msg-len pop2 match {
                    case Error -> { make Result<[Word, bool], ResolveError>.Error break }
                    case Success -> {}
                } [,] @a @b
                &a &b Type-eq not if { $ctx.ctx &word.name $msg-ptr $msg-len abort<[Word, bool]> break }
                &a match {
                    case Bool -> {}
                    case I32 -> {}
                    case I64 -> {}
                    case _ -> { drop $ctx.ctx &word.name $msg-ptr $msg-len abort<[Word, bool]> break }
                }
                $ctx $stack $a push
                $word.name $a make Intrinsic.And make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "or" Bytes:eq if {
                "`or` expected [bool, bool] or [i32, i32] or [i64, i64]" @msg-len @msg-ptr
                $ctx $stack &word.name $msg-ptr $msg-len pop2 match {
                    case Error -> { make Result<[Word, bool], ResolveError>.Error break }
                    case Success -> {}
                } [,] @a @b
                &a &b Type-eq not if { $ctx.ctx &word.name $msg-ptr $msg-len abort<[Word, bool]> break }
                &a match {
                    case Bool -> {}
                    case I32 -> {}
                    case I64 -> {}
                    case _ -> { drop $ctx.ctx &word.name $msg-ptr $msg-len abort<[Word, bool]> break }
                }
                $ctx $stack $a push
                $word.name $a make Intrinsic.Or make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "shl" Bytes:eq
            $name-ptr $name-len "shr" Bytes:eq or
            $name-ptr $name-len "rotl" Bytes:eq or
            $name-ptr $name-len "rotr" Bytes:eq or
            if {
                $ctx $stack &word.name "expected [i8, i8] or [i32, i32] or [i64, i64]" pop2 match {
                    case Error -> { make Result<[Word, bool], ResolveError>.Error break }
                    case Success -> {}
                } [,] @shift @value
                $value match {
                    case I8 -> { 1 1 = }
                    case I32 -> { 1 1 = }
                    case I64 -> { 1 1 = }
                    case _ -> {
                        drop
                        0 1 =
                    }
                } if {
                    &value &shift Type-eq
                } else {
                    1 0 =
                } not if {
                    $ctx.temp Fmt:into-new-string @msg @fmt
                    &fmt "`" Fmt:write
                    &fmt &word.name Token-lexeme Fmt:write
                    &fmt "` " Fmt:write
                    &fmt "expected [i8, i8] or [i32, i32] or [i64, i64]" Fmt:write
                    &fmt ", got: [" Fmt:write
                    &fmt $ctx.type-lookup &value Type-pretty
                    &fmt ", " Fmt:write
                    &fmt $ctx.type-lookup &shift Type-pretty
                    &fmt "]" Fmt:write
                    $ctx.ctx &word.name $msg ~ ByteArray:unpack abort<[Word, bool]> break
                }
                $ctx $stack $value push
                $word.name $value block (Type -> Intrinsic) {
                    $name-ptr $name-len "shl" Bytes:eq if {
                        make Intrinsic.Shl break
                    }
                    $name-ptr $name-len "shr" Bytes:eq if {
                        make Intrinsic.Shr break
                    }
                    $name-ptr $name-len "rotl" Bytes:eq if {
                        make Intrinsic.Rotl break
                    }
                    make Intrinsic.Rotr
                } make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "uninit" Bytes:eq if {
                $ctx.ctx $ctx.imports &word.generic-arguments resolve-types match {
                    case Error -> { make Result<[Word, bool], ResolveError>.Error break }
                    case Success -> {}
                } @resolved-generic-arguments
                $resolved-generic-arguments.len 1 /= if {
                    $ctx.ctx &word.name "uninit expected exactly one generic arguments" abort<[Word, bool]> break
                }
                $word.name &resolved-generic-arguments 0 Array:get<Type> ~ Core:dup<Type>
                $ctx flip $stack flip push
                make Uninit
                make Word.Uninit 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "store" Bytes:eq if {
                $ctx $stack &word.name "store expected [.a, a]" pop2 match {
                    case Error -> { make Result<[Word, bool], ResolveError>.Error break }
                    case Success -> {}
                } [,] @value match {
                    case Ptr -> {
                        @child $child &value Type-eq not if {
                            $ctx.temp Fmt:into-new-string @msg @fmt
                            &fmt "store expected [.a, a], got: [." Fmt:write
                            &fmt $ctx.type-lookup $child Type-pretty
                            &fmt ", " Fmt:write
                            &fmt $ctx.type-lookup &value Type-pretty
                            &fmt "]" Fmt:write
                            $ctx.ctx &word.name $msg ~ ByteArray:unpack abort<[Word, bool]> break
                        }
                    }
                    case _ -> {
                        @actual
                        $ctx.temp Fmt:into-new-string @msg @fmt
                        &fmt "store expected [.a, a], got: [" Fmt:write
                        &fmt $ctx.type-lookup &actual Type-pretty
                        &fmt ", " Fmt:write
                        &fmt $ctx.type-lookup &value Type-pretty
                        &fmt "]" Fmt:write
                        $ctx.ctx &word.name $msg ~ ByteArray:unpack abort<[Word, bool]> break
                    }
                }
                $word.name
                $value make Intrinsic.Store
                make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
            $name-ptr $name-len "set-stack-size" Bytes:eq if {
                $ctx $stack &word.name $ctx.I32 "`set-stack-size` expected i32" expect1 match {
                    case Some -> { make Result<[Word, bool], ResolveError>.Error break }
                    case None -> {}
                }
                $word.name make Intrinsic.SetStackSize make IntrinsicWord
                make Word.Intrinsic 0 1 = [,2]
                make Result<[Word, bool], ResolveError>.Success break
            }
        }
        case Foreign -> { drop }
    }
    $ctx $parsed-word resolve-call-word match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @word
    $ctx &word.function lookup-signature @signature
    $ctx $stack &word.name &word.generic-arguments &signature.parameters &signature.returns type-check-call match {
        case None -> {}
        case Some -> { make Result<[Word, bool], ResolveError>.Error break }
    }

    $word make Word.Call 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success break
} }

fn resolve-call-word(ctx: .WordCtx, word: .P:Call) -> Result<Call, ResolveError> { block {
    $word match {
        case Local -> {
            @word
            $ctx.ctx $ctx.imports &word.generic-arguments resolve-types match {
                case Error -> { make Result<Call, ResolveError>.Error break }
                case Success -> {}
            } @resolved-generic-arguments
            &word.name Token-lexeme @name-len @name-ptr
            $ctx &word.name find-function match {
                case None -> {
                    $ctx.ctx &word.name function-not-found-error make Result<Call, ResolveError>.Error break
                }
                case Some -> {}
            } @function
            $ctx &function lookup-signature @signature
            $signature.generic-parameters.len $resolved-generic-arguments.len /= if {
                $ctx.ctx &word.name $signature.generic-parameters.len $resolved-generic-arguments.len
                generic-arguments-mismatch-error make Result<Call, ResolveError>.Error break
            }
            $word.name $function $resolved-generic-arguments make Call
            make Result<Call, ResolveError>.Success break
        }
        case Foreign -> {
            @word
            $ctx.ctx $ctx.imports &word.generic-arguments resolve-types match {
                case Error -> { make Result<Call, ResolveError>.Error break }
                case Success -> {}
            } @resolved-generic-arguments
            $ctx.imports &word.module Token-lexeme Map:get-bs<Array<Import>> match {
                case None -> { $ctx.ctx &word.name "module not found" abort<Call> break }
                case Some -> {}
            } @imports
            0 @i
            loop {
                $imports.len $i = if {
                    $ctx.ctx &word.name function-not-found-error make Result<Call, ResolveError>.Error break
                }
                $imports $i Array:get<Import> @imp
                $ctx.ctx.resolved-modules $imp.module.index Array:get<Module> @module
                &module.functions &word.name Token-lexeme Map:get-bs-with-index<FunctionOrExtern> match {
                    case None -> {}
                    case Some -> {
                        [,] @function-id @function
                        $function FunctionOrExtern-signature @signature
                        $signature.generic-parameters.len $resolved-generic-arguments.len /= if {
                            $ctx.ctx &word.name $signature.generic-parameters.len $resolved-generic-arguments.len
                            generic-arguments-mismatch-error make Result<Call, ResolveError>.Error break
                        }
                        $word.name
                        $imp.module $function-id make FunctionHandle
                        $resolved-generic-arguments
                        make Call
                        make Result<Call, ResolveError>.Success break
                    }
                }
                $i 1 + #i
            }
        }
    }
} }

fn function-not-found-error(ctx: .Ctx, name: .Token) -> ResolveError {
    $ctx.temp Fmt:into-new-string @buf @fmt
    &fmt "function `" Fmt:write
    &fmt $name Token-lexeme Fmt:write
    &fmt "` not found" Fmt:write
    $ctx $name $buf ~ ByteArray:unpack error
}

fn find-function(ctx: .WordCtx, name: .Token) -> Maybe<FunctionHandle> {
    0 @i
    0 @function-index
    loop {
        $i $ctx.ctx.top-items.len = if {
            0 @i
            loop {
                $i $ctx.imports.values.len = if { make Maybe<FunctionHandle>.None break }
                &ctx.imports.values $i Array:get<Array<Import>> @imps
                0 @j
                loop {
                    $j $imps.len = if { make Maybe<FunctionHandle>.None break }
                    $imps $j Array:get<Import> @imp
                    0 @k
                    loop {
                        $k $imp.items.len = if { make Maybe<FunctionHandle>.None break }
                        &imp.items $k Array:get<ImportItem> @item
                        &item.name Token-lexeme $name Token-lexeme Bytes:eq if {
                            &item.handle match {
                                case Function -> { ~ make Maybe<FunctionHandle>.Some break }
                                case CustomType -> { drop }
                            }
                        }
                        $k 1 + #k
                    } match {
                        case None -> {}
                        case Some -> { make Maybe<FunctionHandle>.Some break }
                    }
                    $j 1 + #j
                } match {
                    case None -> {}
                    case Some -> { make Maybe<FunctionHandle>.Some break }
                }
                $i 1 + #i
            } break
        }
        $ctx.ctx.top-items $i Array:get<TopItem> match {
            case Function -> {
                @fun
                &fun.name Token-lexeme $name Token-lexeme Bytes:eq if {
                    $ctx.ctx.module-id $function-index make FunctionHandle
                    make Maybe<FunctionHandle>.Some break
                }
                $function-index 1 + #function-index
            }
            case Extern -> {
                @ext
                &ext.name Token-lexeme $name Token-lexeme Bytes:eq if {
                    $ctx.ctx.module-id $function-index make FunctionHandle
                    make Maybe<FunctionHandle>.Some break
                }
                $function-index 1 + #function-index
            }
            case _ -> { drop }
        }
        $i 1 + #i
    }
}

fn pop1(ctx: .WordCtx, stack: .Stack, token: .Token, expected-ptr: .i8, expected-len: i32) -> Result<Type, ResolveError> { block {
    $ctx $stack pop match {
        case None -> {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt $expected-ptr $expected-len Fmt:write
            &fmt ", got: []" Fmt:write
            $ctx.ctx $token $msg ~ ByteArray:unpack abort<Type> break
        }
        case Some -> {}
    } make Result<Type, ResolveError>.Success
} }

fn pop2(ctx: .WordCtx, stack: .Stack, token: .Token, expected-ptr: .i8, expected-len: i32) -> Result<[Type, Type], ResolveError> { block {
    $ctx $stack pop match {
        case None -> {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt $expected-ptr $expected-len Fmt:write
            &fmt ", got: []" Fmt:write
            $ctx.ctx $token $msg ~ ByteArray:unpack abort<[Type, Type]> break
        }
        case Some -> {}
    } @b
    $ctx $stack pop match {
        case None -> {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt $expected-ptr $expected-len Fmt:write
            &fmt ", got: [" Fmt:write
            &fmt $ctx.type-lookup &b Type-pretty
            &fmt "]" Fmt:write
            $ctx.ctx $token $msg ~ ByteArray:unpack abort<[Type, Type]> break
        }
        case Some -> {}
    } $b [,2] make Result<[Type, Type], ResolveError>.Success
} }

fn pop3(ctx: .WordCtx, stack: .Stack, token: .Token, expected-ptr: .i8, expected-len: i32) -> Result<[Type, Type, Type], ResolveError> { block {
    $ctx $stack pop match {
        case None -> {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt $expected-ptr $expected-len Fmt:write
            &fmt ", got: []" Fmt:write
            $ctx.ctx $token $msg ~ ByteArray:unpack abort<[Type, Type, Type]> break
        }
        case Some -> {}
    } @c
    $ctx $stack pop match {
        case None -> {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt $expected-ptr $expected-len Fmt:write
            &fmt ", got: [" Fmt:write
            &fmt $ctx.type-lookup &c Type-pretty
            &fmt "]" Fmt:write
            $ctx.ctx $token $msg ~ ByteArray:unpack abort<[Type, Type, Type]> break
        }
        case Some -> {}
    } @b
    $ctx $stack pop match {
        case None -> {
            $ctx.temp Fmt:into-new-string @msg @fmt
            &fmt $expected-ptr $expected-len Fmt:write
            &fmt ", got: [" Fmt:write
            &fmt $ctx.type-lookup &b Type-pretty
            &fmt ", " Fmt:write
            &fmt $ctx.type-lookup &c Type-pretty
            &fmt "]" Fmt:write
            $ctx.ctx $token $msg ~ ByteArray:unpack abort<[Type, Type, Type]> break
        }
        case Some -> {}
    } $b $c [,3] make Result<[Type, Type, Type], ResolveError>.Success
} }

fn type-mismatch-error(ctx: .WordCtx, token: .Token, expected: .Array<Type>, actual: .Array<Type>) -> Maybe<ResolveError> {
    $ctx.temp Fmt:into-new-string @msg @fmt
    &fmt "expected:\n\t" Fmt:write
    &fmt $ctx.type-lookup $expected Types-pretty-bracketed
    &fmt "\ngot:\n\t" Fmt:write
    &fmt $ctx.type-lookup $actual   Types-pretty-bracketed
    $ctx.ctx $token $msg ~ ByteArray:unpack abort-m
}
fn expect(ctx: .WordCtx, stack: .Stack, token: .Token, expected: .Array<Type>) -> Maybe<ResolveError> { block {
    $expected.len @i
    $ctx.temp Arena:temp @temp @save
    $temp $expected.len Array:new-with-capacity<Type> @popped
    loop {
        $i 0 = if { make Maybe<ResolveError>.None break }
        $expected $i 1 - Array:get<Type> @expected-type
        $ctx $stack pop match {
            case None -> { 1 1 = }
            case Some -> {
                @popped-type
                &popped-type $expected-type Type-eq not
                &popped $popped-type Array:push-assert-no-alloc<Type>
            }
        } if {
            &popped Array:reverse<Type>
            $ctx $token $expected &popped type-mismatch-error break
        }
        $i 1 - #i
    }
    $temp $save Arena:restore
} }
fn expect-arguments(ctx: .WordCtx, stack: .Stack, function-name: .Token, generic-arguments: .Array<Type>, parameters: .Array<NamedType>) -> Maybe<ResolveError> { block {
    $parameters.len @i
    $ctx.temp Arena:temp @temp @save
    $temp $parameters.len Array:new-with-capacity<Type> @popped
    loop {
        $i 0 = if { make Maybe<ResolveError>.None break }
        $ctx $generic-arguments
        $parameters $i 1 - Array:get<NamedType> .type
        resolve-generic @expected-type
        $ctx $stack pop match {
            case None -> { 1 1 = }
            case Some -> {
                @popped-type &popped-type &expected-type Type-eq not
                $temp &popped $popped-type Array:push<Type>
            }
        } if {
            loop {
                $ctx $stack pop match {
                    case None -> { break }
                    case Some -> { $temp flip &popped flip Array:push<Type> }
                }
            }
            $ctx.temp $parameters \NamedType-type Array:map<NamedType, Type> @expected
            &popped Array:reverse<Type>
            $ctx $function-name &expected &popped type-mismatch-error break
        }
        $i 1 - #i
    }
    $temp $save Arena:restore
} }
fn expect1(ctx: .WordCtx, stack: .Stack, token: .Token, a: .Type, expected-ptr: .i8, expected-len: i32) -> Maybe<ResolveError> { block {
    $ctx $stack $token $expected-ptr $expected-len pop1 match {
        case Error -> { make Maybe<ResolveError>.Some break }
        case Success -> {}
    } @actual-a
    &actual-a $a Type-eq not if {
        $ctx.temp Fmt:into-new-string @msg @fmt
        &fmt $expected-ptr $expected-len Fmt:write
        &fmt ", got: [" Fmt:write &fmt $ctx.type-lookup &actual-a Type-pretty &fmt "]" Fmt:write
        $ctx.ctx $token $msg ~ ByteArray:unpack abort-m
    } else {
        make Maybe<ResolveError>.None
    }
} }
fn expect2(ctx: .WordCtx, stack: .Stack, token: .Token, a: .Type, b: .Type, expected-ptr: .i8, expected-len: i32) -> Maybe<ResolveError> { block {
    $ctx $stack $token $expected-ptr $expected-len pop2 match {
        case Error -> { make Maybe<ResolveError>.Some break }
        case Success -> {}
    } [,] @actual-b @actual-a
    block {
        &actual-b $b Type-eq not if { 1 1 = break }
        &actual-a $a Type-eq not if { 1 1 = break }
        0 1 =
    } if {
        $ctx.temp Fmt:into-new-string @msg @fmt
        &fmt $expected-ptr $expected-len Fmt:write
        &fmt ", got: [" Fmt:write
        &fmt $ctx.type-lookup &actual-a Type-pretty &fmt ", " Fmt:write
        &fmt $ctx.type-lookup &actual-b Type-pretty &fmt "]"  Fmt:write
        $ctx.ctx $token $msg ~ ByteArray:unpack abort-m
    } else {
        make Maybe<ResolveError>.None
    }
} }
fn expect3(ctx: .WordCtx, stack: .Stack, token: .Token, a: .Type, b: .Type, c: .Type, expected-ptr: .i8, expected-len: i32) -> Maybe<ResolveError> { block {
    $ctx $stack $token $expected-ptr $expected-len pop3 match {
        case Error -> { make Maybe<ResolveError>.Some break }
        case Success -> {}
    } [,] @actual-c @actual-b @actual-a
    block {
        &actual-c $c Type-eq not if { 1 1 = break }
        &actual-b $b Type-eq not if { 1 1 = break }
        &actual-a $a Type-eq not if { 1 1 = break }
        0 1 =
    } if {
        $ctx.temp Fmt:into-new-string @msg @fmt
        &fmt $expected-ptr $expected-len Fmt:write
        &fmt ", got: [" Fmt:write
        &fmt $ctx.type-lookup &actual-a Type-pretty &fmt ", " Fmt:write
        &fmt $ctx.type-lookup &actual-b Type-pretty &fmt ", " Fmt:write
        &fmt $ctx.type-lookup &actual-c Type-pretty &fmt "]"  Fmt:write
        $ctx.ctx $token $msg ~ ByteArray:unpack abort-m
    } else {
        make Maybe<ResolveError>.None
    }
} }

fn resolve-init-local(ctx: .WordCtx, stack: .Stack, word: .P:InitLocal) -> Result<[Word, bool], ResolveError> { block {
    $ctx $stack pop match {
        case None -> { $ctx.ctx &word.start "local init expected item on stack" abort<[Word, bool]> break }
        case Some -> {}
    } @type
    $ctx.struc-lit-ctx match {
        case None -> {}
        case Some -> {
            @struc-lit-ctx
            &struc-lit-ctx.fields &word.ident Token-lexeme Map:remove-bs<[i32, Type]> match {
                case None -> {}
                case Some -> {
                    [,] @field-type @field-index
                    $ctx &struc-lit-ctx.generic-arguments &field-type resolve-generic @field-type
                    &type &field-type Type-eq not if {
                        $ctx.ctx &word.ident "expected different type for field" abort<[Word, bool]> break
                    }
                    make FieldInit {
                        $field-index @field-index
                        $field-type @type
                        $word.ident @name
                        $struc-lit-ctx.generic-arguments @generic-arguments
                        $struc-lit-ctx.struc @struc
                    }
                    make Word.FieldInit 0 1 = [,2]
                    make Result<[Word, bool], ResolveError>.Success break
                }
            }
        }
    }
    make Env:Local {
        $type @type
        $word.ident @name
        0 1 = @reffed
        0 1 = @is-parameter
    } @local
    $ctx.temp &ctx.env $local Env:insert @local-id
    $word.ident
    $type
    $local-id
    make InitLocal
    make Word.InitLocal 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-get-field(ctx: .WordCtx, stack: .Stack, word: .P:GetField) -> Result<[Word, bool], ResolveError> { block {
    $ctx $stack pop match {
        case None -> { $ctx.ctx &word.token "expected a value on the stack" abort<[Word, bool]> break }
        case Some -> {}
    } @type
    $ctx $type &word.fields resolve-field-accesses match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @fields
    $type match {
        case Ptr -> { drop 1 1 = }
        case _ -> { drop 0 1 = }
    } @on-ptr
    &fields $fields.len 1 - Array:get<FieldAccess>.target-type @type
    $on-ptr if { $type make Type.Ptr } else { $type ~ } @type
    $ctx $stack $type push
    $word.token $fields $on-ptr $type make GetField
    make Word.GetField 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-get-local(ctx: .WordCtx, stack: .Stack, word: .P:GetLocal) -> Result<[Word, bool], ResolveError> { block {
    $ctx &word.ident resolve-var-name match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } [,] @type @var-id
    $ctx $type &word.fields resolve-field-accesses match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @fields
    $fields.len 0 = if {
        $type
    } else {
        &fields $fields.len 1 - Array:get<FieldAccess> .target-type ~
    } @resolved-type
    $ctx $stack $resolved-type push
    $word.ident $var-id $type $fields $resolved-type make GetLocal
    make Word.GetLocal 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-var-name(ctx: .WordCtx, name: .Token) -> Result<[VarId, Type], ResolveError> {
    &ctx.env $name Env:lookup match {
        case None -> {
            $ctx.globals $name Token-lexeme Map:get-bs-with-index<Global> match {
                case None -> { $ctx.ctx $name "var not found" abort<[VarId, Type]> }
                case Some -> {
                    [,] @id @globl
                    $name ~ $ctx.ctx.module-id $id make GlobalId make VarId.Global $globl.type [,2]
                    make Result<[VarId, Type], ResolveError>.Success
                }
            }
        }
        case Some -> {
            @local
            $local make VarId.Local
            &ctx.env &local Env:lookup-by-id .type ~
            [,2] make Result<[VarId, Type], ResolveError>.Success
        }
    }
}

fn resolve-set-local(ctx: .WordCtx, stack: .Stack, word: .P:SetLocal) -> Result<[Word, bool], ResolveError> { block {
    $ctx &word.ident resolve-var-name match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } [,] @type @var-id
    $ctx $type &word.fields resolve-field-accesses match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @fields
    $fields.len 0 = if {
        &type
    } else {
        &fields $fields.len 1 - Array:get<FieldAccess> .target-type
    } @resolved-type
    $ctx $stack &word.ident $resolved-type "TODO" expect1 match {
        case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        case None -> {}
    }
    $word.ident $var-id $fields $resolved-type ~ make SetLocal
    make Word.SetLocal 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-store(ctx: .WordCtx, stack: .Stack, word: .P:Store) -> Result<[Word, bool], ResolveError> { block {
    $ctx &word.name resolve-var-name match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } [,] @type @var-id
    $ctx $type &word.fields resolve-field-accesses match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @fields
    $fields.len 0 = if {
        &type
    } else {
        &fields $fields.len 1 - Array:get<FieldAccess> .target-type
    } match {
        case Ptr -> { ~ }
        case _ -> { drop $ctx.ctx &word.name "`=>` can only store into ptr types" abort<[Word, bool]> break }
    } @expected-type
    $ctx $stack &word.name $expected-type "TODO" expect1 match {
        case Some -> { make Result<[Word, bool], ResolveError>.Error break }
        case None -> {}
    }
    $word.name $var-id $expected-type ~ $fields make StoreLocal
    make Word.StoreLocal 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn fields-go-through-ptr(fields: .Array<FieldAccess>) -> bool {
    0 @i
    loop {
        $i $fields.len = if {
            // No field access went through a pointer,
            0 1 = break
        }
        $fields $i Array:get<FieldAccess> .source-type match {
            case Ptr -> {
                drop
                // At least one field access goes through a pointer,
                1 1 = break
            }
            case _ -> { drop }
        }
        $i 1 + #i
    }
}

fn resolve-ref-local(ctx: .WordCtx, stack: .Stack, word: .P:RefLocal) -> Result<[Word, bool], ResolveError> { block {
    &ctx.env &word.ident Env:lookup match {
        case None -> {
            $ctx.globals &word.ident Token-lexeme Map:get-bs-with-index<Global> match {
                case None -> { $ctx.ctx &word.ident "var not found" abort<[Word, bool]> break }
                case Some -> {
                    [,] @id @globl
                    &globl.reffed
                    $globl.type
                    $word.ident $ctx.ctx.module-id $id make GlobalId make VarId.Global
                }
            }
        }
        case Some -> {
            @local-id
            &ctx.env &local-id Env:lookup-by-id @local
            &local.reffed $local.type $local-id make VarId.Local
        }
    } @var-id @type @reffed-slot
    $ctx $type &word.fields resolve-field-accesses match {
        case Error -> { make Result<[Word, bool], ResolveError>.Error break }
        case Success -> {}
    } @fields

    &fields fields-go-through-ptr not if {
        // No field access went through a pointer,
        // therefore this local really was reffed.
        1 1 = =>reffed-slot
    }

    $fields.len 0 = if {
        &type
    } else {
        &fields $fields.len 1 - Array:get<FieldAccess> .target-type
    } $ctx.persistent flip Arena:copy<Type> @result-type
    $ctx $stack $result-type make Type.Ptr push
    $word.ident $var-id $fields make RefLocal
    make Word.RefLocal 0 1 = [,2]
    make Result<[Word, bool], ResolveError>.Success
} }

fn resolve-field-accesses(ctx: .WordCtx, type: Type, fields: .Array<Token>) -> Result<Array<FieldAccess>, ResolveError> { block {
    Array:new<FieldAccess> @resolved
    $fields.len 0 = if { $resolved make Result<Array<FieldAccess>, ResolveError>.Success break }
    0 @i
    loop {
        $fields $i Array:get<Token> @field-name
        $type match {
            case Custom -> {
                @custom-type
                $ctx.type-lookup &custom-type.type-definition lookup-type match {
                    case Variant -> {
                        drop $ctx.ctx $field-name "variants do not have fields" abort<Array<FieldAccess>> break
                    }
                    case Struct -> {}
                } $custom-type
            }
            case Ptr -> {
                ~ match {
                    case Custom -> {
                        @custom-type
                        $ctx.type-lookup &custom-type.type-definition lookup-type match {
                            case Variant -> { drop $ctx.ctx $field-name "variants do not have fields" abort<Array<FieldAccess>> break }
                            case Struct -> {}
                        }
                        $custom-type
                    }
                    case _ -> { drop $ctx.ctx $field-name "ooTODO" abort<Array<FieldAccess>> break }
                }
            }
            case _ -> { drop $ctx.ctx $field-name "TODO" abort<Array<FieldAccess>> break }
        }
        @custom-type @struc
        0 @field-index
        loop {
            $field-index $struc.fields.len = if {
                $ctx.ctx $field-name "field not found" abort-m break
            }
            &struc.fields $field-index Array:get<NamedType> @field
            &field.name Token-lexeme $field-name Token-lexeme Bytes:eq if {
                $ctx.persistent &resolved
                $ctx &custom-type.generic-arguments &field.type resolve-generic @target-type
                $field-name ~ $type $target-type $field-index make FieldAccess
                Array:push<FieldAccess>
                $target-type #type
                make Maybe<ResolveError>.None break
            }
            $field-index 1 + #field-index
        } match {
            case Some -> { make Result<Array<FieldAccess>, ResolveError>.Error break }
            case None -> {}
        }
        $i 1 + #i
        $i $fields.len = if { $resolved make Result<Array<FieldAccess>, ResolveError>.Success break }
    }
} }

fn resolve-stack-annotation(ctx: .WordCtx, stack: .Stack, annotation: .P:StackAnnotation) -> Result<[], ResolveError> { block {
    $stack size @stack-size
    $annotation.types.len $stack-size gt if {
        $ctx.ctx &annotation.token "stack annotation doesn't match reality" abort<[]> break
    }
    0 @i
    loop {
        $i $annotation.types.len = if { [,0] make Result<[], ResolveError>.Success break }
        &annotation.types $annotation.types.len $i - 1 - Array:get<P:Type> @expected
        $ctx.ctx $ctx.imports $expected resolve-type match {
            case Error -> { make Result<[], ResolveError>.Error break }
            case Success -> {}
        } @expected
        $stack $i index @actual
        &expected $actual Type-eq not if {
            $ctx.ctx &annotation.token "stack annotation doesn't match reality" abort<[]> break
        }
        $i 1 + #i
    }
} }

fn resolve-generic(ctx: .WordCtx, generics: .Array<Type>, type: .Type) -> Type {
    $type match {
        case Generic -> { .index ~ $generics flip Array:get<Type> ~ }
        case Ptr -> {
            ~ $ctx flip $generics flip resolve-generic $ctx.persistent flip Arena:push<Type> make Type.Ptr
        }
        case Custom -> {
            @type
            $type.type-definition
            $ctx $generics &type.generic-arguments resolve-generic-many
            make CustomTypeType
            make Type.Custom
        }
        case Fun -> {
            @type
            $type.token
            $ctx $generics &type.parameters resolve-generic-many
            $ctx $generics &type.returns resolve-generic-many
            make FunType
            make Type.Fun
        }
        case Tuple -> {
            @tuple
            $tuple.token
            $ctx $generics &tuple.items resolve-generic-many
            make TupleType
            make Type.Tuple
        }
        case Bool -> { make Type.Bool }
        case I8 -> { make Type.I8 }
        case I32 -> { make Type.I32 }
        case I64 -> { make Type.I64 }
    }
}
fn resolve-generic-many(ctx: .WordCtx, generics: .Array<Type>, types: .Array<Type>) -> Array<Type> { block {
    $ctx.persistent $types.len Array:new-with-capacity<Type> @resolved
    0 @i
    loop {
        $i $types.len = if { break }
        &resolved $ctx $generics $types $i Array:get<Type> resolve-generic Array:push-assert-no-alloc<Type>
        $i 1 + #i
    }
    $resolved
} }

fn resolve-imports(ctx: .Ctx) -> Result<Map<ByteSlice, Array<Import>>, ResolveError> {
    $ctx.temp @temp-arena
    $ctx.temp Arena:save @save
    \ByteSlice:eq-by-ref Map:new<ByteSlice, Array<Import>> @resolved-imports
    &ctx.parsed-modules.keys $ctx.module-id.index Array:get<ByteSlice> @module-path
    0 @i
    loop {
        $ctx.top-items.len $i = if { $resolved-imports make Result<Map<ByteSlice, Array<Import>>, ResolveError>.Success break }
        $ctx.top-items $i Array:get<TopItem> match {
            case Import -> {
                @imp
                $module-path ~ ByteSlice:unpack "-" Bytes:eq if {
                    "" ByteArray:init
                } else {
                    $module-path ~ ByteSlice:unpack FS:path-dir ByteArray:init
                } @path
                $temp-arena &path &imp.path Token-lexeme 2 - flip 1 + flip ByteArray:push
                $temp-arena $path ByteArray:unpack FS:normalize make ByteSlice @path
                $ctx.parsed-modules &path Map:get-index<ByteSlice, Array<TopItem>> assert-some<i32> make ModuleId @imported-module-id
                $ctx.persistent $path ByteSlice:copy @path

                $ctx $imported-module-id &imp.items resolve-import-items match {
                    case Error -> { make Result<Map<ByteSlice, Array<Import>>, ResolveError>.Error break }
                    case Success -> {}
                } @items

                &imp.qualifier Token-lexeme make ByteSlice @qualifier
                $imp.start $imported-module-id $path $imp.qualifier $items make Import @imp
                &resolved-imports &qualifier Map:get<ByteSlice, Array<Import>> match {
                    case None -> {
                        $ctx.persistent &resolved-imports
                        $qualifier
                        $ctx.persistent $imp Array:singleton<Import>
                        Map:insert<ByteSlice, Array<Import>> drop
                    }
                    case Some -> { $ctx.persistent flip $imp Array:push<Import> }
                }
            }
            case _ -> { drop }
        }
        $i 1 + #i
    }
    $temp-arena $save Arena:restore
}

fn resolve-import-items(ctx: .Ctx, imported-module-id: ModuleId, items: .Array<Token>) -> Result<Array<ImportItem>, ResolveError> {
    $ctx.persistent $items.len Array:new-with-capacity<ImportItem> @resolved-items
    $ctx.parsed-modules $imported-module-id.index Map:get-value<ByteSlice, Array<TopItem>> @imported-module
    0 @i
    loop {
        $items.len $i = if { $resolved-items make Result<Array<ImportItem>, ResolveError>.Success break }
        $items $i Array:get<Token> @item
        $imported-module $imported-module-id $item lookup-item-in-module match {
            case None -> {
                $ctx $item "not found" abort<Array<ImportItem>> break
            }
            case Some -> {}
        } @item
        &resolved-items $item Array:push-assert-no-alloc<ImportItem>
        $i 1 + #i
    }
}

fn lookup-item-in-module(module: .Array<TopItem>, module-id: ModuleId, name: .Token) -> Maybe<ImportItem> {
    0 @type-index
    0 @function-index
    0 @other
    loop {
        $type-index $function-index + $other + $module.len = if { make Maybe<ImportItem>.None break }
        $module $type-index $function-index + $other + Array:get<TopItem> match {
            case Struct -> {
                .name Token-lexeme $name Token-lexeme Bytes:eq if {
                    $name ~ $module-id $type-index make CustomTypeHandle make ImportItemItem.CustomType make ImportItem make Maybe<ImportItem>.Some break
                }
                $type-index 1 + #type-index
            }
            case Variant -> {
                .name Token-lexeme $name Token-lexeme Bytes:eq if {
                    $name ~ $module-id $type-index make CustomTypeHandle make ImportItemItem.CustomType make ImportItem make Maybe<ImportItem>.Some break
                }
                $type-index 1 + #type-index
            }
            case Function -> {
                .name Token-lexeme $name Token-lexeme Bytes:eq if {
                    $name ~ $module-id $function-index make FunctionHandle make ImportItemItem.Function make ImportItem make Maybe<ImportItem>.Some break
                }
                $function-index 1 + #function-index
            }
            case Extern -> {
                .name Token-lexeme $name Token-lexeme Bytes:eq if {
                    $name ~ $module-id $function-index make FunctionHandle make ImportItemItem.Function make ImportItem make Maybe<ImportItem>.Some break
                }
                $function-index 1 + #function-index
            }
            case _ -> {
                drop $other 1 + #other
            }
        }
    }
}

fn resolve-custom-types(ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>) -> Result<Map<ByteSlice, CustomType>, ResolveError> {
    \ByteSlice:eq-by-ref Map:new<ByteSlice, CustomType> @resolved-custom-types
    0 @i
    loop {
        $ctx.top-items.len $i = if { $resolved-custom-types make Result<Map<ByteSlice, CustomType>, ResolveError>.Success break }
        $ctx.top-items $i Array:get<TopItem> match {
            case Struct -> {
                @struc
                $ctx $imports $struc resolve-struct match {
                    case Error -> { make Result<Map<ByteSlice, CustomType>, ResolveError>.Error break }
                    case Success -> {
                        $ctx.persistent flip
                        &resolved-custom-types flip
                        &struc.name Token-lexeme make ByteSlice flip
                        make CustomType.Struct Map:insert<ByteSlice, CustomType> drop }
                }
            }
            case Variant -> {
                @varant
                $ctx $imports $varant resolve-variant match {
                    case Error -> { make Result<Map<ByteSlice, CustomType>, ResolveError>.Error break }
                    case Success -> {
                        $ctx.persistent flip
                        &resolved-custom-types flip
                        &varant.name Token-lexeme make ByteSlice flip
                        make CustomType.Variant Map:insert<ByteSlice, CustomType> drop
                    }
                }
            }
            case _ -> { drop }
        }
        $i 1 + #i
    }
}

fn resolve-signatures(ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>) -> Result<Array<Signature>, ResolveError> {
    Array:new<Signature> @signatures
    0 @i
    loop (-> Result<Array<Signature>, ResolveError>) {
        $ctx.top-items.len $i = if { $signatures make Result<Array<Signature>, ResolveError>.Success break }
        $ctx.top-items $i Array:get<TopItem> match {
            case Extern -> { .signature make Maybe<.P:Signature>.Some }
            case Function -> { .signature make Maybe<.P:Signature>.Some }
            case _ -> { drop make Maybe<.P:Signature>.None }
        } match {
            case None -> {}
            case Some -> {
                @signature
                $ctx.persistent &signatures
                $ctx $imports $signature resolve-signature match {
                    case Error -> { make Result<Array<Signature>, ResolveError>.Error break }
                    case Success -> {}
                }
                Array:push<Signature>
            }
        }
        $i 1 + #i
    }
}

fn resolve-signature(ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>, signature: .P:Signature) -> Result<Signature, ResolveError> { block (-> Result<Signature, ResolveError>) {
    $signature.generic-parameters
    $ctx $imports &signature.parameters resolve-named-types match {
        case Error -> { make Result<Signature, ResolveError>.Error break }
        case Success -> {}
    }
    $ctx $imports &signature.returns resolve-types match {
        case Error -> { make Result<Signature, ResolveError>.Error break }
        case Success -> {}
    }
    make Signature
    make Result<Signature, ResolveError>.Success
} }

fn resolve-struct(ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>, struc: .P:Struct) -> Result<Struct, ResolveError> { block (-> Result<Struct, ResolveError>) {
    $struc.name $struc.generic-parameters
    $ctx.persistent $struc.fields.len Array:new-with-capacity<NamedType> @fields
    0 @i
    loop (-> Result<Array<NamedType>, ResolveError>) {
        $i $struc.fields.len = if { $fields make Result<Array<NamedType>, ResolveError>.Success break }
        &struc.fields $i Array:get<P:NamedType> @field
        &fields
        $ctx $imports $field resolve-named-type match {
            case Error -> { make Result<Array<NamedType>, ResolveError>.Error break }
            case Success -> {}
        }
        Array:push-assert-no-alloc<NamedType>
        $i 1 + #i
    } match {
        case Error -> { make Result<Struct, ResolveError>.Error break }
        case Success -> {}
    }
    make Struct make Result<Struct, ResolveError>.Success
} }

fn resolve-variant(ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>, varant: .P:Variant) -> Result<Variant, ResolveError> { block (-> Result<Variant, ResolveError>) {
    $varant.name $varant.generic-parameters
    $ctx.persistent $varant.cases.len Array:new-with-capacity<VariantCase> @cases
    0 @i
    loop (-> Result<Array<VariantCase>, ResolveError>) {
        $i $varant.cases.len = if { $cases make Result<Array<VariantCase>, ResolveError>.Success break }
        &varant.cases $i Array:get<P:VariantCase> @cays
        &cases
        $cays.name &cays.type match {
            case None -> { make Maybe<Type>.None }
            case Some -> { $ctx flip $imports flip resolve-type match {
                case Error -> { make Result<Array<VariantCase>, ResolveError>.Error break }
                case Success -> { make Maybe<Type>.Some }
            } }
        }
        make VariantCase
        Array:push-assert-no-alloc<VariantCase>
        $i 1 + #i
    } match {
        case Error -> { make Result<Variant, ResolveError>.Error break }
        case Success -> {}
    }
    make Variant make Result<Variant, ResolveError>.Success
} }

fn resolve-named-type(ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>, type: .P:NamedType) -> Result<NamedType, ResolveError> {
    $type.name
    $ctx $imports &type.type resolve-type match {
        case Error -> { flip drop make Result<NamedType, ResolveError>.Error }
        case Success -> { make NamedType make Result<NamedType, ResolveError>.Success }
    }
}
fn resolve-named-types(ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>, named-types: .Array<P:NamedType>) -> Result<Array<NamedType>, ResolveError> { block {
    $ctx.persistent $named-types.len Array:new-with-capacity<NamedType> @resolved-named-types
    0 @i
    loop {
        $i $named-types.len = if { $resolved-named-types make Result<Array<NamedType>, ResolveError>.Success break }
        $ctx $imports $named-types $i Array:get<P:NamedType> resolve-named-type match {
            case Error -> { make Result<Array<NamedType>, ResolveError>.Error break }
            case Success -> { &resolved-named-types flip Array:push-assert-no-alloc<NamedType> }
        }
        $i 1 + #i
    }
} }

fn resolve-type(ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>, type: .P:Type) -> Result<Type, ResolveError> { block (-> Result<Type, ResolveError>) {
    $type match {
        case Bool -> { drop make Type.Bool }
        case I8 -> { drop make Type.I8 }
        case I32 -> { drop make Type.I32 }
        case I64 -> { drop make Type.I64 }
        case Generic -> { ~ make Type.Generic }
        case Ptr -> {
            .type ~ $ctx flip $imports flip resolve-type match {
                case Error -> { make Result<Type, ResolveError>.Error break }
                case Success -> { $ctx.persistent flip Arena:push<Type> make Type.Ptr }
            }
        }
        case Custom -> { $ctx flip $imports flip resolve-custom-type match {
                case Error -> { make Result<Type, ResolveError>.Error break }
                case Success -> { make Type.Custom }
        } }
        case Fun -> {
            @fun
            $fun.token
            $ctx $imports &fun.parameters resolve-types match {
                case Error -> { make Result<Type, ResolveError>.Error break }
                case Success -> {}
            }
            $ctx $imports &fun.returns resolve-types match {
                case Error -> { make Result<Type, ResolveError>.Error break }
                case Success -> {}
            }
            make FunType
            make Type.Fun
        }
        case Tuple -> {
            @tuple
            $tuple.token
            $ctx $imports &tuple.items resolve-types match {
                case Error -> { make Result<Type, ResolveError>.Error break }
                case Success -> {}
            }
            make TupleType
            make Type.Tuple
        }
    } make Result<Type, ResolveError>.Success
} }

fn resolve-custom-type(ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>, custom-type: .P:CustomType) -> Result<CustomTypeType, ResolveError> { block {
    $custom-type match {
        case Local -> {
            @type
            $ctx $imports &type.generic-arguments resolve-types match {
                case Error -> { make Result<CustomTypeType, ResolveError>.Error break }
                case Success -> {}
            } @generic-arguments
            0 @i
            0 @type-index
            loop {
                $ctx.top-items.len $i = if {
                    0 @i
                    loop {
                        $imports.values.len $i = if { $ctx &type.name "not found" abort<CustomTypeType> break }
                        $imports $i Map:get-value<ByteSlice, Array<Import>> @imports
                        0 @j
                        loop {
                            $j $imports.len = if { make Maybe<CustomTypeType>.None make Result<Maybe<CustomTypeType>, ResolveError>.Success break }
                            $imports $j Array:get<Import> @imp
                            0 @k
                            loop {
                                $k $imp.items.len = if {
                                    make Maybe<CustomTypeType>.None make Result<Maybe<CustomTypeType>, ResolveError>.Success break
                                }
                                &imp.items $k Array:get<ImportItem> @item
                                &item.name Token-lexeme &type.name Token-lexeme Bytes:eq if {
                                    &item.handle match {
                                        case CustomType -> {
                                            @custom-type
                                            $ctx.resolved-modules $custom-type.module.index Array:get<Module>
                                            .custom-types.values $custom-type.index Array:get<CustomType>
                                            CustomType-generic-parameters .len ~ @actual-num-generic-args
                                            $generic-arguments.len $actual-num-generic-args /= if {
                                                $ctx &type.name $actual-num-generic-args $generic-arguments.len
                                                generic-arguments-mismatch-error
                                                make Result<Maybe<CustomTypeType>, ResolveError>.Error break
                                            }
                                            $custom-type ~ $generic-arguments make CustomTypeType
                                            make Maybe<CustomTypeType>.Some
                                            make Result<Maybe<CustomTypeType>, ResolveError>.Success break
                                        }
                                        case _ -> { drop }
                                    }
                                }
                                $k 1 + #k
                            } match {
                                case Success -> { match {
                                    case None -> {}
                                    case _ -> { make Result<Maybe<CustomTypeType>, ResolveError>.Success break }
                                } }
                                case Error -> { make Result<Maybe<CustomTypeType>, ResolveError>.Error break }
                            }
                            $j 1 + #j
                        } match {
                            case Success -> { match {
                                case None -> {}
                                case Some -> { make Result<CustomTypeType, ResolveError>.Success break }
                            } }
                            case Error -> { make Result<CustomTypeType, ResolveError>.Error break }
                        }
                        $i 1 + #i
                    } break
                }
                $ctx.top-items $i Array:get<TopItem>
                match {
                    case Struct -> {
                        @struc
                        &struc.name Token-lexeme &type.name Token-lexeme Bytes:eq if {
                            $struc.generic-parameters.len $generic-arguments.len /= if {
                                $ctx &type.name $struc.generic-parameters.len $generic-arguments.len
                                generic-arguments-mismatch-error
                                make Result<CustomTypeType, ResolveError>.Error break
                            }
                            $ctx.module-id $type-index make CustomTypeHandle
                            $generic-arguments
                            make CustomTypeType
                            make Result<CustomTypeType, ResolveError>.Success break
                        }
                        $type-index 1 + #type-index
                    }
                    case Variant -> {
                        @varint
                        &varint.name Token-lexeme &type.name Token-lexeme Bytes:eq if {
                            $varint.generic-parameters.len $generic-arguments.len /= if {
                                $ctx &type.name $varint.generic-parameters.len $generic-arguments.len
                                generic-arguments-mismatch-error
                                make Result<CustomTypeType, ResolveError>.Error break
                            }
                            $ctx.module-id $type-index make CustomTypeHandle
                            $generic-arguments
                            make CustomTypeType
                            make Result<CustomTypeType, ResolveError>.Success break
                        }
                        $type-index 1 + #type-index
                    }
                    case _ -> { drop }
                }
                $i 1 + #i
            }
        }
        case Foreign -> {
            @type
            $ctx $imports &type.generic-arguments resolve-types match {
                case Error -> { make Result<CustomTypeType, ResolveError>.Error break }
                case Success -> {}
            } @generic-arguments
            &type.module Token-lexeme make ByteSlice @module-lexeme
            $imports &module-lexeme Map:get<ByteSlice, Array<Import>> match {
                case None -> {
                    $ctx &type.module "not found" abort<CustomTypeType> break
                }
                case Some -> {
                    @imports
                    0 @i
                    loop {
                        $i $imports.len = if { $ctx &type.name "not found" abort<CustomTypeType> break }
                        $imports $i Array:get<Import> @imp
                        $ctx.resolved-modules $imp.module.index Array:get<Module> @module
                        0 @j
                        loop {
                            $j $module.custom-types.keys.len = if {
                                make Maybe<CustomTypeType>.None make Result<Maybe<CustomTypeType>, ResolveError>.Success break
                            }
                            &module.custom-types $j Map:get-value<ByteSlice, CustomType> @custom-type
                            $custom-type CustomType-name Token-lexeme &type.name Token-lexeme Bytes:eq if {
                                $custom-type CustomType-generic-parameters .len ~ @actual-num-generic-args
                                $generic-arguments.len $actual-num-generic-args /= if {
                                    $ctx &type.name $actual-num-generic-args $generic-arguments.len
                                    generic-arguments-mismatch-error
                                    make Result<Maybe<CustomTypeType>, ResolveError>.Error break
                                }
                                $imp.module $j make CustomTypeHandle
                                $generic-arguments
                                make CustomTypeType
                                make Maybe<CustomTypeType>.Some
                                make Result<Maybe<CustomTypeType>, ResolveError>.Success break
                            }
                            $j 1 + #j
                        } match {
                            case Error -> { make Result<CustomTypeType, ResolveError>.Error break }
                            case Success -> { match {
                                case Some -> { make Result<CustomTypeType, ResolveError>.Success break }
                                case None -> {}
                            } }
                        }
                        $i 1 + #i
                    }
                }
            }
        }
    }
} }

fn generic-arguments-mismatch-error(ctx: .Ctx, token: .Token, expected: i32, actual: i32) -> ResolveError {
    $ctx.temp Fmt:into-new-string @msg @fmt
    &fmt "expected " Fmt:write
    &fmt $expected i32-format
    &fmt " generic arguments, not " Fmt:write
    &fmt $actual i32-format
    $ctx $token $msg ~ ByteArray:unpack error
}

fn resolve-types(ctx: .Ctx, imports: .Map<ByteSlice, Array<Import>>, types: .Array<P:Type>) -> Result<Array<Type>, ResolveError> { block {
    $ctx.persistent $types.len Array:new-with-capacity<Type> @resolved-types
    0 @i
    loop {
        $i $types.len = if { $resolved-types make Result<Array<Type>, ResolveError>.Success break }
        $ctx $imports $types $i Array:get<P:Type> resolve-type match {
            case Error -> { make Result<Array<Type>, ResolveError>.Error break }
            case Success -> { &resolved-types flip Array:push-assert-no-alloc<Type> }
        }
        $i 1 + #i
    }
} }

