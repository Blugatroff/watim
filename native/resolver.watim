import "../std/io.watim" as IO
import "../std/string.watim" as S
import "../std/str.watim" as STR
import "../std/alloc.watim" as A

import "./ast.watim" as AST
import "./module.watim" as M
import "./lexer.watim" as L
import "./parser.watim" as P
import "./util.watim" as U

fn resolve(modules: .M:Modules) {
    local i: i32
    loop {
        $i $modules M:Modules-len = if { break }
        $modules $modules $i M:Modules-get-value resolve-module
        $i 1 + #i
    }
}
fn resolve-module(modules: .M:Modules, module: .M:Module) {
    local i: i32
    local items: .AST:TopItems
    local item: .AST:TopItem

    $module M:Module-items #items
    loop {
        $i $items AST:TopItems-len = if { break }
        $items $i AST:TopItems-get #item
        $item AST:TopItem-ty AST:TOP_ITEM_STRUCT = if {
            $modules $module $item AST:TopItem-struc resolve-struc
        }
        $item AST:TopItem-ty AST:TOP_ITEM_FN = if {
            $modules $module $item AST:TopItem-function resolve-function
        }
        $item AST:TopItem-ty AST:TOP_ITEM_EXT = if {
            $modules $module $item AST:TopItem-ext resolve-extern
        }
        $item AST:TopItem-ty AST:TOP_ITEM_MEM = if {
            $modules $module $item.mem resolve-memory
        }
        $i 1 + #i
    }
}
fn resolve-extern(modules: .M:Modules, module: .M:Module, ext: .AST:Extern) {
    $modules $module 0 !.AST:Generics $ext AST:Extern-parameters resolve-parameters
    $modules $module 0 !.AST:Generics $ext AST:Extern-rets resolve-types
}
fn resolve-struc(modules: .M:Modules, module: .M:Module, struc: .AST:Struct) {
    local fields: .AST:Fields
    local field: .AST:Field
    local type: .AST:Type
    local i: i32
    $struc AST:Struct-fields #fields
    loop {
        $i $fields AST:Fields-len = if { break }
        $fields $i AST:Fields-get #field
        $field AST:Field-type #type

        $modules $module &struc.generics $field resolve-field
        $i 1 + #i
    }
}
fn resolve-function(modules: .M:Modules, module: .M:Module, function: .AST:Function) {
    $modules $module &function.generics $function AST:Function-rets resolve-types
    $modules $module &function.generics $function AST:Function-locals resolve-locals
    $modules $module &function.generics $function AST:Function-body resolve-words
    $function AST:Function-gather-generics-types
}
fn resolve-words(modules: .M:Modules, module: .M:Module, generics: .AST:Generics, words: .AST:Words) {
    local i: i32
    loop {
        $i $words AST:Words-len = if { break }
        $modules $module $generics $words $i AST:Words-get resolve-word
        $i 1 + #i
    }
}
fn resolve-word(modules: .M:Modules, module: .M:Module, generics: .AST:Generics, word: .AST:Word) {
    $word AST:Word-ty AST:WORD_CAST = if {
        $modules $module $generics &word.type resolve-type
    }
    $word AST:Word-ty AST:WORD_IF = if {
        $modules $module $generics $word AST:Word-iff resolve-iff
    }
    $word AST:Word-ty AST:WORD_LOOP = if {
        $modules $module $generics $word.lop.body resolve-words
    }
    $word AST:Word-ty AST:WORD_BLOCK = if {
        $modules $module $generics $word.blok.body resolve-words
    }
    $word AST:Word-ty AST:WORD_CALL = if {
        $modules $module $generics $word resolve-call
    }
    $word AST:Word-ty AST:WORD_SIZEOF = if {
        $modules $module $generics &word.type resolve-type
    }
}
fn resolve-call(modules: .M:Modules, module: .M:Module, generics: .AST:Generics, word: .AST:Word) { block {
    // FIXME: this causes a segfault: 
    // $word.generics 0 !.AST:Types = if {
    $word.generics !i32 0 = if {
        break
    }
    0 @i
    loop {
        $word.generics AST:Types-len $i = if { break }
        $modules $module $generics $word.generics $i AST:Types-get-ref resolve-type
        $i 1 + #i
    }
} }
fn resolve-iff(modules: .M:Modules, module: .M:Module, generics: .AST:Generics, iff: .AST:If) {
    $modules $module $generics $iff AST:If-body resolve-words
    $iff.has-el if { 
        $modules $module $generics $iff AST:If-el resolve-words
    }
}
fn resolve-field(modules: .M:Modules, module: .M:Module, generics: .AST:Generics, field: .AST:Field) {
    $modules $module $generics &field.type resolve-type
}
fn resolve-types(modules: .M:Modules, module: .M:Module, generics: .AST:Generics, types: .AST:Types) {
    local i: i32
    loop {
        $i $types AST:Types-len = if { break }
        $modules $module $generics $types $i AST:Types-get-ref resolve-type
        $i 1 + #i
    }
}
fn resolve-memory(modules: .M:Modules, module: .M:Module, mem: .AST:Local) {
    $modules $module 0 !.AST:Generics &mem.type resolve-type
}
fn resolve-locals(modules: .M:Modules, module: .M:Module, generics: .AST:Generics, locals: .AST:Locals) {
    local i: i32
    loop {
        $i $locals AST:Locals-len = if { break }
        $modules $module $generics $locals $i AST:Locals-get resolve-local
        $i 1 + #i
    }
}
fn resolve-local(modules: .M:Modules, module: .M:Module, generics: .AST:Generics, locl: .AST:Local) {
    $modules $module $generics &locl.type resolve-type
}
fn resolve-parameters(modules: .M:Modules, module: .M:Module, generics: .AST:Generics, parameters: .AST:Locals) {
    local i: i32
    loop {
        $parameters AST:Locals-len $i = if { break }
        $modules $module $generics $parameters $i AST:Locals-get resolve-parameter
        $i 1 + #i
    }
}
fn resolve-parameter(modules: .M:Modules, module: .M:Module, generics: .AST:Generics, parameter: .AST:Local) {
    $modules $module $generics &parameter.type resolve-type
}
fn resolve-type(modules: .M:Modules, module: .M:Module, generics: .AST:Generics, type: ..AST:Type) {
    local path: .S:String
    block {
        $type ~ AST:Type-ty AST:TYPE_STRUCT = if {
            $type ~ AST:Type-ident L:Token-lexeme @ident

            0 $generics !i32 /= if {
                $generics $ident AST:Generics-contains if {
                    $type ~ .generic flip store
                    AST:TYPE_GENERIC $type ~ .ty flip store
                    break
                } else { drop }
            } else {
                // 0 0 / drop
            }

            $type ~ AST:Type-module @module-token
            
            $module-token !i32 0 /= if {
                $module M:Module-imports @imports
                $imports $module-token L:Token-lexeme ~ STR:Str-unpack AST:Imports-get if {
                    #path
                } else {
                    drop
                    $module-token L:Token-location "module not found" U:abort-with-location
                }
            } else {
                $module M:Module-path #path
            }

            $modules $path S:String-unpack $ident ~ STR:Str-unpack M:Modules-find-struc if {
                $type ~ flip AST:Type-set-struc
            } else {
                drop $type ~ AST:Type-ident L:Token-location "struct not found" U:abort-with-location
            }

            0 @i
            loop {
                $type ~ .generics ~ AST:Types-len $i = if { break }
                $modules $module $generics $type ~ .generics ~ $i AST:Types-get-ref resolve-type
                $i 1 + #i
            }
            $type ~ $type ~ .generics ~ $module AST:Type-apply-generics drop =>type
            break
        }
        $type ~ AST:Type-ty AST:TYPE_PTR = if {
            $modules $module $generics $type ~ .child resolve-type
        }
        $type ~ AST:Type-ty AST:TYPE_FUNCTION = if {
            $modules $module $generics $type ~ .function.args ~ resolve-types
            $modules $module $generics $type ~ .function.rets ~ resolve-types
        }
    }
}

