import "../../std/fmt.watim" as Fmt (Formatter)
import "../../std/array.watim" as Array (Array)

import "../lexer.watim" as Lexer (Token-lexeme)
import "../parser.watim" as Parser

import "../resolving/module.watim" as Resolved
import "../resolving/top-items.watim" as Resolved
import "../resolving/type.watim" as Type (Type, FunType, CustomTypeType, TupleType)

fn pretty(fmt: .Formatter, modules: .Array<Resolved:Module>, self: .Type) { block {
    $fmt $self match {
        case Type.Bool -> { "bool" }
        case Type.I8 -> { "i8" }
        case Type.I32 -> { "i32" }
        case Type.I64 -> { "i64" }
        case Type.Ptr -> { $fmt "." Fmt:write ~ $modules flip pretty break }
        case Type.Custom -> { $modules flip CustomTypeType-pretty break }
        case Type.Fun -> { $modules flip FunType-pretty break }
        case Type.Tuple -> { $modules flip TupleType-pretty break }
        case Type.Generic -> { Parser:GenericType-pretty break }
        case Type.Hole -> { drop "_" }
    } Fmt:write
} }

fn FunType-pretty(fmt: .Formatter, modules: .Array<Resolved:Module>, self: .FunType) {
    $fmt "(" Fmt:write
    $fmt $modules &self.parameters Types-pretty
    $fmt " -> " Fmt:write
    $fmt $modules &self.returns Types-pretty
    $fmt ")" Fmt:write
}

fn Types-pretty(fmt: .Formatter, modules: .Array<Resolved:Module>, self: .Array<Type>) {
    0 @i
    loop {
        $i $self.len = if { break }
        $fmt $modules $self $i Array:get<Type> pretty
        $i 1 + #i
        $i $self.len = if { break }
        $fmt ", " Fmt:write
    }
}
fn Types-pretty-bracketed(fmt: .Formatter, modules: .Array<Resolved:Module>, self: .Array<Type>) {
    $fmt "[" Fmt:write
    $fmt $modules $self Types-pretty
    $fmt "]" Fmt:write
}

fn TupleType-pretty(fmt: .Formatter, modules: .Array<Resolved:Module>, self: .TupleType) {
    $fmt $modules &self.items Types-pretty-bracketed
}

fn CustomTypeType-pretty(fmt: .Formatter, modules: .Array<Resolved:Module>, self: .CustomTypeType) {
    $fmt $modules $self.type-definition.module.index Array:get<_> .type-definitions.values $self.type-definition.index Array:get<_> match {
        case Resolved:TypeDefinition.Struct  -> { .name }
        case Resolved:TypeDefinition.Variant -> { .name }
    } Token-lexeme Fmt:write
    0 @i
    loop {
        $i $self.generic-arguments.len = if { break }
        $i 0 = if { $fmt "<" Fmt:write }
        $fmt $modules &self.generic-arguments $i Array:get<Type> pretty
        $i 1 + #i
        $i $self.generic-arguments.len /= if {
            $fmt ", " Fmt:write
        } else {
            $fmt ">" Fmt:write
        }
    }
}
