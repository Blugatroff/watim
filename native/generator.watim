import "../std/core.watim" as Core (align-to)
import "../std/bytes.watim" as Bytes
import "../std/maybe.watim" as Maybe (Maybe, is-some)
import "../std/arena.watim" as Arena (Arena)
import "../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../std/byte-array.watim" as ByteArray (ByteArray)
import "../std/array.watim" as Array (Array)
import "../std/list.watim" as List (List)
import "../std/map.watim" as Map (Map)
import "../std/fmt.watim" as Fmt (Formatter, ByteSlice-format)
import "../std/util.watim" as Util (i32-format, bool-format)

import "./lexer.watim" as Lexer (Token, Token-lexeme, Token-format)
import "./type.watim" as Type (CustomTypeHandle)
import "./env.watim" as Env (LocalId, LocalId-eq)
import "./resolver.watim" as Resolver (GlobalId, VarId)
import "./monomizer.watim" as Monomized (
    Monomized, Module, ExternOrInstances,
    Extern, Function, FunctionHandle, Signature, Local, Global,
    Type, Key, Key-type, NamedTypeId, TypeId, TypeId-format,
    CustomType, CustomType-name, FunType,
    Variant, VariantCase, Struct,
    Word, Intrinsic, FieldAccess, MatchCase,
    I32-id, I64-id, type-size, field-offset, can-live-in-reg
)

struct Ctx {
    fmt: .Formatter
    program: .Monomized
    module-data-offsets: Array<i32>
    flip-i32-i32-used: bool
    flip-i32-i64-used: bool
    flip-i64-i32-used: bool
    flip-i64-i64-used: bool
    pack-i32s-used: bool
    unpack-i32s-used: bool
    dup-i64-used: bool
}

fn generate(fmt: .Formatter, program: .Monomized) {
    $fmt "(module\n" Fmt:write
    $fmt Fmt:indent


    0 !.Arena Arena:temp @arena @arena-save

    $arena $program.modules.values.len Arena:alloc-many<i32> $program.modules.values.len
    Array:init-no-copy<i32> @static-data-offsets

    ByteArray:new @all-static-data
    0 @i
    loop {
        $program.modules.values.len $i = if { break }
        &program.modules.values $i Array:get<Monomized:Module> @module
        &static-data-offsets $i $all-static-data.len Array:set<i32> drop
        $arena &all-static-data $module.static-data ByteSlice:unpack ByteArray:push
        $i 1 + #i
    }

    $fmt $program $static-data-offsets 0 1 = 0 1 = 0 1 = 0 1 = 0 1 = 0 1 = 0 1 = make Ctx @ctx

    0 @i
    loop {
        $program.modules.values.len $i = if { break }
        &program.modules.values $i Array:get<Monomized:Module> @module
        0 @j
        loop {
            $j $module.functions.len = if { break }
            &module.functions $j Array:get<ExternOrInstances> match {
                case Extern -> { &ctx flip $i generate-extrn }
                case Instances -> { drop }
            }
            $j 1 + #j
        }
        $i 1 + #i
    }

    $fmt Fmt:write-indent $fmt "(memory 1 65536)\n" Fmt:write
    $fmt Fmt:write-indent $fmt "(export \"memory\" (memory 0))\n" Fmt:write

    &ctx generate-function-table
    &ctx $all-static-data.len 4 align-to generate-globals 4 align-to @stack-start

    $fmt Fmt:write-indent
    $fmt "(global $stac:k (mut i32) (i32.const " Fmt:write
    $fmt $stack-start i32-format
    $fmt "))\n" Fmt:write

    $fmt &all-static-data ByteArray:to-slice generate-data

    &ctx generate-functions

    &ctx generate-intrinsic-functions

    $fmt Fmt:dedent
    $fmt ")" Fmt:write
    $arena $arena-save Arena:restore
}

variant FunctionOrExtern {
    case Extern -> .Extern
    case Function -> .Function
}
fn FunctionOrExtern-name(self: .FunctionOrExtern) -> .Token {
    $self match {
        case Extern -> { ~ .name }
        case Function -> { ~ .name }
    }
}

fn lookup-function(program: .Monomized, handle: .FunctionHandle) -> FunctionOrExtern {
    &program.modules.values $handle.module.index Array:get<Module> @module
    &module.functions $handle.index Array:get<ExternOrInstances> match {
        case Extern -> { make FunctionOrExtern.Extern }
        case Instances -> { $handle.instance Array:get<.Function> ~ make FunctionOrExtern.Function }
    }
}

fn lookup-globl(program: .Monomized, id: .GlobalId) -> .Global {
    &program.modules.values $id.module.index Array:get<Module> .globals $id.index Array:get<Global>
}

fn lookup-type(program: .Monomized, type: TypeId) -> .Type {
    &program.types $type.index Array:get<Maybe<Key>> match {
        case None -> { Core:unreachable<.Type> }
        case Some -> { Key-type }
    }
}

fn lookup-custom-type(program: .Monomized, handle: .CustomTypeHandle) -> .CustomType {
    &program.modules.values $handle.module.index Array:get<Module> .custom-types
    $handle.index Array:get<CustomType>
}

fn generate-extrn(ctx: .Ctx, extrn: .Extern, module-id: i32) {
    $ctx.fmt Fmt:write-indent
    $ctx.fmt "(import " Fmt:write
    $ctx.fmt &extrn.extrn-module ByteSlice-format
    $ctx.fmt " " Fmt:write
    $ctx.fmt &extrn.extrn-name ByteSlice-format
    $ctx.fmt " (" Fmt:write
    make Maybe<Token>.None @export
    \LocalId-eq Map:new<LocalId, Local> @empty-locals
    $ctx &extrn.signature &export $module-id &extrn.name 0 &empty-locals generate-signature
    $ctx.fmt "))\n" Fmt:write
}

fn generate-data(fmt: .Formatter, data: ByteSlice) {
    $fmt Fmt:write-indent
    $fmt "(data (i32.const 0) " Fmt:write
    $fmt &data Fmt:ByteSlice-format
    $fmt ")\n" Fmt:write
}

fn generate-globals(ctx: .Ctx, static-data-len: i32) -> i32 {
    $static-data-len @offset
    0 @i
    loop {
        $i $ctx.program.modules.values.len = if { $offset break }
        &ctx.program.modules.values $i Array:get<Module> @module

        0 @j
        loop {
            $j $module.globals.len = if { break }
            &module.globals $j Array:get<Global> @globl
            $j 1 + #j
            &ctx.program.sizes $globl.type type-size @size
            $globl.reffed &ctx.program.sizes $globl.type can-live-in-reg not or @lives-in-memory
            $lives-in-memory if { $offset } else { 0 } @initial-value

            $ctx.fmt Fmt:write-indent
            $ctx.fmt "(global $" Fmt:write
            $ctx.fmt &globl.name Token-lexeme Fmt:write
            $ctx.fmt ":" Fmt:write
            $ctx.fmt $i i32-format
            // TODO: only use `mut` when the global is stored directly instead of in memory.
            $ctx.fmt " (mut " Fmt:write
            $ctx $globl.type generate-type
            $ctx.fmt ") (" Fmt:write
            $ctx $globl.type generate-type
            $ctx.fmt ".const " Fmt:write
            $ctx.fmt $initial-value i32-format
            $ctx.fmt "))\n" Fmt:write

            $lives-in-memory if {
                $offset $size + #offset
            }
        }
        $i 1 + #i
    }
}

fn generate-function-table(ctx: .Ctx) { block {
    $ctx.fmt Fmt:write-indent
    $ctx.program.function-table.len 0 = if {
        $ctx.fmt "(table funcref (elem))\n" Fmt:write
        break
    }
    $ctx.fmt "(table funcref (elem $intrinsic:flip\n" Fmt:write

    $ctx.fmt Fmt:indent
    $ctx.fmt Fmt:write-indent

    0 @i
    loop {
        $ctx.program.function-table.len $i = if { break }
        &ctx.program.function-table $i Array:get<FunctionHandle> @handle
        $i 1 + #i

        $ctx.program $handle lookup-function @function
        $ctx.fmt "$" Fmt:write
        $ctx.fmt $handle.module.index i32-format
        $ctx.fmt ":" Fmt:write
        $ctx.fmt &function FunctionOrExtern-name Token-lexeme Fmt:write
        $handle.instance 0 /= if {
            $ctx.fmt ":" Fmt:write
            $ctx.fmt $handle.instance i32-format
        }
        $i $ctx.program.function-table.len /= if {
            $ctx.fmt " " Fmt:write
        }
    }
    $ctx.fmt Fmt:dedent
    $ctx.fmt "))\n" Fmt:write
} }

fn generate-intrinsic-functions(ctx: .Ctx) {
    $ctx.fmt Fmt:write-indent
    $ctx.fmt "(func $intrinsic:flip (param $a i32) (param $b i32) (result i32 i32) local.get $b local.get $a)\n" Fmt:write
    $ctx.flip-i32-i64-used if {
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "(func $intrinsic:flip-i32-i64 (param $a i32) (param $b i64) (result i64 i32) local.get $b local.get $a)\n" Fmt:write
    }
    $ctx.flip-i64-i32-used if {
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "(func $intrinsic:flip-i64-i32 (param $a i64) (param $b i32) (result i32 i64) local.get $b local.get $a)\n" Fmt:write
    }
    $ctx.flip-i64-i64-used if {
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "(func $intrinsic:flip-i64-i64 (param $a i64) (param $b i64) (result i64 i64) local.get $b local.get $a)\n" Fmt:write
    }
    $ctx.fmt Fmt:write-indent
    $ctx.fmt "(func $intrinsic:dupi32 (param $a i32) (result i32 i32) local.get $a local.get $a)\n" Fmt:write
    $ctx.dup-i64-used if {
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "(func $intrinsic:dupi64 (param $a i64) (result i64 i64) local.get $a local.get $a)\n" Fmt:write
    }
    $ctx.fmt Fmt:write-indent
    $ctx.fmt "(func $intrinsic:rotate-left (param $a i32) (param $b i32) (param $c i32) (result i32 i32 i32) local.get $b local.get $c local.get $a)\n" Fmt:write
    $ctx.pack-i32s-used if {
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "(func $intrinsic:pack-i32s (param $a i32) (param $b i32) (result i64) " Fmt:write
        $ctx.fmt "local.get $a i64.extend_i32_u " Fmt:write
        $ctx.fmt "local.get $b i64.extend_i32_u i64.const 32 i64.shl i64.or" Fmt:write
        $ctx.fmt ")\n" Fmt:write
    }
    $ctx.unpack-i32s-used if {
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "(func $intrinsic:unpack-i32s (param $a i64) (result i32) (result i32) " Fmt:write
        $ctx.fmt "local.get $a i32.wrap_i64 local.get $a i64.const 32 i64.shr_u i32.wrap_i64" Fmt:write
        $ctx.fmt ")\n" Fmt:write
    }
}

fn generate-functions(ctx: .Ctx) {
    0 @module-id
    loop {
        $module-id $ctx.program.modules.values.len = if { break }
        &ctx.program.modules.values $module-id Array:get<Module> @module

        0 @function-id
        loop {
            $function-id $module.functions.len = if { break }
            &module.functions $function-id Array:get<ExternOrInstances> match {
                case Extern -> { drop }
                case Instances -> {
                    @instances

                    0 @instance-id
                    loop {
                        $instance-id $instances.len = if { break }
                        $instances $instance-id Array:get<.Function> ~ @function
                        $ctx $function $module-id $instance-id generate-function
                        $instance-id 1 + #instance-id
                    }
                }
            }

            $function-id 1 + #function-id
        }

        $module-id 1 + #module-id
    }
}

fn globl-lives-in-memory(ctx: .Ctx, globl: .Global) -> bool {
    &ctx.program.sizes $globl.type can-live-in-reg not
    $globl.reffed or
}

fn local-lives-in-memory(ctx: .Ctx, local: .Local) -> bool {
    &ctx.program.sizes $local.type can-live-in-reg not
    $local.reffed or
}

fn var-lives-in-memory(ctx: .Ctx, locals: .Map<LocalId, Local>, var: .VarId) -> bool {
    $ctx $var match {
        case Local -> {
            $locals flip Map:get<LocalId, Local> Maybe:assert-some<.Local> local-lives-in-memory
        }
        case Global -> {
            $ctx.program flip lookup-globl globl-lives-in-memory
        }
    }
}

fn any-local-lives-in-memory(ctx: .Ctx, locals: .Map<LocalId, Local>) -> bool {
    0 @i
    loop {
        $i $locals.values.len = if { 0 1 = break }
        $ctx &locals.values $i Array:get<Local> local-lives-in-memory if {
            1 1 = break
        }
        $i 1 + #i
    }
}

fn generate-function(
    ctx: .Ctx,
    function: .Function,
    module: i32,
    instance: i32
) {
    $ctx.fmt Fmt:write-indent
    $ctx.fmt "(" Fmt:write
    $ctx &function.signature &function.export $module &function.name $instance &function.locals generate-signature
    $function.generic-arguments.len 0 /= if {
        $ctx.fmt " ;;" Fmt:write
        0 @i
        loop {
            $i $function.generic-arguments.len = if { break }
            $ctx.fmt " " Fmt:write
            $ctx
            &function.generic-arguments $i Array:get<TypeId> ~
            generate-type-pretty
            $i 1 + #i
        }
    }
    $ctx.fmt "\n" Fmt:write
    $ctx.fmt Fmt:indent
    $ctx &function.locals generate-locals

    0 @i
    loop {
        $i $function.max-stack-returns = if { break }
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "(local $s" Fmt:write
        $ctx.fmt $i i32-format
        $ctx.fmt ":a i32)\n" Fmt:write
        $i 1 + #i
    }

    $function.local-copy-space 0 /= if {
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "(local $locl-copy-spac:e i32)\n" Fmt:write
    }

    $function.local-copy-space 0 /=
    $ctx &function.locals any-local-lives-in-memory or @uses-stack
    $uses-stack if {
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "(local $stac:k i32)\n" Fmt:write
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "global.get $stac:k local.set $stac:k\n" Fmt:write
    }

    $function.local-copy-space 0 /= if {
        $ctx "locl-copy-spac:e" $function.local-copy-space 0 0 generate-memory-slot
    }

    $ctx &function.locals generate-memory-slots-for-locals

    $ctx $module &function.locals &function.words generate-words

    $uses-stack if {
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "local.get $stac:k global.set $stac:k\n" Fmt:write
    }

    $ctx.fmt Fmt:dedent
    $ctx.fmt Fmt:write-indent
    $ctx.fmt ")\n" Fmt:write
}

fn generate-memory-slots-for-locals(ctx: .Ctx, locals: .Map<LocalId, Local>) {
    0 @i
    loop {
        $i $locals.values.len = if { break }
        &locals.values $i Array:get<Local> @local

        $ctx $local local-lives-in-memory @lives-in-memory
        &ctx.program.sizes $local.type can-live-in-reg @can-live-in-reg

        $local.is-parameter $lives-in-memory and $can-live-in-reg and if {
            // This parameter must be put on the stack, because it is reffed
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "global.get $stac:k global.get $stac:k local.get $" Fmt:write
            $ctx $local parameter-can-be-abused-ref not if {
                $ctx.fmt "v:" Fmt:write
            }
            $ctx.fmt &local.name Token-lexeme Fmt:write
            $ctx.fmt " " Fmt:write
            $ctx $local.type generate-type
            $ctx.fmt ".store local.tee $" Fmt:write
            $ctx.fmt &local.name Token-lexeme Fmt:write
            $ctx.fmt " i32.const " Fmt:write
            $ctx.fmt &ctx.program.sizes $local.type type-size i32-format
            $ctx.fmt " i32.add global.set $stac:k\n" Fmt:write
        }

        $local.is-parameter not $lives-in-memory and if {
            &locals.keys $i Array:get<LocalId> @local-id

            $ctx
            &local.name Token-lexeme
            &ctx.program.sizes $local.type type-size
            $local-id.scope
            $local-id.shadow
            generate-memory-slot
        }

        $i 1 + #i
    }
}

fn generate-memory-slot(ctx: .Ctx, name-ptr: .i32, name-len: i32, size: i32, scope: i32, shadow: i32) {
    $ctx.fmt Fmt:write-indent
    $ctx.fmt "global.get $stac:k global.get $stac:k i32.const " Fmt:write
    $ctx.fmt $size 4 align-to i32-format
    $ctx.fmt " i32.add global.set $stac:k local.set $" Fmt:write
    $ctx.fmt $name-ptr $name-len Fmt:write
    $scope 0 /= $shadow 0 /= or if {
        $ctx.fmt ":" Fmt:write
        $ctx.fmt $scope i32-format
        $ctx.fmt ":" Fmt:write
        $ctx.fmt $shadow i32-format
    }
    $ctx.fmt "\n" Fmt:write
}

fn parameter-needs-moved-into-memory(ctx: .Ctx, local: .Local) -> bool {
    $local.is-parameter not if { 0 0 / drop }
    $local.reffed &ctx.program.sizes $local.type can-live-in-reg and
}

fn parameter-can-be-abused-ref(ctx: .Ctx, local: .Local) -> bool {
    &ctx.program.sizes $local.type type-size @size
    $size 4 le $size 8 gt or
}

fn generate-locals(ctx: .Ctx, locals: .Map<LocalId, Local>) {
    0 @i
    loop {
        $i $locals.values.len = if { break }
        &locals.values $i Array:get<Local> @local
        $local.is-parameter if {
            $ctx $local parameter-needs-moved-into-memory
            $ctx $local parameter-can-be-abused-ref not
            and if {
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "(local $" Fmt:write
                $ctx.fmt &local.name Token-lexeme Fmt:write
                $ctx.fmt " i32)\n" Fmt:write
            }
        } else {
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "(local $" Fmt:write
            $ctx.fmt &local.name Token-lexeme Fmt:write
            &locals.keys $i Array:get<LocalId> @local-id
            $local-id.scope 0 /= $local-id.shadow 0 /= or if {
                $ctx.fmt ":" Fmt:write
                $ctx.fmt $local-id.scope i32-format
                $ctx.fmt ":" Fmt:write
                $ctx.fmt $local-id.shadow i32-format
            }
            $ctx.fmt " " Fmt:write
            $ctx $local local-lives-in-memory if {
                $ctx.fmt "i32" Fmt:write
            } else {
                $ctx $local.type generate-type
            }
            $ctx.fmt ")\n" Fmt:write
        }
        $i 1 + #i
    }
}

fn generate-words(ctx: .Ctx, module: i32, locals: .Map<LocalId, Local>, words: .Array<Word>) {
    0 @i
    loop {
        $i $words.len = if { break }
        $ctx $module $locals $words $i Array:get<Word> generate-word
        $i 1 + #i
    }
}

fn generate-word(ctx: .Ctx, module: i32, locals: .Map<LocalId, Local>, word: .Word) {
    $ctx.fmt Fmt:write-indent
    $word match {
        case Number -> {
            $ctx.fmt "i32.const " Fmt:write
            $ctx.fmt flip Token-lexeme Fmt:write
        }
        case String -> {
            @word
            $ctx.fmt "i32.const " Fmt:write
            $ctx.fmt
            &ctx.module-data-offsets $module Array:get<i32> ~ $word.offset +
            i32-format
            $ctx.fmt " i32.const " Fmt:write
            $ctx.fmt $word.len i32-format
        }
        case Drop -> {
            drop $ctx.fmt "drop" Fmt:write
        }
        case Intrinsic -> {
            .intrinsic $ctx flip generate-intrinsic
        }
        case GetLocal -> {
            @word
            &ctx.program.sizes $word.result-type can-live-in-reg @result-can-live-in-reg

            $ctx.program $word.result-type lookup-type @result-type

            $result-can-live-in-reg not if {
                // set up the address to store the result in
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset i32-format
                $ctx.fmt " i32.add call $intrinsic:dupi32 " Fmt:write
            }
            &word.var match {
                case Global -> {
                    @global-id
                    $ctx.fmt "global.get $" Fmt:write
                    $ctx.program $global-id lookup-globl @globl
                    $ctx.fmt &globl.name Token-lexeme Fmt:write
                    $ctx.fmt ":" Fmt:write
                    $ctx.fmt $global-id.module.index i32-format
                    $ctx $globl globl-lives-in-memory
                }
                case Local -> {
                    @local-id
                    $ctx.fmt "local.get " Fmt:write
                    $locals $local-id Map:get<LocalId, Local> Maybe:assert-some<.Local> @local
                    $ctx.fmt $local $local-id generate-local-ident
                    $ctx $local local-lives-in-memory
                }
            } @var-lives-in-memory
            // at this point, either the value itself or a pointer to it is on the stack

            0 !.Arena Arena:temp @temp @temp-save
            0 1 = @just-ref
            $temp $ctx &word.fields $just-ref $var-lives-in-memory determine-loads @loads

            &ctx.program.sizes $word.result-type type-size @result-size
            $ctx &loads generate-loads
            &loads List:is-empty<Load> if {
                $result-can-live-in-reg if {
                    $var-lives-in-memory if {
                        $ctx.fmt " " Fmt:write
                        $ctx $word.result-type generate-type
                        $ctx.fmt ".load" Fmt:write
                    }
                } else {
                    $ctx.fmt " i32.const " Fmt:write
                    $ctx.fmt $result-size i32-format
                    $ctx.fmt " memory.copy" Fmt:write
                }
            }
            $temp $temp-save Arena:restore
        }
        case InitLocal -> {
            @word
            List:empty<Load> @loads

            $ctx $locals &word.local Map:get<LocalId, Local> Maybe:assert-some<.Local>
            local-lives-in-memory @var-lives-in-memory

            $ctx $locals $word.local make VarId.Local $word.type $var-lives-in-memory &loads generate-set
        }
        case SetLocal -> {
            @word
            0 !.Arena Arena:temp @temp @temp-save
            $ctx $locals &word.var var-lives-in-memory @var-lives-in-memory

            $var-lives-in-memory
            $ctx &word.fields fields-go-through-ptr
            or @target-lives-in-memory

            $temp $ctx &word.fields $target-lives-in-memory $var-lives-in-memory determine-loads @loads
            $ctx $locals $word.var $word.target-type $target-lives-in-memory &loads generate-set
            $temp $temp-save Arena:restore
        }
        case RefLocal -> {
            @word
            0 !.Arena Arena:temp @temp @temp-save
            $temp $ctx &word.fields 1 1 = 0 1 = determine-loads @loads
            $ctx.fmt &word.var match {
                case Local -> { drop "local.get " }
                case Global -> { drop "global.get " }
            } Fmt:write
            $ctx $locals &word.var generate-var-ident
            $ctx &loads generate-loads
            $temp $temp-save Arena:restore
        }
        case Call -> {
            @word
            $ctx.fmt "call $" Fmt:write
            $ctx.fmt $word.function.module.index i32-format
            $ctx.fmt ":" Fmt:write
            $ctx.fmt $ctx.program &word.function lookup-function match {
                case Extern -> { @ext &ext.name &ext.signature }
                case Function -> { @fun &fun.name &fun.signature }
            } @signature Token-lexeme Fmt:write
            $word.function.instance 0 /= if {
                $ctx.fmt ":" Fmt:write
                $ctx.fmt $word.function.instance i32-format
            }
            $ctx $word.copy-space-offset &signature.returns generate-return-receivers
        }
        case If -> {
            @word
            $ctx.fmt "(if" Fmt:write
            $ctx &word.parameters generate-parameters-unnamed
            $ctx &word.returns match {
                case None -> { drop }
                case Some -> { generate-returns }
            }
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "(then\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx $module $locals &word.true-words generate-words
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")\n" Fmt:write
            $word.false-words.len 0 /= if {
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "(else\n" Fmt:write
                $ctx.fmt Fmt:indent
                $ctx $module $locals &word.false-words generate-words
                $ctx.fmt Fmt:dedent
                $ctx.fmt Fmt:write-indent
                $ctx.fmt ")\n" Fmt:write
            }
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")" Fmt:write
            &word.returns match {
                case None -> {
                    $ctx.fmt "\n" Fmt:write
                    $ctx.fmt Fmt:write-indent
                    $ctx.fmt "unreachable" Fmt:write
                }
                case Some -> { drop }
            }
        }
        case Break -> { drop $ctx.fmt "br $block" Fmt:write }
        case Block -> {
            @word
            $ctx.fmt "(block $block" Fmt:write
            $ctx &word.parameters generate-parameters-unnamed
            $ctx &word.returns generate-returns
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx $module $locals &word.words generate-words
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")" Fmt:write
        }
        case Loop -> {
            @word
            $ctx.fmt "(block $block " Fmt:write
            $ctx &word.parameters generate-parameters-unnamed
            $ctx &word.returns match { case Some -> { generate-returns } case None -> { drop } }
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "(loop $loop " Fmt:write
            $ctx &word.parameters generate-parameters-unnamed
            $ctx &word.returns match { case Some -> { generate-returns } case None -> { drop } }
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx $module $locals &word.words generate-words
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "br $loop\n" Fmt:write
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")\n" Fmt:write
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")" Fmt:write
            &word.returns match {
                case Some -> { drop }
                case None -> {
                    $ctx.fmt "\n" Fmt:write
                    $ctx.fmt Fmt:write-indent
                    $ctx.fmt "unreachable" Fmt:write
                }
            }
        }
        case Load -> {
            @word
            &ctx.program.sizes $word.type can-live-in-reg if {
                $ctx $word.type generate-type
                $ctx.fmt ".load" Fmt:write
            } else {
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset i32-format
                $ctx.fmt " i32.add call $intrinsic:dupi32 call $intrinsic:rotate-left i32.const " Fmt:write
                $ctx.fmt &ctx.program.sizes $word.type type-size i32-format
                $ctx.fmt " memory.copy" Fmt:write
            }
        }
        case Struct -> { block {
            @word
            $ctx.program $word.type lookup-type match {
                case Custom -> {}
                case _ -> { drop Core:unreachable<.CustomTypeHandle> }
            } @custom-type-handle
            $ctx.program $custom-type-handle lookup-custom-type match {
                case Variant -> { drop Core:unreachable<.Struct> }
                case Struct -> {}
            } @struc

            &ctx.program.sizes $word.type type-size @type-size
            $type-size 8 le if {
                $type-size 0 = if {
                    0 @i
                    loop {
                        $i $struc.fields.len = if { break }
                        $ctx.fmt "drop " Fmt:write
                        $i 1 + #i
                    }
                    $ctx.fmt "i32.const 0 ;; make " Fmt:write
                    $ctx $word.type generate-type-pretty
                    break
                }
                $type-size 4 le if {
                    $struc.fields.len 1 /= if {
                        // alternative is TODO
                        0 0 / drop
                    }
                    $ctx.fmt ";; make " Fmt:write
                    $ctx $word.type generate-type-pretty
                    break
                }
                $type-size 8 le if {
                    $struc.fields.len 1 = if {
                        $ctx.fmt ";; make " Fmt:write
                        $ctx $word.type generate-type-pretty
                        break
                    }
                    $struc.fields.len 2 = if {
                        &ctx.program.sizes &struc.fields 0 Array:get<NamedTypeId> .type ~ type-size 4 =
                        &ctx.program.sizes &struc.fields 1 Array:get<NamedTypeId> .type ~ type-size 4 =
                        and not if {
                            0 0 / drop // TODO
                        }
                        $ctx generate-pack-i32s
                        $ctx.fmt " ;; make " Fmt:write
                        $ctx $word.type generate-type-pretty
                        break
                    }
                    0 0 / drop // TODO: implement packing structs made up of i8s
                }
            }

            $ctx.fmt ";; make " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $struc.fields.len @i
            loop {
                $i 0 = if { break }
                $i 1 - @field-index
                &struc.fields $field-index Array:get<NamedTypeId> @field
                &ctx.program.sizes $field.type type-size @field-size
                &ctx.program.sizes $struc $field-index field-offset @field-offset
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset $field-offset + i32-format
                $ctx.fmt " i32.add " Fmt:write
                $field-size 4 gt $field-size 8 le and if {
                    $ctx generate-flip-i64-i32
                } else {
                    $ctx generate-flip-i32-i32
                }
                $ctx.fmt " " Fmt:write
                $ctx $field.type generate-store
                $ctx.fmt "\n" Fmt:write
                $i 1 - #i
            }
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add ;; make " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt " end" Fmt:write
        } }
        case StructNamed -> { block {
            @word
            $ctx.program $word.type lookup-type match {
                case Custom -> {}
                case _ -> { drop Core:unreachable<.CustomTypeHandle> }
            } @custom-type-handle
            $ctx.program $custom-type-handle lookup-custom-type match {
                case Variant -> { drop Core:unreachable<.Struct> }
                case Struct -> {}
            } @struc
            &ctx.program.sizes $word.type type-size @type-size
            $type-size 0 = if {
                0 @i
                loop {
                    $i $struc.fields.len = if { break }
                    $ctx.fmt "drop " Fmt:write
                    $i 1 + #i
                }
                $ctx.fmt "i32.const 0 ;; make " Fmt:write
                $ctx $word.type generate-type-pretty
                break
            }
            $ctx.fmt ";; make " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx $module $locals &word.words generate-words
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add " Fmt:write
            block {
                $type-size 4 le if {
                    $ctx.fmt "i32.load " Fmt:write
                }
                $type-size 8 le if {
                    $ctx.fmt "i64.load " Fmt:write
                }
            }
            $ctx.fmt ";; make " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt " end" Fmt:write
        } }
        case FieldInit -> {
            @word
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add " Fmt:write
            &ctx.program.sizes $word.type type-size @type-size
            $type-size 4 le $type-size 8 gt or if {
                $ctx generate-flip-i32-i32
            } else {
                $ctx generate-flip-i64-i32
            }
            $ctx.fmt " " Fmt:write
            $ctx $word.type generate-store
        }
        case Variant -> { block {
            @word
            $ctx.program $word.type lookup-type match {
                case Custom -> {}
                case _ -> { drop Core:unreachable<.CustomTypeHandle> }
            } @custom-type-handle
            $ctx.program $custom-type-handle lookup-custom-type match {
                case Variant -> {}
                case Struct -> { drop Core:unreachable<.Variant> }
            } @varint
            &varint.cases $word.tag Array:get<VariantCase> @cays
            &ctx.program.sizes $word.type type-size @varint-size

            $varint-size 4 le if {
                $varint-size 4 /= if {
                    // The tag is (at least for now) always 4 bytes,
                    // so there can be no smaller variant.
                    0 0 / drop
                }
                $cays.type match {
                    case Some -> { drop $ctx.fmt "drop " Fmt:write }
                    case None -> {}
                }
                $ctx.fmt "i32.const " Fmt:write
                $ctx.fmt $word.tag i32-format
                $ctx.fmt " ;; store tag " Fmt:write
                $ctx.fmt &varint.name Token-lexeme Fmt:write
                $ctx.fmt "." Fmt:write
                $ctx.fmt &cays.name Token-lexeme Fmt:write
                break
            }

            $varint-size 8 le if {
                $cays.type match {
                    case None -> {
                        $ctx.fmt "i64.const " Fmt:write
                        $ctx.fmt $word.tag i32-format
                        $ctx.fmt " ;; make " Fmt:write
                    }
                    case Some -> {
                        drop
                        $ctx.fmt "i64.extend_i32_u i64.const 32 i64.shl ;; store value\n" Fmt:write
                        $ctx.fmt Fmt:write-indent
                        $ctx.fmt "i64.const " Fmt:write
                        $ctx.fmt $word.tag i32-format
                        $ctx.fmt " ;; store tag\n" Fmt:write
                        $ctx.fmt Fmt:write-indent
                        $ctx.fmt "i64.or ;; make " Fmt:write
                    }
                }
                $ctx.fmt &varint.name Token-lexeme Fmt:write
                $ctx.fmt "." Fmt:write
                $ctx.fmt &cays.name Token-lexeme Fmt:write
                break
            }

            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add i32.const " Fmt:write
            $ctx.fmt $word.tag i32-format
            $ctx.fmt " i32.store ;; store tag\n" Fmt:write
            $cays.type match {
                case Some -> {
                    @case-type
                    &ctx.program.sizes $case-type type-size @case-type-size

                    $ctx.fmt Fmt:write-indent
                    $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                    $ctx.fmt $word.copy-space-offset 4 + i32-format
                    $ctx.fmt " i32.add " Fmt:write
                    $case-type-size 4 gt $case-type-size 8 le and if {
                        $ctx generate-flip-i64-i32
                    } else {
                        $ctx generate-flip-i32-i32
                    }
                    $ctx.fmt " " Fmt:write
                    $ctx $case-type generate-store
                    $ctx.fmt " ;; store value\n" Fmt:write
                }
                case None -> {}
            }
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add ;; make " Fmt:write
            $ctx.fmt &varint.name Token-lexeme Fmt:write
            $ctx.fmt "." Fmt:write
            $ctx.fmt &cays.name Token-lexeme Fmt:write
        } }
        case Match -> {
            @word
            $ctx.program $word.type lookup-type match {
                case Custom -> {}
                case _ -> { drop Core:unreachable<.CustomTypeHandle> }
            } @custom-type-handle
            $ctx.program $custom-type-handle lookup-custom-type match {
                case Variant -> {}
                case Struct -> { drop Core:unreachable<.Variant> }
            } @varint
            &ctx.program.sizes $word.type type-size @variant-size
            $ctx.fmt ";; match on " Fmt:write
            $ctx.fmt &varint.name Token-lexeme Fmt:write
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:write-indent
            0 @i
            &ctx.program.sizes $word.type can-live-in-reg @variant-can-live-in-reg
            loop {
                $i $word.cases.len = if {
                    &word.default match {
                        case None -> {
                            $ctx.fmt "unreachable" Fmt:write
                        }
                        case Some -> {
                            $ctx flip $module flip $locals flip generate-words
                        }
                    }
                    break
                }
                &word.cases $i Array:get<MatchCase> @cays
                block {
                    $variant-size 8 gt $word.by-ref or if {
                        $ctx.fmt "call $intrinsic:dupi32 i32.load " Fmt:write
                        break
                    }
                    $variant-size 4 gt if {
                        $ctx generate-dup-i64
                        $ctx.fmt " i32.wrap_i64 " Fmt:write
                        break
                    }
                    $ctx.fmt "call $intrinsic:dupi32 " Fmt:write
                }
                $ctx.fmt "i32.const " Fmt:write
                $ctx.fmt $cays.tag i32-format
                $ctx.fmt " i32.eq (if" Fmt:write
                $ctx &word.parameters generate-parameters-unnamed

                $variant-size 8 le $variant-size 4 gt and $word.by-ref not and @variant-inhabits-i64
                $ctx.fmt $variant-inhabits-i64 if {
                    " (param i64)"
                } else {
                    " (param i32)"
                } Fmt:write

                $ctx &word.returns generate-returns
                $ctx.fmt "\n" Fmt:write
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "(then\n" Fmt:write
                $ctx.fmt Fmt:indent
                $cays.type match {
                    case None -> {
                        $ctx.fmt Fmt:write-indent
                        $ctx.fmt "drop\n" Fmt:write
                    }
                    case Some -> {
                        @case-type
                        &ctx.program.sizes $case-type type-size @case-type-size
                        $case-type-size 0 /= if {
                            $ctx.fmt Fmt:write-indent
                            $word.by-ref $variant-size 8 gt or if {
                                $ctx.fmt "i32.const 4 i32.add" Fmt:write
                                $word.by-ref not $case-type-size 8 le and if {
                                    $ctx.fmt " " Fmt:write
                                    $ctx $case-type generate-type
                                    $ctx.fmt ".load" Fmt:write
                                }
                            } else {
                                $ctx.fmt "i64.const 32 i64.shr_u i32.wrap_i64" Fmt:write
                            }
                            $ctx.fmt "\n" Fmt:write
                        } else {
                            $variant-inhabits-i64 if {
                                $ctx.fmt Fmt:write-indent
                                $ctx.fmt "i32.wrap_i64\n" Fmt:write
                            }
                        }
                    }
                }
                $ctx $module $locals &cays.words generate-words
                $ctx.fmt Fmt:dedent
                $ctx.fmt Fmt:write-indent
                $ctx.fmt ")\n" Fmt:write
                $ctx.fmt Fmt:write-indent
                $i 1 + $word.cases.len = &word.default is-some<Array<Word>> and if {
                    $ctx.fmt "(else\n" Fmt:write
                    $ctx.fmt Fmt:indent
                } else {
                    $ctx.fmt "(else " Fmt:write
                }
                $i 1 + #i
            }
            loop {
                $i 0 = if { break }
                $i $word.cases.len = &word.default is-some<Array<Word>> and if {
                    $ctx.fmt Fmt:dedent
                    $ctx.fmt Fmt:write-indent
                }
                $ctx.fmt "))" Fmt:write
                $i 1 - #i
            }
        }
        case Flip -> {
            @flip
            &ctx.program.sizes $flip.lower type-size @lower-size
            &ctx.program.sizes $flip.upper type-size @upper-size
            $lower-size 4 le $lower-size 8 gt or @lower-is-i32
            $upper-size 4 le $upper-size 8 gt or @upper-is-i32
            block {
                $lower-is-i32     $upper-is-i32     and if { $ctx generate-flip-i32-i32 break }
                $lower-is-i32     $upper-is-i32 not and if { $ctx generate-flip-i32-i64 break }
                $lower-is-i32 not $upper-is-i32     and if { $ctx generate-flip-i64-i32 break }
                $lower-is-i32 not $upper-is-i32 not and if { $ctx generate-flip-i64-i64 break }
                0 0 / drop
            }
        }
        case Cast -> {
            @word
            block {
                &ctx.program.sizes $word.src type-size @src-size
                &ctx.program.sizes $word.dst type-size @dst-size
                $src-size 4 le $dst-size 4 le and
                $src-size 4 gt $src-size 8 le and $dst-size 4 gt $dst-size 8 le and and
                or if {
                    $ctx.fmt ";; cast to " Fmt:write
                    $ctx $word.dst generate-type-pretty
                    break
                }
                $src-size 4 le $dst-size 4 gt and if {
                    $ctx.fmt "i64.extend_i32_s ;; cast to " Fmt:write
                    $ctx $word.dst generate-type-pretty
                    break
                }
                $src-size 4 gt $src-size 8 le and $dst-size 4 le and if {
                    $ctx.fmt "i32.wrap_i64 ;; cast to " Fmt:write
                    $ctx $word.dst generate-type-pretty
                    break
                }

                $ctx.program $word.dst lookup-type match {
                    case I64 -> {
                        &ctx.program.sizes $word.src can-live-in-reg if {
                            $ctx.fmt "i64.extend_i32_s" Fmt:write
                            break
                        }
                    }
                    case _ -> { drop }
                }

                $ctx.fmt "UNSUPPORTED Cast from " Fmt:write
                $ctx $word.src generate-type-pretty
                $ctx.fmt " to " Fmt:write
                $ctx $word.dst generate-type-pretty
            }
        }
        case Sizeof -> {
            &ctx.program.sizes flip ~ type-size
            $ctx.fmt "i32.const " Fmt:write
            $ctx.fmt flip i32-format
        }
        case IndirectCall -> {
            @word
            $ctx.program $word.type lookup-type match {
                case Fun -> {}
                case _ -> { drop Core:unreachable<.FunType> }
            } @fun-type
            $ctx.fmt "(call_indirect" Fmt:write
            $ctx &fun-type.parameters generate-parameters-unnamed
            $ctx &fun-type.returns generate-returns
            $ctx.fmt ")" Fmt:write
            $ctx $word.copy-space-offset &fun-type.returns generate-return-receivers
        }
        case GetField -> {
            @word
            0 !.Arena Arena:temp @temp @temp-save
            $temp $ctx &word.fields $word.on-ptr 0 1 = determine-loads @loads
            &loads List:is-empty<Load> if {
                $ctx.fmt ";; GetField was no-op" Fmt:write
            } else {
                &ctx.program.sizes $word.type can-live-in-reg @target-type-can-live-in-reg
                $word.on-ptr not $target-type-can-live-in-reg not and if {
                    $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                    $ctx.fmt $word.copy-space-offset i32-format
                    $ctx.fmt " i32.add call $intrinsic:dupi32 " Fmt:write
                }
                $ctx &loads generate-loads
            }
            $temp $temp-save Arena:restore
        }
        case Uninit -> { block {
            @word
            &ctx.program.sizes $word.type type-size @type-size
            $type-size 4 le if {
                $ctx.fmt "i32.const 0" Fmt:write
                break
            }

            $type-size 8 le if {
                $ctx.fmt "i64.const 0" Fmt:write
                break
            }
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add" Fmt:write
        } }
        case FunRef -> {
            $ctx.fmt "i32.const " Fmt:write
            .table-index ~ $ctx.fmt flip 1 + i32-format
        }
        case StoreLocal -> {
            @word
            $ctx.fmt &word.var match {
                case Local -> { drop "local.get " }
                case Global -> { drop "global.get " }
            } Fmt:write
            $ctx $locals &word.var generate-var-ident
            0 !.Arena Arena:temp @temp @temp-save
            $temp $ctx &word.fields 1 0 = 0 1 = determine-loads @loads
            $ctx &loads generate-loads
            $ctx.fmt " call $intrinsic:flip " Fmt:write
            $ctx $word.type generate-store
            $temp $temp-save Arena:restore
        }
        case MakeTuple -> { block {
            @word
            $ctx.program $word.type lookup-type match {
                case Tuple -> {}
                case _ -> { drop Core:unreachable<.Array<TypeId>> }
            } @items
            &ctx.program.sizes $word.type type-size @tuple-size
            $tuple-size 8 le if {
                $tuple-size 0 = if {
                    0 @i
                    loop {
                        $i $items.len = if { break }
                        $ctx.fmt "drop " Fmt:write
                        $i 1 + #i
                    }
                    $ctx.fmt "i32.const 0 " Fmt:write
                }
                $tuple-size 4 gt if {
                    $items.len 2 /= if {
                        // alternative is TODO
                        0 0 / drop
                    }
                    &ctx.program.sizes $items 0 Array:get<TypeId> ~ type-size 4 =
                    &ctx.program.sizes $items 0 Array:get<TypeId> ~ type-size 4 =
                    and not if {
                        // alternative is TODO
                        0 0 / drop
                    }
                    $ctx generate-pack-i32s
                }
                $ctx.fmt ";; make " Fmt:write
                $ctx $word.type generate-type-pretty
                break
            }
            $ctx.fmt ";; make " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt "\n" Fmt:write
            $tuple-size @item-offset
            $ctx.fmt Fmt:indent
            $items.len @i
            loop {
                $i 0 = if { break }
                $i 1 - #i
                $items $i Array:get<TypeId> ~ @item
                &ctx.program.sizes $item type-size @item-size
                $item-offset $item-size - #item-offset
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset $item-offset + i32-format
                $ctx.fmt " i32.add " Fmt:write
                $item-size 4 gt $item-size 8 le and if {
                    $ctx generate-flip-i64-i32
                } else {
                    $ctx generate-flip-i32-i32
                }
                $ctx.fmt " " Fmt:write
                $ctx $item generate-store
                $ctx.fmt "\n" Fmt:write
            }
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add ;; make " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt " end" Fmt:write
        } }
        case UnpackTuple -> { block {
            @word
            $ctx.program $word.type lookup-type match {
                case Tuple -> {}
                case _ -> { drop Core:unreachable<.Array<TypeId>> }
            } @items
            $items.len 2 = if {
                &ctx.program.sizes $items 0 Array:get<TypeId> ~ type-size 4 =
                &ctx.program.sizes $items 1 Array:get<TypeId> ~ type-size 4 =
                and if {
                    $ctx generate-unpack-i32s
                    $ctx.fmt ";; unpack " Fmt:write
                    $ctx $word.type generate-type-pretty
                    break
                }
            }
            $ctx.fmt ";; unpack " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $word.copy-space-offset @copy-space-offset
            0 @offset
            0 @i
            loop {
                $i $items.len = if { break }
                $items $i Array:get<TypeId> ~ @item
                $i 1 + #i
                &ctx.program.sizes $item type-size @item-size
                $ctx.fmt Fmt:write-indent
                $item-size 0 = if {
                    $ctx.fmt "i32.const " Fmt:write
                } else {
                    $i $items.len /= if {
                        $ctx.fmt "call $intrinsic:dupi32 " Fmt:write
                    }
                    $ctx.fmt "i32.const " Fmt:write
                    $ctx.fmt $offset i32-format
                    $ctx.fmt " i32.add " Fmt:write

                    &ctx.program.sizes $item can-live-in-reg if {
                        $ctx.fmt "i32.load" Fmt:write
                    } else {
                        $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                        $ctx.fmt $copy-space-offset i32-format
                        $ctx.fmt " i32.add call $intrinsic:dupi32 call $intrinsic:rotate-left i32.const " Fmt:write
                        $ctx.fmt $item-size i32-format
                        $ctx.fmt " memory.copy" Fmt:write
                        $copy-space-offset $item-size + #copy-space-offset
                    }
                    $i $items.len /= if {
                        $ctx.fmt " call $intrinsic:flip\n" Fmt:write
                    }
                }
                $offset $item-size + #offset
            }
            $ctx.fmt Fmt:dedent
        } }
    }
    $ctx.fmt "\n" Fmt:write
}

fn generate-flip-i32-i32(ctx: .Ctx) {
    1 1 = #ctx.flip-i32-i32-used
    $ctx.fmt "call $intrinsic:flip" Fmt:write
}
fn generate-flip-i32-i64(ctx: .Ctx) {
    1 1 = #ctx.flip-i32-i64-used
    $ctx.fmt "call $intrinsic:flip-i32-i64" Fmt:write
}
fn generate-flip-i64-i32(ctx: .Ctx) {
    1 1 = #ctx.flip-i64-i32-used
    $ctx.fmt "call $intrinsic:flip-i64-i32" Fmt:write
}
fn generate-flip-i64-i64(ctx: .Ctx) {
    1 1 = #ctx.flip-i64-i64-used
    $ctx.fmt "call $intrinsic:flip-i64-i64" Fmt:write
}
fn generate-pack-i32s(ctx: .Ctx) {
    1 1 = #ctx.pack-i32s-used
    $ctx.fmt "call $intrinsic:pack-i32s" Fmt:write
}
fn generate-unpack-i32s(ctx: .Ctx) {
    1 1 = #ctx.unpack-i32s-used
    $ctx.fmt "call $intrinsic:unpack-i32s" Fmt:write
}
fn generate-dup-i64(ctx: .Ctx) {
    1 1 = #ctx.dup-i64-used
    $ctx.fmt "call $intrinsic:dupi64" Fmt:write
}

fn fields-go-through-ptr(ctx: .Ctx, fields: .Array<FieldAccess>) -> bool {
    0 @i
    loop {
        $i $fields.len = if {
            // No field access went through a pointer,
            0 1 = break
        }
        $ctx.program $fields $i Array:get<FieldAccess> .source-type ~ lookup-type match {
            case Ptr -> {
                drop
                // At least one field access goes through a pointer,
                1 1 = break
            }
            case _ -> { drop }
        }
        $i 1 + #i
    }
}

fn generate-set(
    ctx: .Ctx,
    locals: .Map<LocalId, Local>,
    var-id: VarId,
    target-type: TypeId,
    target-lives-in-memory: bool,
    loads: .List<Load>
) { block {
    &var-id match {
        case Local -> {
            $locals flip Map:get<LocalId, Local> Maybe:assert-some<.Local> @local
            $ctx $local local-lives-in-memory
            $local.type
        }
        case Global -> {
            $ctx.program flip lookup-globl @globl
            $ctx $globl globl-lives-in-memory
            $globl.type
        }
    } @var-type @var-lives-in-memory

    $loads List:is-empty<Load> $target-lives-in-memory not and if {
        $ctx.fmt &var-id match {
            case Local -> { drop "local.set " }
            case Global -> { drop "global.set " }
        } Fmt:write
        $ctx $locals &var-id generate-var-ident
        break
    }

    $ctx.fmt &var-id match {
        case Local -> { drop "local.get " }
        case Global -> { drop "global.get " }
    } Fmt:write
    $ctx $locals &var-id generate-var-ident

    &ctx.program.sizes $target-type type-size @target-type-size

    $loads List:is-empty<Load> if {
        $ctx.fmt " " Fmt:write
        $target-type-size 4 gt $target-type-size 8 le and if {
            $ctx generate-flip-i64-i32
        } else {
            $ctx generate-flip-i32-i32
        }
        $ctx.fmt " " Fmt:write
        $ctx $target-type generate-store
        break
    }

    $loads List:last<Load> Maybe:assert-some<.Load> @last-load
    $last-load match {
        case BitShift -> { drop 1 1 = }
        case _ -> { drop 0 1 = }
    } @last-load-is-bitshift

    $target-lives-in-memory not $last-load-is-bitshift and if {
        $loads @l
        loop {
            $l match {
                case Empty -> { break }
                case Cons -> {}
            } @cons
            $cons.next are-all-bitshifts if { break }
            $ctx &cons.elem generate-load
            $cons.next #l
        }
        $ctx.fmt $last-load match {
            case BitShift -> { match {
                case Upper32 -> { " i64.const 0xFFFFFFFF i64.and " }
                case Lower32 -> { " i64.const 0xFFFFFFFF00000000 i64.and " }
            } }
            case _ -> { !.i32 0 0 / }
        } Fmt:write
        $ctx generate-flip-i32-i64
        $ctx.fmt " i64.extend_i32_u " Fmt:write
        $last-load match {
            case BitShift -> { match {
                case Upper32 -> { $ctx.fmt "i64.const 32 i64.shl " Fmt:write }
                case _ -> { drop }
            } }
            case _ -> { drop }
        }
        $ctx.fmt "i64.or " Fmt:write
        $target-lives-in-memory if {
            $ctx.fmt &var-id match {
                case Local -> { drop "local.get " }
                case Global -> { drop "global.get " }
            } Fmt:write
            $ctx $locals &var-id generate-var-ident
            $ctx generate-flip-i64-i32
            // Because the value is being packed into an i64, the modified i64
            // needs to be stored back, not the target-type.
            $ctx I64-id generate-store
            $ctx.fmt "\n" Fmt:write
            break
        } else {
            $ctx.fmt &var-id match {
                case Local -> { drop "local.set " }
                case Global -> { drop "global.set " }
            } Fmt:write
            $ctx $locals &var-id generate-var-ident
            break
        }
    }
    $ctx $loads generate-loads
    $ctx.fmt " " Fmt:write
    $target-type-size 4 gt $target-type-size 8 le and if {
        $ctx generate-flip-i64-i32
    } else {
        $ctx generate-flip-i32-i32
    }
    $ctx.fmt " " Fmt:write
    $ctx $target-type generate-store
} }

fn are-all-bitshifts(loads: .List<Load>) -> bool {
    \Load-is-bitshift $loads List:all<Load>
}

fn generate-loads(ctx: .Ctx, loads: .List<Load>) {
    loop {
        $loads match {
            case Empty -> { break }
            case Cons -> {
                @cons
                $ctx.fmt " " Fmt:write
                $ctx &cons.elem generate-load
                $cons.next #loads
            }
        }
    }
}

fn generate-load(ctx: .Ctx, load: .Load) {
    $load match {
        case BitShift -> {
            $ctx.fmt flip match {
                case Lower32 -> { "i32.wrap_i64" }
                case Upper32 -> { "i64.const 32 i64.shr_u i32.wrap_i64" }
            } Fmt:write
        }
        case Offset -> {
            $ctx.fmt "i32.const " Fmt:write
            $ctx.fmt flip ~ i32-format
            $ctx.fmt " i32.add" Fmt:write
        }
        case OffsetLoad -> {
            ~ [,] @offset @type
            &ctx.program.sizes $type type-size @size
            block {
                $size 4 le if {
                    $ctx.fmt "i32.load" Fmt:write
                    $offset 0 /= if {
                        $ctx.fmt " offset=" Fmt:write
                        $ctx.fmt $offset i32-format
                    }
                    break
                }
                $size 8 le if {
                    $ctx.fmt "i64.load" Fmt:write
                    $offset 0 /= if {
                        $ctx.fmt " offset=" Fmt:write
                        $ctx.fmt $offset i32-format
                    }
                    break
                }
                $offset 0 = if {
                    $ctx.fmt "i32.const " Fmt:write
                    $ctx.fmt $size i32-format
                    $ctx.fmt " memory.copy" Fmt:write
                    break
                }
                $ctx.fmt "i32.const " Fmt:write
                $ctx.fmt $offset i32-format
                $ctx.fmt " i32.add i32.const " Fmt:write
                $ctx.fmt $size i32-format
                $ctx.fmt " memory.copy" Fmt:write
            }
        }
    }
}

fn generate-return-receivers(ctx: .Ctx, offset: i32, returns: .Array<TypeId>) {
    0 @i
    loop {
        $i $returns.len = if {
            // all returns can live in reg
            0 1 = break
        }
        &ctx.program.sizes $returns $i Array:get<TypeId> ~ can-live-in-reg not if {
            $ctx.program $returns $i Array:get<TypeId> ~ lookup-type match {
                // TODO: this special case for I64s can be removed, once i64 structs are supported
                case I64 -> {}
                case _ -> {
                    drop
                    1 1 = break
                }
            }
        }
        $i 1 + #i
    } if {
        // not all returns can live in reg
        $ctx.fmt "\n" Fmt:write
        0 @i
        loop {
            $i $returns.len = if { break }
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "local.set $s" Fmt:write
            $ctx.fmt $i i32-format
            $ctx.fmt ":a\n" Fmt:write
            $i 1 + #i
        }
        $returns.len @i
        loop {
            $i 0 = if { break }
            $returns $returns.len $i - Array:get<TypeId> ~ @ret
            $ctx.fmt Fmt:write-indent
            &ctx.program.sizes $ret can-live-in-reg if {
                $ctx.fmt "local.get $s" Fmt:write
                $ctx.fmt $i 1 - i32-format
                $ctx.fmt ":a" Fmt:write
            } else {
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $offset i32-format
                $ctx.fmt " i32.add call $intrinsic:dupi32 local.get $s" Fmt:write
                $ctx.fmt $i 1 - i32-format
                $ctx.fmt ":a i32.const " Fmt:write
                &ctx.program.sizes $ret type-size @ret-size
                $ctx.fmt $ret-size i32-format
                $ctx.fmt " memory.copy" Fmt:write
                $offset $ret-size + #offset
            }
            $i 1 - #i
            $i 0 = if { break }
            $ctx.fmt "\n" Fmt:write
        }
    }
}

variant BitShift {
    case Upper32
    case Lower32
}

variant Load {
    case Offset -> i32
    case OffsetLoad -> [TypeId, i32]
    case BitShift -> BitShift
}
fn Load-is-bitshift(load: .Load) -> bool {
    1 $load match {
        case BitShift -> { drop 1 }
        case _ -> { drop 0 }
    } =
}
fn Load-format(fmt: .Formatter, self: .Load) {
    $self match {
        case Offset -> {
            $fmt "(Offset " Fmt:write
            $fmt flip ~ i32-format
            $fmt ")" Fmt:write
        }
        case OffsetLoad -> {
            ~ [,] @offset @type
            $fmt "(OffsetLoad " Fmt:write
            $fmt &type TypeId-format
            $fmt " " Fmt:write
            $fmt $offset i32-format
            $fmt ")" Fmt:write
        }
        case BitShift -> {
            $fmt flip match {
                case Upper32 -> { "Upper32" }
                case Lower32 -> { "Lower32" }
            } Fmt:write
        }
    }
}

fn merge-loads(arena: .Arena, loads: List<Load>) -> List<Load> { block {
    $loads match {
        case Empty -> { $loads break }
        case Cons -> {
            @cons
            $cons.elem
            $cons.next match {
                case Empty -> { drop $loads break }
                case Cons -> { @cons $cons.elem $cons.next }
            }
        }
    } @rest @second @first
    $first match {
        case OffsetLoad -> {
            [,] @first-offset @type
            $second match {
                case BitShift -> {
                    match {
                        case Lower32 -> { 0 }
                        case Upper32 -> { 4 }
                    } @extra-offset
                    I32-id $first-offset $extra-offset + [,2] make Load.OffsetLoad
                    $rest List:cons<Load>
                }
                case _ -> { drop $loads }
            }
        }
        case Offset -> {
            @first
            $second match {
                case Offset -> {
                    @second
                    $first $second + make Load.Offset
                    $rest List:cons<Load>
                }
                case OffsetLoad -> {
                    [,] @second-offset @type
                    $type $first $second-offset + [,2] make Load.OffsetLoad
                    $rest List:cons<Load>
                }
                case _ -> { drop $loads }
            }
        }
        case BitShift -> { drop $loads }
    }
} }

fn determine-loads(arena: .Arena, ctx: .Ctx, fields: .Array<FieldAccess>, just-ref: bool, base-in-mem: bool) -> List<Load> { block {
    $fields.len 0 = if { List:empty<Load> break }

    $fields 0 Array:get<FieldAccess> @field
    $fields Array:tail<FieldAccess> @tail

    &ctx.program.sizes $field.source-type type-size @source-type-size
    $ctx.program $field.source-type lookup-type match {
        case Custom -> {
            $ctx.program flip lookup-custom-type match {
                case Struct -> {
                    @struc
                    &ctx.program.sizes $struc $field.field-index field-offset @offset

                    block {
                        $base-in-mem $source-type-size 8 gt or if {
                            $fields.len 1 gt $just-ref or if {
                                $offset 0 = if {
                                    $arena $ctx &tail $just-ref 1 1 = determine-loads break
                                }
                                $offset make Load.Offset
                            } else {
                                $field.target-type $offset [,2] make Load.OffsetLoad
                            } @load
                            1 1 = #base-in-mem
                            $arena $ctx &tail $just-ref $base-in-mem determine-loads @rest
                            $arena $load &rest List:cons<Load> merge-loads break
                        }
                        $source-type-size 4 gt if {
                            // source-type is within 4 to 8 bytes
                            1 $offset 4 % 0 = !i32 / drop // assert offset == 4 or offset = 0
                            loop {
                                $offset 0 = if { make BitShift.Lower32 break }
                                $offset 4 = if { make BitShift.Upper32 break }
                                0 0 / drop
                            } make Load.BitShift @load

                            $arena $ctx &tail $just-ref $base-in-mem determine-loads @rest
                            $arena $load &rest List:cons<Load> merge-loads break
                        }

                        1 $source-type-size 4 = !i32 / drop // assert source-type-size == 4
                        $arena $ctx &tail $just-ref $base-in-mem determine-loads break
                    }
                }
                case _ -> {
                    // A field access on a variant doesn't make any sense.
                    // The resolver should have taken care of this case.
                    drop Core:unreachable<List<Load>>
                }
            }
        }
        case Ptr -> {
            ~ $ctx.program flip lookup-type match {
                case Custom -> { $ctx.program flip lookup-custom-type match {
                    case Struct -> {}
                    case _ -> {
                        // A field access on a variant doesn't make any sense.
                        // The resolver should have taken care of this case.
                        drop Core:unreachable<.Struct>
                    }
                } }
                case _ -> {
                    // A field access only makes sense on structs, or ptr to structs.
                    // The resolver should have taken care of this case.
                    drop Core:unreachable<.Struct>
                }
            } @struc
            &ctx.program.sizes $struc $field.field-index field-offset @offset

            &ctx.program.sizes $field.target-type type-size @target-type-size

            $just-ref $fields.len 1 = and
            $target-type-size 8 gt $fields.len 1 /= and
            or if {
                $offset 0 = if {
                    $arena $ctx &tail $just-ref $base-in-mem determine-loads
                } else {
                    $offset make Load.Offset @load
                    $arena $ctx &tail $just-ref $base-in-mem determine-loads @rest
                    $arena $load &rest List:cons<Load> merge-loads
                }
            } else {
                $field.target-type $offset [,2] make Load.OffsetLoad @load
                $arena $ctx &tail $just-ref $base-in-mem determine-loads @rest
                $arena $load &rest List:cons<Load> merge-loads
            }
        }
        case _ -> {
            // A field access only makes sense on structs, or ptr to structs.
            // The resolver should have taken care of this case.
            drop Core:unreachable<List<Load>>
        }
    }
} }

fn determine-loads3(arena: .Arena, ctx: .Ctx, fields: .Array<FieldAccess>, lives-in-memory: bool) -> Array<i32> {
    Array:new<i32> @loads
    0 @i
    loop {
        $i $fields.len = if { $loads break }
        $fields $i Array:get<FieldAccess> @field
        $ctx.program $field.source-type lookup-type match {
            case Ptr -> { drop 1 1 = }
            case _ -> { drop 0 1 = }
        } @source-type-is-ptr
        &ctx.program.sizes $field.source-type can-live-in-reg
        $i 0 = $lives-in-memory and not and
        $source-type-is-ptr not and if {
            $i 1 + #i
        } else {
            0 @offset
            loop {
                $i $fields.len = if { break }
                $fields $i Array:get<FieldAccess> @field

                $ctx.program $field.source-type lookup-type match {
                    case Custom -> {}
                    case Ptr -> { $ctx.program flip ~ lookup-type match {
                        case Custom -> {}
                        case _ -> { drop Core:unreachable<.CustomTypeHandle> }
                    } }
                    case _ -> { drop Core:unreachable<.CustomTypeHandle> }
                } @struct-handle

                $ctx.program $struct-handle lookup-custom-type match {
                    case Variant -> { drop Core:unreachable<.Struct> }
                    case Struct -> {}
                } @struc

                &ctx.program.sizes $struc $field.field-index field-offset @field-offset

                $offset $field-offset + #offset
                $i 1 + #i

                $ctx.program $field.target-type lookup-type match {
                    case Custom -> { drop }
                    case _ -> { drop break }
                }
            }
            $arena &loads $offset Array:push<i32>
        }
    }
}

fn generate-store(ctx: .Ctx, type: TypeId) { block {
    &ctx.program.sizes $type type-size @type-size
    $type-size 8 gt if {
        $ctx.fmt "i32.const " Fmt:write
        $ctx.fmt $type-size i32-format
        $ctx.fmt " memory.copy" Fmt:write
        break
    }
    $type-size 4 gt if {
        $ctx.fmt "i64.store" Fmt:write break
    }
    $ctx.fmt "i32.store" Fmt:write
} }

fn generate-var-ident(ctx: .Ctx, locals: .Map<LocalId, Local>, var-id: .VarId) {
    $ctx $var-id match {
        case Local -> {
            $locals flip generate-local-ident-by-id
        }
        case Global -> {
            @global-id
            .fmt ~ "$" Fmt:write
            $ctx.program $global-id lookup-globl @globl
            $ctx.fmt &globl.name Token-lexeme Fmt:write
            $ctx.fmt ":" Fmt:write
            $ctx.fmt $global-id.module.index i32-format
        }
    }
}

fn generate-local-ident-by-id(ctx: .Ctx, locals: .Map<LocalId, Local>, local-id: .LocalId) {
    $ctx.fmt 
    $locals $local-id Map:get<LocalId, Local> Maybe:assert-some<.Local>
    $local-id generate-local-ident
}

fn generate-local-ident(fmt: .Formatter, local: .Local, local-id: .LocalId) {
    $fmt "$" Fmt:write
    $fmt &local.name Token-lexeme Fmt:write
    $local-id.scope 0 /= $local-id.shadow 0 /= or if {
        $fmt ":" Fmt:write
        $fmt $local-id.scope i32-format
        $fmt ":" Fmt:write
        $fmt $local-id.shadow i32-format
    }
}

fn generate-intrinsic(ctx: .Ctx, intrinsic: .Intrinsic) { block () -> {
    $ctx.fmt $intrinsic match {
        case Add -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.add" }
            case _ -> { drop "i32.add" }
        } }
        case Sub -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.sub" }
            case _ -> { drop "i32.sub" }
        } }
        case Eq -> {
            ~ @type
            $ctx.program $type lookup-type match {
                case I64 -> { "i64.eq" }
                case _ -> {
                    0 &ctx.program.sizes $type can-live-in-reg !i32 / drop // assert
                    drop "i32.eq"
                }
            }
        }
        case NotEq -> {
            ~ @type
            $ctx.program $type lookup-type match {
                case I64 -> { "i64.ne" }
                case _ -> {
                    0 &ctx.program.sizes $type can-live-in-reg !i32 / drop // assert
                    drop "i32.ne"
                }
            }
        }
        case Mod -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.rem_u" }
            case I64 -> { "i64.rem_u" }
            case _ -> { !.i32 0 0 / }
        } }
        case Mul -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.mul" }
            case I64 -> { "i64.mul" }
            case _ -> { !.i32 0 0 / }
        } }
        case Div -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.div_u" }
            case I64 -> { "i64.div_u" }
            case _ -> { !.i32 0 0 / }
        } }
        case Lt -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.lt_u" }
            case I64 -> { "i64.lt_u" }
            case _ -> { !.i32 0 0 / }
        } }
        case Gt -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.gt_u" }
            case I64 -> { "i64.gt_u" }
            case _ -> { !.i32 0 0 / }
        } }
        case Le -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.le_u" }
            case I64 -> { "i64.le_u" }
            case _ -> { !.i32 0 0 / }
        } }
        case Ge -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.ge_u" }
            case I64 -> { "i64.ge_u" }
            case _ -> { !.i32 0 0 / }
        } }
        case And -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.and" }
            case I32 -> { "i32.and" }
            case Bool -> { "i32.and" }
            case _ -> { !.i32 0 0 / }
        } }
        case Or -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.or" }
            case I32 -> { "i32.or" }
            case Bool -> { "i32.or" }
            case _ -> { !.i32 0 0 / }
        } }
        case Not -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.const -1 i64.xor" }
            case I32 -> { "i32.const -1 i32.xor" }
            case Bool -> { "i32.const 1 i32.and i32.const 1 i32.xor i32.const 1 i32.and" }
            case _ -> { !.i32 0 0 / }
        } }
        case Load8 -> { "i32.load8_u" }
        case Store8 -> { "i32.store8" }
        case Rotl -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.extend_i32_s i64.rotl" }
            case _ -> { drop "i32.rotl" }
        } }
        case Rotr -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.extend_i32_s i64.rotr" }
            case _ -> { drop "i32.rotr" }
        } }
        case MemCopy -> { "memory.copy" }
        case MemFill -> { "memory.fill" }
        case MemGrow -> { "memory.grow" }
        case Store -> { $ctx flip ~ generate-store break }
        case SetStackSize -> { "drop" } // TODO: support stack guards
        case _ -> { drop "TODO" }
    } Fmt:write
} }

fn generate-signature(
    ctx: .Ctx,
    signature: .Signature,
    export: .Maybe<Token>,
    module: i32,
    name: .Token,
    instance: i32,
    locals: .Map<LocalId, Local>
) {
    $ctx.fmt "func $" Fmt:write
    $ctx.fmt $module i32-format
    $ctx.fmt ":" Fmt:write
    $ctx.fmt $name Token-lexeme Fmt:write
    $instance 0 /= if {
        $ctx.fmt ":" Fmt:write
        $ctx.fmt $instance i32-format
    }
    $export match {
        case None -> {}
        case Some -> {
            $ctx.fmt " (export " Fmt:write
            $ctx.fmt flip Token-lexeme Fmt:write
            $ctx.fmt ")" Fmt:write
        }
    }
    0 @i
    loop {
        $i $signature.parameters.len = if { break }
        &signature.parameters $i Array:get<NamedTypeId> @parameter
        $ctx.fmt " (param $" Fmt:write
        0 @j
        loop {
            $j $locals.values.len = if { break }
            &locals.values $j Array:get<Local> @local
            $local.is-parameter if {
                &local.name Token-lexeme &parameter.name Token-lexeme Bytes:eq if {
                    &ctx.program.sizes $local.type type-size @local-size
                    $local.reffed $local-size 4 gt and $local-size 8 le and if {
                        $ctx.fmt "v:" Fmt:write
                        break
                    }
                }
            }
            $j 1 + #j
        }
        $ctx.fmt &parameter.name Token-lexeme Fmt:write
        $ctx.fmt " " Fmt:write
        $ctx $parameter.type generate-type
        $ctx.fmt ")" Fmt:write
        $i 1 + #i
    }
    $ctx &signature.returns    generate-returns
}

fn generate-parameters-unnamed(ctx: .Ctx, parameters: .Array<TypeId>) {
    0 @i
    loop {
        $i $parameters.len = if { break }
        $parameters $i Array:get<TypeId> ~ @parameter
        $ctx.fmt " (param " Fmt:write
        $ctx $parameter generate-type
        $ctx.fmt ")" Fmt:write
        $i 1 + #i
    }
}

fn generate-returns(ctx: .Ctx, returns: .Array<TypeId>) {
    0 @i
    loop {
        $i $returns.len = if { break }
        $ctx.fmt " (result " Fmt:write
        $ctx $returns $i Array:get<TypeId> ~ generate-type
        $ctx.fmt ")" Fmt:write
        $i 1 + #i
    }
}

fn generate-type(ctx: .Ctx, type: TypeId) { block {
    &ctx.program.sizes $type type-size @size
    $ctx.fmt $size 4 gt $size 8 le and if {
        "i64"
    } else {
        "i32"
    } Fmt:write
} }

fn generate-type-pretty(ctx: .Ctx, type: TypeId) { block {
    $ctx.fmt $ctx.program $type lookup-type match {
        case I32 -> { "i32" }
        case I64 -> { "i64" }
        case Bool -> { "bool" }
        case Ptr -> { $ctx.fmt "." Fmt:write $ctx flip ~ generate-type-pretty drop break }
        case Tuple -> {
            @items
            "[" Fmt:write
            0 @i
            loop {
                $i $items.len = if { break }
                $ctx $items $i Array:get<TypeId> ~ generate-type-pretty
                $i 1 + #i
                $items.len $i /= if {
                    $ctx.fmt ", " Fmt:write
                }
            }
            $ctx.fmt "]" Fmt:write
            break
        }
        case Fun -> {
            @type
            "(" Fmt:write
            0 @i
            loop {
                $i $type.parameters.len = if { break }
                $ctx &type.parameters $i Array:get<TypeId> ~ generate-type-pretty
                $i 1 + #i
                $i $type.parameters.len /= if {
                    $ctx.fmt ", " Fmt:write
                } else {
                    $ctx.fmt " " Fmt:write
                }
            }
            $ctx.fmt "->" Fmt:write
            0 @i
            loop {
                $i $type.returns.len = if { break }
                $i 0 = if {
                    $ctx.fmt " " Fmt:write
                } else {
                    $i 1 + $type.returns.len /= if {
                        $ctx.fmt ", " Fmt:write
                    }
                }
                $ctx &type.returns $i Array:get<TypeId> ~ generate-type-pretty
                $i 1 + #i
            }
            $ctx.fmt ")" Fmt:write
            break
        }
        case Custom -> {
            $ctx.program flip lookup-custom-type CustomType-name Token-lexeme
        }
    } Fmt:write
} }

