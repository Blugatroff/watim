import "../std/alloc.watim" as A
import "../std/args.watim" as ARGS
import "../std/core.watim" as CORE
import "../std/fmt.watim" as FMT
import "../std/fs.watim" as FS
import "../std/io.watim" as IO
import "../std/map.watim" as MAP
import "../std/str.watim" as STR
import "../std/string.watim" as S
import "../std/util.watim" as U
import "../std/dyn-array.watim" as DynArray
import "../std/array.watim" as Array
import "../std/arena.watim" as Arena

import "./ast.watim" as AST
import "./checker.watim" as C
import "./wat_gen.watim" as GEN
import "./lexer.watim" as L
import "./mem.watim" as MEM
import "./module.watim" as M
import "./parser.watim" as P
import "./resolver.watim" as R
import "./dump.watim" as DUMP
import "./graph.watim" as GRAPH
import "./monomorph.watim" as MONO

fn print-usage-and-exit() {
    2 "The native Watim compiler\n\n" IO:write-all IO:check
    2 "Usage: wasmtime --dir=. ./watim.wasm <watim-source-file>\n" IO:write-all IO:check
    2 "Options:\n" IO:write-all IO:check
    2 "  -q, --quiet    Don't print any logs to stderr\n" IO:write-all IO:check
    2 "  --parse-ast    Parse stdin into a watim AST in print it as JSON\n" IO:write-all IO:check
    1 CORE:exit
}

fn find-flag(args: .Array:Array<STR:Str>, ptr: .i32, len: i32) -> bool {
    $ptr $len STR:Str-new @str
    $args \STR:Str-eq &str Array:find<STR:Str, .STR:Str> if { 
        $args flip Array:remove<STR:Str> drop
        1 1 =
    } else { 
        drop 
        0 1 =
    }
}

fn main() {
    memory temp: i32 65536 // 64 kiB
    memory mem: i32 12582912 // 12 * MiB
    memory alloc-mem: i32 20971520 // 16 MiB

    $temp 65536 Arena:init-temp
    $mem 12582912 Arena:new @arena

    $alloc-mem 20971520 A:init

    &arena FS:init "Failed to init fs" IO:exit-with-message @fs
    &arena ARGS:get-args @args

    enable-logging
    COMPILE set-mode

    &args "--quiet" find-flag if { disable-logging }
    &args "-q" find-flag if { disable-logging }
    &args "--parse-ast" find-flag if { PARSE_AST set-mode }
    &args "--call-graph" find-flag if { CALL_GRAPH set-mode }

    $args.len 1 le if { print-usage-and-exit }
    &args 1 Array:remove<STR:Str> @path 
 
    mode COMPILE = if {
        M:Modules-new @modules
        S:String-empty @mem
        &arena &fs &modules &mem $path STR:Str-unpack load-module-recursive
        &modules R:resolve
        &mem S:String-len &modules MEM:process @stack-start
        &modules C:check
        &modules M:Modules-mark-reachable
        &modules MONO:gather-instances

        FMT:Formatter-stdout @formatter
        &formatter $stack-start &mem &modules GEN:generate
        1 "\n" IO:write-all IO:check
        logging-enabled if { 2 A:report }

        $mem S:String-free
        &modules M:Modules-free
    }
    mode CALL_GRAPH = if {
        M:Modules-new @modules
        S:String-empty @mem
        &arena &fs &modules &mem $path STR:Str-unpack load-module-recursive
        &modules R:resolve
        &mem S:String-len &modules MEM:process @stack-start
        &modules C:check
        &modules M:Modules-mark-reachable
        &modules GRAPH:call-graph-modules @formatted
        
        1 &formatted S:String-unpack IO:write-all IO:check
        
        $mem S:String-free
        $formatted S:String-free
        &modules M:Modules-free
    }

    mode PARSE_AST = if {
        &arena parse-ast
    }

    &arena Arena:clear

    A:is-empty not if {
        A:root A:print-alloc-list
        2 A:report
        2 "MEMORY LEAK DETECTED\n" IO:write-all IO:check
        1 CORE:exit
    }
    logging-enabled if { 2 A:report }
}

fn parse-ast(arena: .Arena:Arena) {
    $arena Arena:save @save
    $arena 0 FS:read-all @code 
    $code 0 /= if {
        2 "Failed to read stdin, Error Code: " IO:write-all IO:check
        2 $code IO:print-to-fd
        1 CORE:exit
    }
    @input

    S:String-empty @mem

    &mem 
    $input "stdin.watim" STR:Str-new L:lex @tokens
    &tokens P:parse @fields @types @items
    
    FMT:Formatter-stdout @formatter
    &formatter &items DUMP:TopItems-json
    &formatter "\n" FMT:Formatter-write

    $items DynArray:free<.AST:TopItem>
    $tokens DynArray:free<.L:Token>
    $mem S:String-free
    $types DynArray:free<.AST:Type>
    $fields DynArray:free<.AST:Field>
    $arena $save Arena:restore
}

fn load-module-recursive(arena: .Arena:Arena, fs: .FS:FileSystem, modules: .M:Modules, mem: .S:String, path-ptr: .i32, path-len: i32) {
    logging-enabled if {
        2 "Loading module: " IO:write-all IO:check
        2 $path-ptr $path-len IO:write-all IO:check
        2 "\n" IO:write-all IO:check
    }
    $arena $fs $path-ptr $path-len $mem M:Module-load @module
    &module M:Module-imports @imps
    $modules $path-ptr $path-len S:String-new $module M:Modules-insert
    
    0 @i
    loop {
        $i $imps AST:Imports-len = if { break }
        $modules $imps $i AST:Imports-get-value ~ STR:Str-unpack M:Modules-get if {
            drop
        } else {
            drop
            $arena $fs
            $modules $mem 
            $imps $i AST:Imports-get-value ~ STR:Str-unpack 
            load-module-recursive
        }
        $i 1 + #i
    }
}

memory LOGGING: bool 4
fn enable-logging() { $LOGGING 0 0 = store }
fn disable-logging() { $LOGGING 0 1 = store }
fn logging-enabled() -> bool { $LOGGING ~ }

fn COMPILE() -> i32 { 1 }
fn PARSE_AST() -> i32 { 2 }
fn CALL_GRAPH() -> i32 { 3 }

memory MODE: i32 4
fn set-mode(mode: i32) { $MODE $mode store }
fn mode() -> i32 { $MODE ~ }

fn start "_start" () {
    // grow memory to (512 + 256) * 2B^16 = 48 MiB
    512 256 + mem-grow 1 /= if { 1 CORE:exit } 
    main
}

