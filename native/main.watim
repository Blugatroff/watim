import "../std/alloc.watim" as A
import "../std/args.watim" as ARGS
import "../std/core.watim" as CORE
import "../std/fmt.watim" as FMT
import "../std/fs.watim" as FS
import "../std/io.watim" as IO
import "../std/str.watim" as STR
import "../std/util.watim" as U
import "../std/dyn-array.watim" as DynArray
import "../std/array.watim" as Array
import "../std/arena.watim" as Arena
import "../std/arena-graph.watim" as ArenaGraph
import "../std/byte-array.watim" as ByteArray

import "./ast.watim" as AST
import "./checker.watim" as C
import "./wat_gen.watim" as GEN
import "./lexer.watim" as L
import "./mem.watim" as MEM
import "./module.watim" as M
import "./parser.watim" as P
import "./resolver.watim" as R
import "./dump.watim" as DUMP
import "./monomorph.watim" as MONO
import "./logging.watim" as LOGGING

fn print-usage-and-exit() {
    2 "The native Watim compiler\n\n" IO:write-all IO:check
    2 "Usage: wasmtime --dir=. ./watim.wasm <watim-source-file>\n" IO:write-all IO:check
    2 "Options:\n" IO:write-all IO:check
    2 "  -q, --quiet    Don't print any logs to stderr\n" IO:write-all IO:check
    2 "  --parse-ast    Parse stdin into a watim AST in print it as JSON\n" IO:write-all IO:check
    1 CORE:exit
}

fn find-flag(args: .Array:Array<STR:Str>, ptr: .i32, len: i32) -> bool {
    $ptr $len STR:Str-new @str
    $args \STR:Str-eq &str Array:find<STR:Str, .STR:Str> if { 
        $args flip Array:remove<STR:Str> drop
        1 1 =
    } else { 
        drop 
        0 1 =
    }
}

fn main() {
    memory temp-mem: i32 65536 // 64 kiB
    memory mem: i32 41943040 // 40 * MiB
    memory alloc-mem: i32 8388608 // 8 MiB

    $temp-mem 65536 Arena:init-temp

    0!.Arena:Arena Arena:temp @temp @save
    $temp ARGS:get-args @args
    $temp $save Arena:restore

    LOGGING:enable
    COMPILE set-mode

    &args "-q" find-flag 
    &args "--quiet" find-flag or if { LOGGING:disable }
    &args "--parse-ast" find-flag if { PARSE_AST set-mode }
    &args "--arena-graphs" find-flag if { ArenaGraph:enable LOGGING:disable }

    $args.len 1 le if { print-usage-and-exit }

    ArenaGraph:begin

    $mem 41943040 "Main" Arena:new @arena
    &args 1 Array:remove<STR:Str> &arena flip STR:Str-copy-into @path

    $temp-mem 65536 Arena:init-temp
    $alloc-mem 8388608 A:init

    &arena FS:init "Failed to init fs" IO:exit-with-message @fs
 
    mode COMPILE = if {
        M:Modules-new @modules
        ByteArray:new @mem
        &arena "load-modules" ArenaGraph:mark
        &arena &fs &modules &mem $path load-module-recursive
        &arena "R:resolve" ArenaGraph:mark
        &arena &modules R:resolve
        &arena "MEM:process" ArenaGraph:mark
        $mem.len &modules MEM:process @stack-start
        &arena "C:check" ArenaGraph:mark
        &arena &modules C:check
        &arena "Modules-mark-reachable" ArenaGraph:mark
        &modules M:Modules-mark-reachable
        &arena "gather-instances" ArenaGraph:mark
        &arena &modules MONO:gather-instances

        FMT:Formatter-stdout @formatter
        &arena "GEN:generate" ArenaGraph:mark
        &formatter $stack-start &mem &modules GEN:generate
        1 "\n" IO:write-all IO:check
        LOGGING:enabled if { 2 A:report }

        &modules M:Modules-free
    }
    mode PARSE_AST = if {
        &arena parse-ast
    }

    &arena Arena:clear
    ArenaGraph:end
}

fn parse-ast(arena: .Arena:Arena) {
    $arena Arena:save @save
    $arena 0 FS:read-all @code 
    $code 0 /= if {
        2 "Failed to read stdin, Error Code: " IO:write-all IO:check
        2 $code IO:print-to-fd
        1 CORE:exit
    }
    @input

    ByteArray:new @mem
    $arena 
    &mem 
    $arena $input "stdin.watim" STR:Str-new L:lex @tokens
    &tokens P:parse @fields @types @items
    
    FMT:Formatter-stdout @formatter
    &formatter &items DUMP:TopItems-json
    &formatter "\n" FMT:Formatter-write

    $items DynArray:free<.AST:TopItem>
    $types DynArray:free<.AST:Type>
    $fields DynArray:free<AST:Field>
    $arena $save Arena:restore
}

fn load-module-recursive(arena: .Arena:Arena, fs: .FS:FileSystem, modules: .M:Modules, mem: .ByteArray:T, path: STR:Str) {
    LOGGING:enabled if {
        2 "Loading module: " IO:write-all IO:check
        2 $path STR:Str-unpack IO:write-all IO:check
        2 IO:newline
    }
    $arena "loading-module" ArenaGraph:mark
    $arena $fs $path $mem M:Module-load @module
    &module M:Module-imports @imps
    $arena $modules $path $module M:Modules-insert
    
    0 @i
    loop {
        $i $imps AST:Imports-len = if { break }
        $modules $imps $i AST:Imports-get-value .path ~ STR:Str-unpack M:Modules-get if {
            drop
        } else {
            drop
            $arena $fs
            $modules $mem 
            $imps $i AST:Imports-get-value .path ~
            load-module-recursive
        }
        $i 1 + #i
    }
}

fn COMPILE() -> i32 { 1 }
fn PARSE_AST() -> i32 { 2 }

memory MODE: i32 4
fn set-mode(mode: i32) { $MODE $mode store }
fn mode() -> i32 { $MODE ~ }

fn start "_start" () {
    // grow memory to (512 + 256 + 128) * 2B^16 = 56 MiB
    512 256 128 + + mem-grow 1 /= if { 1 CORE:exit } 
    main
}

