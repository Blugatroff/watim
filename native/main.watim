import "../std/alloc.watim" as A
import "../std/args.watim" as ARGS
import "../std/string.watim" as S
import "../std/io.watim" as IO
import "../std/fs.watim" as FS
import "../std/core.watim" as CORE
import "../std/map.watim" as MAP
import "../std/format.watim" as FMT

import "./lexer.watim" as L
import "./ast.watim" as AST
import "./parser.watim" as P
import "./resolver.watim" as R
import "./module.watim" as M
import "./checker.watim" as C
import "./mem.watim" as MEM
import "./wat_gen.watim" as GEN

fn load-module-recursive(modules: .M:Modules, mem: .S:String, path: .S:String) {
    local module: .M:Module
    local imps: .AST:Imports
    local i: i32

    //2 "Loading module: " IO:write-all IO:check
    //2 $path S:String-unpack IO:write-all IO:check
    //2 "\n" IO:write-all IO:check
    $path S:String-unpack $mem M:Module-load #module
    $module M:Module-imports #imps
    $modules $path S:String-unpack S:String-new $module M:Modules-insert
    
    loop {
        $i $imps AST:Imports-len = if { break }
        $modules $imps $i AST:Imports-get-value S:String-unpack M:Modules-get if {
            drop
        } else {
            drop
            $modules $mem $imps $i AST:Imports-get-value load-module-recursive
        }
        $i 1 + #i
    }
}

fn f() {
    memory alloc-mem: i32 10000000 4; // 10 mb
    local args: .S:StringVec
    local mem: .S:String
    local path: .S:String
    local formatter: .FMT:Formatter
    local formatted: .S:String
    local modules: .M:Modules
    local stack-start: i32

    $alloc-mem 10000000 A:init
    FS:init
    ARGS:get-args #args
    S:String-empty #mem
    
    $args 1 S:StringVec-get #path 

    M:Modules-new #modules
    $modules $mem $path load-module-recursive
    $modules R:resolve
    $mem S:String-len $modules MEM:process #stack-start
    $modules C:check

    FMT:Formatter-new #formatter
    $formatter $stack-start $mem $modules GEN:generate
    $formatter FMT:Formatter-into-string #formatted
    1 $formatted S:String-unpack IO:write-all IO:check
    1 "\n" IO:write-all IO:check
    $formatted S:String-free

    $modules M:Modules-free
    $args S:StringVec-free
    $mem S:String-free
    FS:uninit
    A:is-empty not if {
        A:root A:print-alloc-list
        A:report
        2 "MEMORY LEAK DETECTED\n" IO:write-all IO:check
        1 CORE:exit
    }
}

fn main "_start" () {
    1023 mem-grow 1 /= if {
        1 CORE:exit
    }
    f
}

