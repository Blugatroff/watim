import "../std/fmt.watim" as FMT
import "../std/io.watim" as IO
import "../std/core.watim" as CORE
import "../std/util.watim" as U
import "../std/string.watim" as S
import "../std/str.watim" as STR
import "../std/alloc.watim" as A
import "../std/dyn-array.watim" as DynArray
import "../std/array.watim" as Array
import "../std/arena.watim" as Arena

import "./ast.watim" as AST
import "./lexer.watim" as L
import "./module.watim" as M
import "./checker.watim" as CHECKER
import "./logging.watim" as LOGGING
import "./util.watim" as NU

fn generate-type(formatter: .FMT:Formatter, generics: .AST:Types, self: .AST:Type) {
     loop {
        $self AST:Type-ty AST:TYPE_I32 = 
        $self AST:Type-ty AST:TYPE_BOOL = or
        $self AST:Type-ty AST:TYPE_PTR = or
        $self AST:Type-ty AST:TYPE_STRUCT = or
        $self AST:Type-ty AST:TYPE_ARRAY = or
        $self AST:Type-ty AST:TYPE_FUNCTION = or
        if { 
            $formatter "i32" FMT:Formatter-write break
        }
        $self AST:Type-ty AST:TYPE_I64 = if { 
            $formatter "i64" FMT:Formatter-write break 
        }
        $self AST:Type-ty AST:TYPE_GENERIC = if {
            $formatter $generics $generics $self.generic AST:Types-get generate-type break
        }
        2 "invalid Type-ty" IO:write-all IO:check
        1 CORE:exit
    }
}
fn generate-lop(formatter: .FMT:Formatter, generics: .AST:Types, struc-returnals-space-ptr: .i32, locl-copy-space-ptr: .i32, lop: .AST:Words, rets: .AST:Types, current-function-instance-index: i32) {
    $formatter "(block $block " FMT:Formatter-write
    $rets !i32 0 /= if {
        $formatter $generics $rets generate-rets
    }
    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent
    $formatter FMT:Formatter-write-indent
    $formatter "(loop $loop " FMT:Formatter-write
    $rets !i32 0 /= if {
        $formatter $generics $rets generate-rets
    }
    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent
    $formatter $generics $struc-returnals-space-ptr $locl-copy-space-ptr $lop $current-function-instance-index generate-words
    $formatter FMT:Formatter-write-indent
    $formatter "br $loop\n" FMT:Formatter-write
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter ")\n" FMT:Formatter-write
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter ")\n" FMT:Formatter-write
}
fn generate-block(formatter: .FMT:Formatter, generics: .AST:Types, struc-returnals-space-ptr: .i32, locl-copy-space-ptr: .i32, lop: .AST:Words, rets: .AST:Types, current-function-instance-index: i32) {
    $formatter "(block $block " FMT:Formatter-write
    $rets !i32 0 /= if {
        $formatter $generics $rets generate-rets
    }
    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent
    $formatter $generics $struc-returnals-space-ptr $locl-copy-space-ptr $lop $current-function-instance-index generate-words
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter ")\n" FMT:Formatter-write
}
fn generate-word(formatter: .FMT:Formatter, generics: .AST:Types, struc-returnals-space-ptr: .i32, locl-copy-space-ptr: .i32, self: .AST:Word, current-function-instance-index: i32) {
    loop {
        $self.ty AST:WORD_NUMBER = if {
            $formatter "i32.const " FMT:Formatter-write
            $self.number $formatter U:i32-format
            $formatter "\n" FMT:Formatter-write
            break
        }
        $self.ty AST:WORD_STRING = if {
            $formatter "i32.const " FMT:Formatter-write
            $self.addr $formatter U:i32-format
            $formatter " i32.const " FMT:Formatter-write
            $self.size $formatter U:i32-format
            $formatter "\n" FMT:Formatter-write
            break
        }
        $self.ty AST:WORD_CALL = if {
            $formatter $generics $struc-returnals-space-ptr $self $current-function-instance-index generate-call break
        }
        $self.ty AST:WORD_GET_GLOBAL = if {
            $formatter "global.get $" FMT:Formatter-write
            $self AST:Word-module $formatter U:i32-format
            $formatter ":" FMT:Formatter-write
            $formatter $self AST:Word-ident ~ STR:Str-unpack FMT:Formatter-write
            $formatter "\n" FMT:Formatter-write
            break
        }
        $self.ty AST:WORD_LOOP = if {
            $formatter $generics $struc-returnals-space-ptr $locl-copy-space-ptr $self.lop.body $self.lop.rets $current-function-instance-index generate-lop
            break
        }
        $self.ty AST:WORD_BLOCK = if {
            $formatter $generics $struc-returnals-space-ptr $locl-copy-space-ptr $self.blok.body $self.blok.rets $current-function-instance-index generate-block
            break
        }
        $self.ty AST:WORD_BREAK = if {
            $formatter "br $block\n" FMT:Formatter-write
            break    
        }
        $self.ty AST:WORD_IF = if {
            $formatter $generics $struc-returnals-space-ptr $locl-copy-space-ptr $self AST:Word-iff $current-function-instance-index generate-iff
            break
        }
        $self.ty AST:WORD_INTRINSIC = if {
            $formatter $generics $self generate-intrinsic break
        }
        $self.ty AST:WORD_CAST = if {
            $self.type AST:Type-ty AST:TYPE_I64 =
            $self.src-type AST:Type-ty AST:TYPE_I32 = 
            $self.src-type AST:Type-ty AST:TYPE_BOOL = or and
            if {
                $formatter "i64.extend_i32_s\n" FMT:Formatter-write break
            }
            $self.type AST:Type-ty AST:TYPE_I32 =
            $self.type AST:Type-ty AST:TYPE_BOOL = or
            $self.src-type AST:Type-ty AST:TYPE_I64 = and
            if {
                $formatter "i32.wrap_i64\n" FMT:Formatter-write break
            }
            $formatter ";; CAST from " FMT:Formatter-write
            $formatter $self.src-type AST:Type-format
            $formatter " to " FMT:Formatter-write
            $formatter $self.type AST:Type-format
            $formatter "\n" FMT:Formatter-write
            break
        }
        $self.ty AST:WORD_DEREF = if {
            $formatter $generics $self generate-deref break
        }
        $self.ty AST:WORD_SET = 
        $self.ty AST:WORD_INIT_LOCAL = or if {
            $formatter $generics $self generate-set break
        }
        $self.ty AST:WORD_GET_REF = if {
            $formatter $generics $self generate-get-ref
            break
        }
        $self.ty AST:WORD_GET_LOCAL = if {
            $formatter $self $generics $locl-copy-space-ptr generate-get
            break
        }
        $self.ty AST:WORD_LOAD = if {
            $formatter $generics $self.type $locl-copy-space-ptr generate-load 
            break
        }
        $self.ty AST:WORD_SIZEOF = if {
            $formatter "i32.const " FMT:Formatter-write
            $self.type $generics AST:Type-size $formatter U:i32-format
            $formatter "\n" FMT:Formatter-write
            break
        }
        $self.ty AST:WORD_STORE = 
        $self.ty AST:WORD_STORE_GLOBAL = or if {
            $formatter $generics $self generate-store-word break
        }
        $self.ty AST:WORD_ANNOTATION = if {
            $formatter ";; ::" FMT:Formatter-write
            $formatter $self.type AST:Type-format
            $formatter "\n" FMT:Formatter-write
            break
        }
        $self.ty AST:WORD_ARRAY_WRITE = if {
            $formatter $generics $self generate-array-write break
        }
        $self.ty AST:WORD_ARRAY_READ = if {
            $formatter $generics $self $locl-copy-space-ptr generate-array-read break
        }
        $self.ty AST:WORD_ARRAY_REF = if {
            $formatter $generics $self generate-array-ref break
        }
        $self.ty AST:WORD_ARRAY_INIT = if {
            $formatter $self $generics $locl-copy-space-ptr generate-array-init break
        }
        $self.ty AST:WORD_REF_FUNCTION = if {
            $formatter $self generate-ref-function break
        }
        $self.ty AST:WORD_CALL_INDIRECT = if {
            $formatter $generics $self generate-call-indirect break
        }
        $formatter $self.ty AST:word-ty-name FMT:Formatter-write
        break
    } 
}
fn generate-call-indirect(formatter: .FMT:Formatter, generics: .AST:Types, word: .AST:Word) {
    $formatter "(call_indirect " FMT:Formatter-write
    $word.type.function.args @args
    0 @i
    loop {
        $i $args AST:Types-len = if { break }
        $formatter "(param " FMT:Formatter-write
        $formatter $generics $args $i AST:Types-get generate-type
        $formatter ") " FMT:Formatter-write
        $i 1 + #i
    }
    $word.type.function.rets @rets
    0 #i
    loop {
        $i $rets AST:Types-len = if { break }
        $formatter "(result " FMT:Formatter-write
        $formatter $generics $rets $i AST:Types-get generate-type
        $formatter ") " FMT:Formatter-write
        $i 1 + #i
    }
    $formatter ")\n" FMT:Formatter-write
}
fn generate-ref-function(formatter: .FMT:Formatter, word: .AST:Word) {
    $formatter "i32.const " FMT:Formatter-write
    $word.function.table-index $formatter U:i32-format
    $formatter "\n" FMT:Formatter-write
}
fn generate-load(formatter: .FMT:Formatter, generics: .AST:Types, type: .AST:Type, locl-copy-space-ptr: .i32) {
    $type AST:Type-ty AST:TYPE_STRUCT = if {
        $formatter $type $generics $locl-copy-space-ptr generate-load-struc
        $formatter "\n" FMT:Formatter-write
    } else {
        $formatter $generics $type generate-type
        $formatter ".load" FMT:Formatter-write
        $formatter "\n" FMT:Formatter-write
    }
}
fn generate-array-init(formatter: .FMT:Formatter, word: .AST:Word, generics: .AST:Types, locl-copy-space-ptr: .i32) {
    $formatter "local.get $locl-copy-spac:e i32.const " FMT:Formatter-write
    $locl-copy-space-ptr ~ $formatter U:i32-format
    $locl-copy-space-ptr ~ $word.type $generics AST:Type-size + =>locl-copy-space-ptr
    $formatter " i32.add\n" FMT:Formatter-write
    $word.size @size
    $size 1 - @i
    loop {
        $size 0 = if { break }
        $formatter FMT:Formatter-write-indent
        $formatter "call $intrinsic:dupi32 i32.const " FMT:Formatter-write
        $word.type.child $generics AST:Type-size $i * $formatter U:i32-format
        $formatter " i32.add call $intrinsic:rotate-left " FMT:Formatter-write
        $formatter $generics $word.type.child generate-store

        $i 0 = if { break }
        $i 1 - #i
    }
}
fn generate-array-write(formatter: .FMT:Formatter, generics: .AST:Types, word: .AST:Word) {
    $formatter "call $intrinsic:rotate-right" FMT:Formatter-write
    $formatter " i32.const " FMT:Formatter-write
    $word.type $generics AST:Type-size $formatter U:i32-format
    $formatter " i32.mul " FMT:Formatter-write
    $formatter " i32.add " FMT:Formatter-write
    $formatter "call $intrinsic:flip " FMT:Formatter-write
    $formatter $generics $word.type generate-store
}
fn generate-array-read(formatter: .FMT:Formatter, generics: .AST:Types, word: .AST:Word, locl-copy-space-ptr: .i32) {
    $formatter $generics $word generate-array-ref
    $formatter $generics $word.type $locl-copy-space-ptr generate-load
}
fn generate-array-ref(formatter: .FMT:Formatter, generics: .AST:Types, word: .AST:Word) {
    $formatter "i32.const " FMT:Formatter-write
    $word.type $generics AST:Type-size $formatter U:i32-format
    $formatter " i32.mul" FMT:Formatter-write
    $formatter " i32.add " FMT:Formatter-write
}
fn generate-load-struc(formatter: .FMT:Formatter, type: .AST:Type, generics: .AST:Types, locl-copy-space-ptr: .i32) { 
    $formatter "local.get $locl-copy-spac:e i32.const " FMT:Formatter-write
    $locl-copy-space-ptr ~ $formatter U:i32-format
    $locl-copy-space-ptr ~ $type $generics AST:Type-size + =>locl-copy-space-ptr 
    $formatter " i32.add call $intrinsic:dupi32 call $intrinsic:rotate-left i32.const " FMT:Formatter-write
    $type $generics AST:Type-size $formatter U:i32-format
    $formatter " memory.copy" FMT:Formatter-write
}
fn generate-deref(formatter: .FMT:Formatter, generics: .AST:Types, word: .AST:Word) {
    $generics $word determine-loads @loads
    0 @i
    loop {
        $i $loads.len = if { break }
        &loads $i DynArray:get<i32> ~ @offset

        $i 1 + $loads.len = if {
            $formatter " i32.const " FMT:Formatter-write
            $offset $formatter U:i32-format
            $formatter " i32.add" FMT:Formatter-write
        } else {
            $formatter " i32.load offset=" FMT:Formatter-write
            $offset $formatter U:i32-format
        }
        $i 1 + #i
    }
    $formatter "\n" FMT:Formatter-write
    $loads DynArray:free<i32>
}
fn generate-get-ref(formatter: .FMT:Formatter, generics: .AST:Types, word: .AST:Word) {
    $formatter "local.get $" FMT:Formatter-write
    $word.scope-id 0 /= if { $word.scope-id $formatter U:i32-format $formatter ":" FMT:Formatter-write }
    $formatter $word AST:Word-ident ~ STR:Str-unpack FMT:Formatter-write
    $word.shadow-id 0 /= if { $word.shadow-id $formatter U:i32-format }
    $formatter " " FMT:Formatter-write

    $generics $word determine-loads @loads

    0 @i
    loop {
        $i $loads.len = if { break }
        &loads $i DynArray:get<i32> ~ @offset

        $i 1 + $loads.len = if {
            $formatter " i32.const " FMT:Formatter-write
            $offset $formatter U:i32-format
            $formatter " i32.add" FMT:Formatter-write
        } else {
            $formatter " i32.load offset=" FMT:Formatter-write
            $offset $formatter U:i32-format
        }
        $i 1 + #i
    }
    $formatter "\n" FMT:Formatter-write
    $loads DynArray:free<i32>
}
fn determine-loads(generics: .AST:Types, word: .AST:Word) -> DynArray:DynArray<i32> {
    $word.src-type @type
    0!(i32 ->) DynArray:new<i32> @loads
    0 @i
    loop {
        $i $word.fields.len = if { break }
        $i 0 = 
        $type AST:Type-ty AST:TYPE_STRUCT =
        and
        $type AST:Type-ty AST:TYPE_PTR = if { $type AST:Type-child AST:Type-ty AST:TYPE_STRUCT = } else { 0 1 = }
        or
        if {
            0 @offset
            loop { // loop for every field access which can be reduced to one load with offset
                $i $word.fields.len = if { break }
                &word.fields $i Array:get<.L:Token> ~ @field

                $type AST:Type-ty AST:TYPE_PTR = if {
                    $type AST:Type-child #type
                }
                $type AST:Type-struc @struc
                $struc $field L:Token-lexeme ~ STR:Str-unpack $generics AST:Struct-find-field-with-offset not if {
                    $field L:Token-location "field not found" NU:abort-with-location
                }
                $offset + #offset
                AST:Field-type #type
                $i 1 + #i
                $type AST:Type-ty AST:TYPE_STRUCT /= if {
                    break
                }
            }
            &loads $offset DynArray:push<i32>
        } else {

            2 $word.token L:Token-location L:print-location
            // this case should already be catched in the checker
            0 0 / drop
        }
    }
    $loads
}
fn generate-store-word(formatter: .FMT:Formatter, generics: .AST:Types, word: .AST:Word) {
    $word AST:Word-ty AST:WORD_STORE_GLOBAL = if {
        $formatter "global.get $" FMT:Formatter-write
        $word AST:Word-module $formatter U:i32-format
        $formatter ":" FMT:Formatter-write
        $formatter $word AST:Word-ident ~ STR:Str-unpack FMT:Formatter-write
    } else {
        $formatter "local.get $" FMT:Formatter-write
        $word.scope-id 0 /= if { $word.scope-id $formatter U:i32-format $formatter ":" FMT:Formatter-write }
        $formatter $word AST:Word-ident ~ STR:Str-unpack FMT:Formatter-write
        $word.shadow-id 0 /= if {
            $word.shadow-id $formatter U:i32-format
        }
    }

    $generics $word determine-loads @loads

    $formatter " " FMT:Formatter-write
    0 @i
    loop {
        $i $loads.len = if { break }
        &loads $i DynArray:get<i32> ~ @offset

        $formatter " i32.load offset=" FMT:Formatter-write
        $offset $formatter U:i32-format
        $i 1 + #i
    }
    $formatter " call $intrinsic:flip " FMT:Formatter-write
    $word.type AST:Type-ty AST:TYPE_STRUCT = if {
        $formatter " i32.const " FMT:Formatter-write
        $word.type $generics AST:Type-size $formatter U:i32-format
        $formatter " memory.copy" FMT:Formatter-write
    } else {
        $formatter $generics $word.type generate-type
        $formatter ".store" FMT:Formatter-write
    }
    $formatter "\n" FMT:Formatter-write

    $loads DynArray:free<i32>
}

fn generate-get(formatter: .FMT:Formatter, word: .AST:Word, generics: .AST:Types, locl-copy-space-ptr: .i32) {
    $word.type AST:Type-ty AST:TYPE_STRUCT = if {
        $formatter "local.get $locl-copy-spac:e i32.const " FMT:Formatter-write
        $locl-copy-space-ptr ~ $formatter U:i32-format
        $formatter " i32.add call $intrinsic:dupi32 " FMT:Formatter-write
        $locl-copy-space-ptr ~ $word.type $generics AST:Type-size + =>locl-copy-space-ptr 
    }
    $formatter "local.get $" FMT:Formatter-write
    $word.scope-id 0 /= if { $word.scope-id $formatter U:i32-format $formatter ":" FMT:Formatter-write }
    $formatter $word AST:Word-ident ~ STR:Str-unpack FMT:Formatter-write
    $word.shadow-id 0 /= if { $word.shadow-id $formatter U:i32-format }
    $formatter " " FMT:Formatter-write

    $generics $word determine-loads @loads

    $loads.len 0 = if {
        $word.type AST:Type-ty AST:TYPE_STRUCT = if {
            $formatter " i32.const " FMT:Formatter-write
            $word.type $generics AST:Type-size $formatter U:i32-format
            $formatter " memory.copy" FMT:Formatter-write
        }
    }

    0 @i
    loop {
        $i $loads.len = if { break }
        &loads $i DynArray:get<i32> ~ @offset

        $loads.len $i 1 + lt
        $word.type AST:Type-ty AST:TYPE_STRUCT /= 
        or if {
            $formatter "i32.load offset=" FMT:Formatter-write
            $offset $formatter U:i32-format
            $formatter " " FMT:Formatter-write
        } else {
            $formatter " i32.const " FMT:Formatter-write
            $offset $formatter U:i32-format
            $formatter " i32.add i32.const " FMT:Formatter-write
            $word.type $generics AST:Type-size $formatter U:i32-format
            $formatter " memory.copy" FMT:Formatter-write
        }
        $i 1 + #i
    }
    $formatter "\n" FMT:Formatter-write

    $loads DynArray:free<i32>
}
fn generate-call(formatter: .FMT:Formatter, generics: .AST:Types, struc-returnals-space-ptr: .i32, word: .AST:Word, current-function-instance-index: i32) {
    local i: i32
    local rets: .AST:Types
    local type: .AST:Type
    local rets-structs: bool
    local struc-size: i32
    $formatter "call $" FMT:Formatter-write
    $word AST:Word-module $formatter U:i32-format
    $formatter ":" FMT:Formatter-write
    $word.recursive-call if { $current-function-instance-index } else { $word.instance-index } @instance-index
    $instance-index 0 /= if {
        $instance-index $formatter U:i32-format
        $formatter ":" FMT:Formatter-write
    }
    $formatter $word AST:Word-ident ~ STR:Str-unpack FMT:Formatter-write
    $formatter "\n" FMT:Formatter-write
    $word AST:Word-rets #rets
    loop {
        $i $rets AST:Types-len = if { 0 1 = break }
        $rets $i AST:Types-get #type
        $type AST:Type-ty AST:TYPE_STRUCT = if {
            1 1 = break
        }
        $i 1 + #i
    } if {
        0 #i
        loop {
            $i $rets AST:Types-len = if { break }
            $formatter FMT:Formatter-write-indent
            $formatter "local.set $s" FMT:Formatter-write
            $i $formatter U:i32-format
            $formatter ":a\n" FMT:Formatter-write

            $i 1 + #i
        }
        0 #i
        $rets AST:Types-len  #i
        loop {
            $i 0 = if { break }
            $rets $rets AST:Types-len $i - AST:Types-get #type
            $formatter FMT:Formatter-write-indent
            $type AST:Type-ty AST:TYPE_STRUCT = if {
                $formatter "local.get $struc-returnals-spac:e i32.const " FMT:Formatter-write
                $struc-returnals-space-ptr ~ $formatter U:i32-format
                $formatter " i32.add call $intrinsic:dupi32 local.get $s" FMT:Formatter-write
                $i 1 - $formatter U:i32-format
                $formatter ":a " FMT:Formatter-write
                $formatter " i32.const " FMT:Formatter-write
                $type AST:Type-struc $generics AST:Struct-size #struc-size
                $struc-size $formatter U:i32-format
                $formatter " memory.copy\n" FMT:Formatter-write
                $struc-returnals-space-ptr ~ $struc-size + =>struc-returnals-space-ptr 
            } else {
                $formatter "local.get $s" FMT:Formatter-write
                $i 1 - $formatter U:i32-format
                $formatter ":a\n" FMT:Formatter-write
            }
            $i 1 - #i
        }
    }
}
fn generate-set(formatter: .FMT:Formatter, generics: .AST:Types, word: .AST:Word) {
    $word AST:Word-ty AST:WORD_INIT_LOCAL = if { 0!(i32 ->) DynArray:new<i32> } else { $generics $word determine-loads } @loads
    // TODO: this can be simplified
    $word.type AST:Type-ty AST:TYPE_STRUCT = if {
        $formatter "local.get $" FMT:Formatter-write
        $word.scope-id 0 /= if { $word.scope-id $formatter U:i32-format $formatter ":" FMT:Formatter-write }
        $formatter $word AST:Word-ident ~ STR:Str-unpack FMT:Formatter-write
        $word.shadow-id 0 /= if { $word.shadow-id $formatter U:i32-format }
        $loads.len 0 gt if {
            $word.shadow-id 0 /= if { $word.shadow-id $formatter U:i32-format }
            0 @i
            loop {
                $loads.len $i = if { break }
                $formatter " i32.const " FMT:Formatter-write
                &loads $i DynArray:get<i32> ~ $formatter U:i32-format
                $formatter " i32.add " FMT:Formatter-write
                $i 1 + $loads.len = if {
                    $formatter " call $intrinsic:flip i32.const " FMT:Formatter-write
                    $word.type $generics AST:Type-size $formatter U:i32-format
                    $formatter " memory.copy" FMT:Formatter-write
                } else {
                    $formatter "i32.load" FMT:Formatter-write
                }
                $i 1 + #i
            }
        } else {
            $formatter " call $intrinsic:flip i32.const " FMT:Formatter-write
            $word.type $generics AST:Type-size $formatter U:i32-format
            $formatter " memory.copy" FMT:Formatter-write
        }
    } else {
        $loads.len 0 gt if {
            $formatter "local.get $" FMT:Formatter-write
            $word.scope-id 0 /= if { $word.scope-id $formatter U:i32-format $formatter ":" FMT:Formatter-write }
            $formatter $word AST:Word-ident ~ STR:Str-unpack FMT:Formatter-write
            $word.shadow-id 0 /= if { $word.shadow-id $formatter U:i32-format }
            0 @i
            loop {
                $loads.len $i = if { break }
                $formatter " i32.const " FMT:Formatter-write
                &loads $i DynArray:get<i32> ~ $formatter U:i32-format
                $formatter " i32.add " FMT:Formatter-write
                $i 1 + $loads.len = if {
                    $formatter " call $intrinsic:flip " FMT:Formatter-write
                    $formatter $generics $word.type generate-type
                    $formatter ".store" FMT:Formatter-write
                } else {
                    $formatter "i32.load" FMT:Formatter-write
                }
                $i 1 + #i
            }
        } else {
            $formatter "local.set $" FMT:Formatter-write
            $word.scope-id 0 /= if { $word.scope-id $formatter U:i32-format $formatter ":" FMT:Formatter-write }
            $formatter $word AST:Word-ident ~ STR:Str-unpack FMT:Formatter-write
            $word.shadow-id 0 /= if { $word.shadow-id $formatter U:i32-format }
        }
    }
    $formatter "\n" FMT:Formatter-write
    $loads DynArray:free<i32>
}
fn generate-store(formatter: .FMT:Formatter, generics: .AST:Types, type: .AST:Type) {
    $type AST:Type-ty AST:TYPE_STRUCT =
    $type $generics AST:Type-size 4 /= and if {
        $formatter "i32.const " FMT:Formatter-write
        $type $generics AST:Type-size $formatter U:i32-format
        $formatter " memory.copy" FMT:Formatter-write
    } else {
        // TODO: this crashes:
        // $formatter "i32.store" FMT:Formatter-write break
        $formatter "i32.store" FMT:Formatter-write
    }
    $formatter "\n" FMT:Formatter-write
}
fn generate-intrinsic(formatter: .FMT:Formatter, generics: .AST:Types, word: .AST:Word) {
    loop {
        $word.intrinsic AST:INTRINSIC_ADD = if {
            $formatter "i32.add" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_SUB = if {
            $formatter "i32.sub" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_EQ = if {
            $formatter "i32.eq" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_DROP = if {
            $formatter "drop" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_NOT = if {
            $word.type AST:Type-ty AST:TYPE_BOOL = if {
                $formatter "i32.const 1 i32.and i32.const 1 i32.xor i32.const 1 i32.and" FMT:Formatter-write
            } else {
                $formatter "i32.const -1 i32.xor" FMT:Formatter-write
            }
            break
        }
        $word.intrinsic AST:INTRINSIC_MEM_GROW = if {
            $formatter "memory.grow" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_NOT_EQ = if {
            $formatter "i32.ne" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_STORE = if {
            $formatter $generics $word.type generate-store break
        }
        $word.intrinsic AST:INTRINSIC_GREATER_EQ = if {
            $formatter "i32.ge_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_AND = if {
            $formatter "i32.and" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_GREATER = if {
            $formatter "i32.gt_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_STORE8 = if {
            $formatter "i32.store8" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_FLIP = if {
            $formatter "call $intrinsic:flip" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_MOD = if {
            $formatter "i32.rem_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_DIV = if {
            $formatter "i32.div_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_LOAD8 = if {
            $formatter "i32.load8_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_LESS = if {
            $formatter "i32.lt_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_MUL = if {
            $formatter "i32.mul" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_MEM_COPY = if {
            $formatter "memory.copy" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_LESS_EQ = if {
            $formatter "i32.le_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_ROTR = if {
            $formatter "i32.rotr" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_ROTL = if {
            $word.type AST:Type-ty AST:TYPE_I32 = if {
                $formatter "i32.rotl" FMT:Formatter-write break
            }
            $word.type AST:Type-ty AST:TYPE_I64 = if {
                $formatter "i64.extend_i32_s i64.rotl" FMT:Formatter-write break
            }
            2 "Unexpected type in INTRINSIC_ROTL" IO:write-all IO:check
            1 CORE:exit
        }
        $word.intrinsic AST:INTRINSIC_OR = if {
            $word.type !i32 0 /= if {
                $formatter $generics $word.type generate-type
                $formatter ".or" FMT:Formatter-write break
            } else {
                $formatter "i32.or" FMT:Formatter-write break
            }
        }
        2 "unhandled intrinsic in wat_gen " IO:write-all IO:check
        2 $word.intrinsic AST:intrinsic-name IO:write-all IO:check
        1 CORE:exit
        break
    }
    $formatter "\n" FMT:Formatter-write
}
fn generate-iff-params(formatter: .FMT:Formatter, generics: .AST:Types, params: .AST:Types) {
    0 @i
    loop {
        $i $params AST:Types-len = if { break }
        $formatter "(param " FMT:Formatter-write
        $formatter $generics $params $i AST:Types-get generate-type
        $formatter ")\n" FMT:Formatter-write
        $i 1 + #i
    }
}
fn generate-iff(formatter: .FMT:Formatter, generics: .AST:Types, struc-returnals-space-ptr: .i32, locl-copy-space-ptr: .i32, iff: .AST:If, current-function-instance-index: i32) {
    $formatter "(if " FMT:Formatter-write
    $formatter $generics $iff AST:If-params generate-iff-params
    $formatter $generics $iff.rets generate-rets
    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent
    $formatter FMT:Formatter-write-indent
    $formatter "(then\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent
    $formatter $generics $struc-returnals-space-ptr $locl-copy-space-ptr $iff AST:If-body $current-function-instance-index generate-words 
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter ")" FMT:Formatter-write
    $iff.has-el if {
        $formatter " (else\n" FMT:Formatter-write
        $formatter FMT:Formatter-indent
        $formatter $generics $struc-returnals-space-ptr $locl-copy-space-ptr $iff AST:If-el $current-function-instance-index generate-words
        $formatter FMT:Formatter-dedent
        $formatter FMT:Formatter-write-indent
        $formatter ")" FMT:Formatter-write
    }
    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter ")\n" FMT:Formatter-write
}
fn generate-param(formatter: .FMT:Formatter, generics: .AST:Types, param: .AST:Local) {
    $formatter "(param $" FMT:Formatter-write
    $formatter $param AST:Local-ident L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
    $formatter " " FMT:Formatter-write
    $param AST:Local-type @type 
    $formatter $generics $type generate-type
    $formatter ")" FMT:Formatter-write
}
fn generate-params(formatter: .FMT:Formatter, params: .AST:Locals, generics: .AST:Types) {
    local i: i32
    local locl: .AST:Local
    loop {
        $i $params AST:Locals-len = if { break }
        $params $i AST:Locals-get #locl
        $locl AST:Local-ty AST:LOCAL_ARGUMENT = if {
            $formatter $generics $locl generate-param
            $i 1 + $params AST:Locals-len lt if { 
                $formatter " " FMT:Formatter-write
            }
        }
        $i 1 + #i
    }
}
fn generate-ret(formatter: .FMT:Formatter, generics: .AST:Types, ret: .AST:Type) {
    $formatter "(result " FMT:Formatter-write
    $formatter $generics $ret generate-type
    $formatter ")" FMT:Formatter-write
}
fn generate-rets(formatter: .FMT:Formatter, generics: .AST:Types, rets: .AST:Types) {
    local i: i32
    loop {
        $i $rets AST:Types-len = if { break }
        $formatter $generics $rets $i AST:Types-get generate-ret
        $i 1 + $rets AST:Types-len lt if {
            $formatter " " FMT:Formatter-write
        }
        $i 1 + #i
    }
}
fn generate-signature(formatter: .FMT:Formatter, module: i32, ident: .L:Token, qualifier: .L:Token, locals: .AST:Locals, rets: .AST:Types, generics: .AST:Types, instance-index: i32) {
    $formatter "func $" FMT:Formatter-write
    $module $formatter U:i32-format
    $instance-index 0 /= if {
        $formatter ":" FMT:Formatter-write
        $instance-index $formatter U:i32-format
    }
    $formatter ":" FMT:Formatter-write
    $formatter $ident L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
    $formatter " " FMT:Formatter-write
    $qualifier !i32 0 /= if {
        $formatter "(export " FMT:Formatter-write
        $formatter $qualifier L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
        $formatter ")" FMT:Formatter-write
    }
    $formatter $locals $generics generate-params
    $formatter " " FMT:Formatter-write
    $formatter $generics $rets generate-rets
}

fn generate-ext(formatter: .FMT:Formatter, module: i32, ext: .AST:Extern) {
    $formatter FMT:Formatter-write-indent
    $formatter "(import " FMT:Formatter-write
    $formatter $ext AST:Extern-module L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
    $formatter " " FMT:Formatter-write
    $formatter $ext AST:Extern-name L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
    $formatter " (" FMT:Formatter-write
    0 !.AST:Types @generics
    $formatter $module $ext AST:Extern-ident 0 !.L:Token $ext AST:Extern-parameters $ext AST:Extern-rets $generics 0 generate-signature
    $formatter "))\n" FMT:Formatter-write
}

fn generate-externs(formatter: .FMT:Formatter, modules: .M:Modules) {
    0 @i
    loop {
        $i $modules M:Modules-len = if { break }
        $modules $i M:Modules-get-value @module
        0 @j
        loop {
            $j $module M:Module-items.len ~ = if { break }
            $module M:Module-items $j DynArray:get<.AST:TopItem> ~ @item
            $item AST:TopItem-ty AST:TOP_ITEM_EXT = if {
                $item AST:TopItem-ext @top-item
                $top-item.reachable if {
                    $formatter $i $item AST:TopItem-ext generate-ext
                }
            }
            $j 1 + #j
        }
        $i 1 + #i
    }
}

fn generate-global-mem(formatter: .FMT:Formatter, module: i32, statics-len: i32, mem: .AST:Local) {
    $formatter FMT:Formatter-write-indent
    $formatter "(global $" FMT:Formatter-write
    $module $formatter U:i32-format
    $formatter ":" FMT:Formatter-write
    $formatter $mem.ident L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
    $formatter " (mut i32) (i32.const " FMT:Formatter-write
    $mem.address $formatter U:i32-format
    $formatter "))\n" FMT:Formatter-write
}

fn generate-global-mems(formatter: .FMT:Formatter, statics-len: i32, modules: .M:Modules) {
    0 @i
    loop {
        $i $modules M:Modules-len = if { break }
        $modules $i M:Modules-get-value @module
        0 @j
        loop {
            $j $module M:Module-items.len ~ = if { break }
            $module M:Module-items $j DynArray:get<.AST:TopItem> ~ @item
            $item AST:TopItem-ty AST:TOP_ITEM_MEM = if {
                $formatter $i $statics-len $item.mem generate-global-mem
            }
            $j 1 + #j
        }
        $i 1 + #i
    }
}
fn generate-static-mem(formatter: .FMT:Formatter, mem: .S:String) {
    memory buf: i32 4
    local i: i32
    $formatter FMT:Formatter-write-indent
    $formatter "(data (i32.const 0) \"" FMT:Formatter-write
    loop {
        $mem S:String-len $i = if { break }
        $formatter $mem S:String-unpack drop $i + load8 $buf CORE:escape
        $buf flip FMT:Formatter-write
        $i 1 + #i
    }
    $formatter "\")" FMT:Formatter-write
}

fn generate-words(formatter: .FMT:Formatter, generics: .AST:Types, struc-returnals-space-ptr: .i32, locl-copy-space-ptr: .i32, words: .AST:Words, current-function-instance-index: i32) {
    local i: i32 
    loop {
        $i $words AST:Words-len = if { break }
        $formatter FMT:Formatter-write-indent
        $formatter $generics $struc-returnals-space-ptr $locl-copy-space-ptr $words $i AST:Words-get $current-function-instance-index generate-word
        $i 1 + #i
    }
}

fn generate-locl(formatter: .FMT:Formatter, generics: .AST:Types, locl: .AST:Local) {
    $formatter FMT:Formatter-write-indent
    $formatter "(local $" FMT:Formatter-write
    $locl.scope-id 0 /= if { $locl.scope-id $formatter U:i32-format $formatter ":" FMT:Formatter-write }
    $formatter $locl AST:Local-ident L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
    $locl.shadow-id 0 /= if { $locl.shadow-id $formatter U:i32-format }
    $formatter " " FMT:Formatter-write
    
    $formatter $generics $locl AST:Local-type generate-type

    $formatter ")" FMT:Formatter-write
    $locl AST:Local-type AST:Type-ty AST:TYPE_STRUCT = if {
        $formatter " ;; " FMT:Formatter-write
        $formatter $locl AST:Local-type AST:Type-format
    }
    $locl AST:Local-type AST:Type-ty AST:TYPE_ARRAY = if {
        $formatter " ;; array" FMT:Formatter-write
    }
    $locl AST:Local-type AST:Type-ty AST:TYPE_GENERIC = if {
        $formatter " ;; " FMT:Formatter-write
        $formatter $locl AST:Local-type AST:Type-format
    }
    $formatter "\n" FMT:Formatter-write
}

fn generate-word-locals(formatter: .FMT:Formatter, generics: .AST:Types, words: .AST:Words) {
    local i: i32
    local word: .AST:Word
    local iff: .AST:If
    loop {
        $i $words AST:Words-len = if { break }
        $words $i AST:Words-get #word
        $word AST:Word-ty AST:WORD_IF = if {
            $word AST:Word-iff #iff
            $formatter $generics 
            &iff.locals generate-locals
            $formatter $generics $word AST:Word-iff AST:If-body generate-word-locals
            $iff.has-el if {
                $formatter $generics $word AST:Word-iff AST:If-el generate-word-locals 
            }
        }
        $word AST:Word-ty AST:WORD_LOOP = if {
            $formatter $generics &word.lop.locals generate-locals
            $formatter $generics $word.lop.body generate-word-locals
        }
        $word AST:Word-ty AST:WORD_BLOCK = if {
            $formatter $generics &word.blok.locals generate-locals
            $formatter $generics $word.blok.body generate-word-locals
        }
        $i 1 + #i
    }
}
fn generate-locals(formatter: .FMT:Formatter, generics: .AST:Types, locals: .AST:Locals) {
    local i: i32
    local locl: .AST:Local
    loop {
        $locals AST:Locals-len $i = if { break }
        $locals $i AST:Locals-get #locl
        $locl AST:Local-ty AST:LOCAL_LOCAL = if {
            $formatter $generics $locl generate-locl
        }
        $i 1 + #i
    }
}
fn generate-mem(formatter: .FMT:Formatter, size: i32, ident-ptr: .i32, ident-len: i32, scope-id: i32, shadow-id: i32) {
    $formatter "global.get $stac:k global.get $stac:k i32.const " FMT:Formatter-write
    $size 4 CORE:align-to $formatter U:i32-format
    $formatter " i32.add global.set $stac:k local.set $" FMT:Formatter-write

    $scope-id 0 /= if { $scope-id $formatter U:i32-format $formatter ":" FMT:Formatter-write }
    $formatter $ident-ptr $ident-len FMT:Formatter-write
    $shadow-id 0 /= if { $shadow-id $formatter U:i32-format }
}
fn generate-strucs(formatter: .FMT:Formatter, generics: .AST:Types, locals: .AST:Locals) {
    local i: i32
    local locl: .AST:Local
    loop {
        $i $locals AST:Locals-len = if { break }
        $locals $i AST:Locals-get #locl
        $locl AST:Local-ty AST:LOCAL_LOCAL = if {
            $locl AST:Local-type AST:Type-ty AST:TYPE_STRUCT = if {
                0!.Arena:Arena Arena:temp @arena @save
                $arena AST:Types-new @resolved-generics
                0 @i
                loop {
                    $locl.type.generics AST:Types-len $i = if { break }
                    $locl.type.generics $i AST:Types-get @type
                    $type AST:Type-ty AST:TYPE_GENERIC = if {
                        $generics $type.generic AST:Types-get @resolved-generic
                        $arena $resolved-generics $resolved-generic AST:Types-push
                    } else {
                        $arena $resolved-generics $type AST:Types-push
                    }
                    $i 1 + #i
                }

                $formatter FMT:Formatter-write-indent
                $formatter 
                $locl AST:Local-type AST:Type-struc $resolved-generics AST:Struct-size
                $locl AST:Local-ident L:Token-lexeme ~ STR:Str-unpack
                $locl.scope-id
                $locl.shadow-id
                generate-mem
                $formatter "\n" FMT:Formatter-write

                $arena $save Arena:restore
            }
            $locl AST:Local-type AST:Type-ty AST:TYPE_ARRAY = if {
                $formatter FMT:Formatter-write-indent
                $formatter 
                $locl AST:Local-type $generics AST:Type-size
                $locl AST:Local-ident L:Token-lexeme ~ STR:Str-unpack
                $locl.scope-id
                $locl.shadow-id
                generate-mem
                $formatter "\n" FMT:Formatter-write
            }
            $locl AST:Local-type AST:Type-ty AST:TYPE_GENERIC = if {
                $formatter FMT:Formatter-write-indent

                $formatter
                $locl AST:Local-type $generics AST:Type-size
                $locl AST:Local-ident L:Token-lexeme ~ STR:Str-unpack
                $locl.scope-id
                $locl.shadow-id
                generate-mem

                $formatter "\n" FMT:Formatter-write
            }
        }
        $locl AST:Local-ty AST:LOCAL_MEMORY = if {
            $formatter FMT:Formatter-write-indent
            $formatter 
            $locl.size
            $locl AST:Local-ident L:Token-lexeme ~ STR:Str-unpack
            $locl.scope-id
            $locl.shadow-id
            generate-mem
            $formatter "\n" FMT:Formatter-write
        }
        $i 1 + #i
    }
}
fn generate-word-strucs(formatter: .FMT:Formatter, generics: .AST:Types, words: .AST:Words) {
    local i: i32
    local word: .AST:Word
    local iff: .AST:If
    loop {
        $i $words AST:Words-len = if { break }
        $words $i AST:Words-get #word
        $word AST:Word-ty AST:WORD_IF = if {
            $word AST:Word-iff #iff
            $formatter $generics $iff AST:If-body generate-word-strucs
            $iff.has-el if {
                $formatter $generics $word AST:Word-iff AST:If-el generate-word-strucs
            }
        }
        $word AST:Word-ty AST:WORD_LOOP = if {
            $formatter $generics $word.lop.body generate-word-strucs
        }
        $word AST:Word-ty AST:WORD_BLOCK = if {
            $formatter $generics $word.blok.body generate-word-strucs
        }
        $word AST:Word-ty AST:WORD_INIT_LOCAL = if {
            $word.type AST:Type-ty AST:TYPE_STRUCT = if {
                $formatter FMT:Formatter-write-indent

                $formatter
                $word.type $generics AST:Type-size
                $word.token L:Token-lexeme ~ STR:Str-unpack
                $word.scope-id
                $word.shadow-id
                generate-mem
                $formatter " ;; @" FMT:Formatter-write
                $formatter "\n" FMT:Formatter-write
            }
        }
        $i 1 + #i
    }
}

fn generate-mem-locals(formatter: .FMT:Formatter, locals: .AST:Locals) {
    local i: i32
    local locl: .AST:Local
    loop {
        $i $locals AST:Locals-len = if { break }
        $locals $i AST:Locals-get #locl
        $locl AST:Local-ty AST:LOCAL_MEMORY = if {
            $formatter $locl generate-mem-locl
        }
        $i 1 + #i
    }
}
fn generate-mem-locl(formatter: .FMT:Formatter, mem: .AST:Local) {
    $formatter FMT:Formatter-write-indent
    $formatter "(local $" FMT:Formatter-write
    $formatter $mem.ident L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
    $formatter " i32)\n" FMT:Formatter-write
}
fn generate-params-receiving(formatter: .FMT:Formatter, generics: .AST:Types, function: .AST:Function) {
    local i: i32
    local locals: .AST:Locals
    local locl: .AST:Local
    $function AST:Function-locals #locals
    loop {
        $i $locals AST:Locals-len = if { break }
        $formatter $locals $i AST:Locals-get #locl
        $locl AST:Local-ty AST:LOCAL_ARGUMENT = if {
            $generics $locl generate-param-receiving
        } else {
            // TODO: removing this else branch results in miscompilation
            drop 
        }
        $i 1 + #i
    }
}
fn generate-param-receiving(formatter: .FMT:Formatter, generics: .AST:Types, param: .AST:Local) {
    local struc: .AST:Struct
    $param AST:Local-type AST:Type-ty AST:TYPE_STRUCT = if {
        $formatter "\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $param AST:Local-type AST:Type-struc #struc
        $formatter "local.get $" FMT:Formatter-write
        $formatter $param AST:Local-ident L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
        $formatter "\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent

        $formatter 
        $struc $generics AST:Struct-size 
        $param AST:Local-ident L:Token-lexeme ~ STR:Str-unpack 
        $param.scope-id
        $param.shadow-id
        generate-mem

        $formatter "\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $formatter "local.get $" FMT:Formatter-write
        $formatter $param AST:Local-ident L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
        $formatter "\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $formatter "call $intrinsic:flip\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $formatter "i32.const " FMT:Formatter-write
        $struc $generics AST:Struct-size $formatter U:i32-format
        $formatter "\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $formatter "memory.copy\n" FMT:Formatter-write
    }
}
fn measure-struc-returnals-space(words: .AST:Words, generics: .AST:Types) -> i32, i32 {
    local size: i32
    local max-args: i32
    local i: i32
    local j: i32
    local word: .AST:Word
    local function: .AST:Function
    local rets: .AST:Types
    local iff: .AST:If

    loop {
        $i $words AST:Words-len = if { break }
        $words $i AST:Words-get #word
        $word AST:Word-ty AST:WORD_CALL = if {
            $word AST:Word-rets #rets
            0 #j
            loop {
                $j $rets AST:Types-len = if { break }
                $rets $j AST:Types-get AST:Type-ty AST:TYPE_STRUCT = if {
                    $size $rets $j AST:Types-get AST:Type-struc 0 !.AST:Types AST:Struct-size + #size
                }
                $rets $j AST:Types-get AST:Type-ty AST:TYPE_ARRAY = if {
                    $size $rets $j AST:Types-get $generics AST:Type-size + #size
                }
                $j 1 + #j
            }
            $j 0 gt if {
                $max-args $j CORE:max #max-args
            }
        }
        $word AST:Word-ty AST:WORD_LOOP = if {
            $word.lop.body $generics measure-struc-returnals-space 
            $max-args CORE:max #max-args 
            $size + #size
        }
        $word AST:Word-ty AST:WORD_BLOCK = if {
            $word.blok.body $generics measure-struc-returnals-space 
            $max-args CORE:max #max-args 
            $size + #size
        }
        $word AST:Word-ty AST:WORD_IF = if {
            $word AST:Word-iff #iff
            $iff AST:If-body $generics measure-struc-returnals-space
            $max-args CORE:max #max-args 
            $size + #size
            $iff.has-el if {
                $word AST:Word-iff AST:If-el $generics measure-struc-returnals-space
                $max-args CORE:max #max-args 
                $size + #size
            }
        }
        $i 1 + #i
    }
    $size $max-args
}
fn measure-locl-copy-space(words: .AST:Words, generics: .AST:Types) -> i32, i32 {
    local size: i32
    local count: i32
    local word: .AST:Word
    local iff: .AST:If
    local i: i32
    loop {
        $i $words AST:Words-len = if { break }
        $words $i AST:Words-get #word
        $word AST:Word-ty AST:WORD_GET_LOCAL = 
        $word AST:Word-ty AST:WORD_DEREF = or
        $word AST:Word-ty AST:WORD_LOAD = or
        if {
            $word AST:Word-type AST:Type-ty AST:TYPE_STRUCT = if {
                $word AST:Word-type $generics AST:Type-size $size + #size
                $count 1 + #count
            }
            $word AST:Word-type AST:Type-ty AST:TYPE_ARRAY = if {
                $word AST:Word-type $generics AST:Type-size $size + #size
                $count 1 + #count
            }

        }
        $word AST:Word-ty AST:WORD_LOOP = if {
            $word.lop.body $generics measure-locl-copy-space
            $count + #count
            $size + #size
        }
        $word AST:Word-ty AST:WORD_BLOCK = if {
            $word.blok.body $generics measure-locl-copy-space
            $count + #count
            $size + #size
        }
        $word AST:Word-ty AST:WORD_IF = if {
            $word AST:Word-iff #iff
            $iff AST:If-body $generics measure-locl-copy-space
            $count + #count
            $size + #size
            $iff.has-el if {
                $word AST:Word-iff AST:If-el $generics measure-locl-copy-space
                $count + #count
                $size + #size
            }
        }
        $word AST:Word-ty AST:WORD_ARRAY_INIT = if {
            $word AST:Word-type $generics AST:Type-size $size + #size
            $count 1 + #count
        }
        $i 1 + #i
    }
    $size $count
}
fn generate-function(formatter: .FMT:Formatter, module: i32, function: .AST:Function) {
    0 @i
    loop {
        $i $function.instances AST:Instances-len = if { break }
        $function.instances $i AST:Instances-get @instance
        $formatter $module $instance $i $function generate-function-instance
        $i 1 + #i
    }
}

fn generate-function-instance(formatter: .FMT:Formatter, module: i32, instance: .AST:Instance, instance-index: i32, function: .AST:Function) {
    local locl-copy-space-ptr: CORE:I32
    local struc-returnals-space-ptr: CORE:I32
    local i: i32
    local uses-stack: bool
    local struc-returnals-space: i32
    local max-args: i32
    local locl-copy-space: i32
    local locl-copy-count: i32

    $instance.generics AST:Types-is-generic if {
        2 "FATAL ERROR: function instance is generic\n\t" IO:write-all IO:check
        2 $function.ident L:Token-lexeme ~ STR:Str-unpack IO:write-all IO:check
        2 "\t" IO:write-all IO:check
        1 CORE:exit
    }

    $formatter FMT:Formatter-write-indent
    $formatter "(" FMT:Formatter-write

    $formatter 
    $module $function AST:Function-ident 
    $function.export
    $function AST:Function-locals
    $function AST:Function-rets
    $instance.generics
    $instance-index
    generate-signature

    $formatter " ;; " FMT:Formatter-write
    $formatter 0 !.AST:Types $instance.generics AST:Types-format

    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent

    $formatter $instance.generics $function AST:Function-locals generate-locals
    $formatter $instance.generics $function AST:Function-body generate-word-locals

    $instance.body $instance.generics measure-struc-returnals-space #max-args #struc-returnals-space
    0 #struc-returnals-space-ptr.inner

    $instance.body $instance.generics measure-locl-copy-space #locl-copy-count #locl-copy-space
    0 #locl-copy-space-ptr.inner

    $function AST:Function-has-mem-or-struc-locl
    $struc-returnals-space 0 gt or
    $locl-copy-count 0 gt or
    #uses-stack

    $struc-returnals-space 0 gt if { loop {
        $i $max-args = if { break }
        $formatter FMT:Formatter-write-indent
        $formatter "(local $s" FMT:Formatter-write
        $i $formatter U:i32-format
        $formatter ":a i32)\n" FMT:Formatter-write
        $i 1 + #i
    } }
    0 #i

    $locl-copy-count 0 gt if {
        $formatter FMT:Formatter-write-indent
        $formatter "(local $locl-copy-spac:e i32)\n" FMT:Formatter-write
    }

    $formatter $function AST:Function-locals generate-mem-locals

    $uses-stack if {
        $formatter FMT:Formatter-write-indent
        $formatter "(local $stac:k i32)\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $struc-returnals-space 0 gt if {
            $formatter "(local $struc-returnals-spac:e i32)\n" FMT:Formatter-write
            $formatter FMT:Formatter-write-indent
            $formatter "global.get $stac:k local.set $stac:k\n" FMT:Formatter-write
            $formatter FMT:Formatter-write-indent
            $formatter $struc-returnals-space "struc-returnals-spac:e\n" 0 0 generate-mem
        } else {
            $formatter "global.get $stac:k local.set $stac:k" FMT:Formatter-write
        }
    }
    $formatter $instance.generics $function generate-params-receiving
    $locl-copy-space 0 gt if {
        $formatter FMT:Formatter-write-indent
        $formatter $locl-copy-space "locl-copy-spac:e\n" 0 0 generate-mem
    }
    $formatter $instance.generics $function AST:Function-locals generate-strucs
    $formatter $instance.generics $function AST:Function-body generate-word-strucs

    $formatter $instance.generics &struc-returnals-space-ptr.inner &locl-copy-space-ptr.inner $instance.body $instance-index generate-words
    $uses-stack if {
        $formatter FMT:Formatter-write-indent
        $formatter "local.get $stac:k global.set $stac:k\n" FMT:Formatter-write
    }
    $function AST:Function-diverges if {
        loop {
            $i $function AST:Function-rets AST:Types-len = if { break }
            $formatter FMT:Formatter-write-indent
            $formatter "i32.const 0\n" FMT:Formatter-write
            $i 1 + #i
        }
    }
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter ")\n" FMT:Formatter-write
}

fn generate-functions(formatter: .FMT:Formatter, modules: .M:Modules) {
    0 @i
    loop {
        $i $modules M:Modules-len = if { break }
        $modules $i M:Modules-get-value @module
        LOGGING:enabled if {
            2 "Codegen for module: " IO:write-all IO:check
            2 &module.path S:String-unpack IO:write-all IO:check
            2 "\n" IO:write-all IO:check
        }
        0 @j
        loop {
            $j $module M:Module-items.len ~ = if { break }
            $module M:Module-items $j DynArray:get<.AST:TopItem> ~ @item
            $item AST:TopItem-ty AST:TOP_ITEM_FN = if {
                $item AST:TopItem-function @function
                $function.reachable if {
                    $formatter $i $item AST:TopItem-function generate-function
                } else {
                    LOGGING:enabled if {
                        2 "Unused function: " IO:write-all IO:check
                        2 $function.ident L:Token-lexeme ~ STR:Str-unpack IO:write-all IO:check
                        2 ", in module: " IO:write-all IO:check
                        2 &module.path S:String-unpack IO:write-all IO:check
                        2 "\n" IO:write-all IO:check
                    }
                }
            }
            $j 1 + #j
        }
        $i 1 + #i
    }
}

struct ExternOrFunction {
    ext: .AST:Extern
    function: .AST:Function
    module: i32
}

fn generate-table(formatter: .FMT:Formatter, modules: .M:Modules) {
    local tmp: ExternOrFunction
    0!(ExternOrFunction ->) DynArray:new<ExternOrFunction> @fs
    0 @i
    loop {
        $i $modules M:Modules-len = if { break }
        $modules $i M:Modules-get-value @module
        $module M:Module-items @items
        0 @j
        loop {
            $j $items.len = if { break }
            $items $j DynArray:get<.AST:TopItem> ~ @item
            $item AST:TopItem-ty AST:TOP_ITEM_FN = if {
                $item.function.table-index 0 /=
                $item.function.reachable and
                if {
                    0 !.AST:Extern #tmp.ext
                    $item.function #tmp.function
                    $i #tmp.module
                    &fs $tmp DynArray:push<ExternOrFunction>
                    $fs.len #item.function.table-index
                }
            }
            $item AST:TopItem-ty AST:TOP_ITEM_EXT = if {
                $item.ext.table-index 0 /= if {
                    0 !.AST:Function #tmp.function
                    $item.ext #tmp.ext
                    $i #tmp.module
                    &fs $tmp DynArray:push<ExternOrFunction>
                    $fs.len #item.ext.table-index
                }
            }
            $j 1 + #j
        }
        $i 1 + #i
    }
    $formatter FMT:Formatter-write-indent
    $formatter "(table funcref (elem $intrinsic:flip " FMT:Formatter-write
    0 @i 
    loop {
        $i $fs.len = if { break }
        &fs $i DynArray:get<ExternOrFunction> @f
        $f.ext 0 !.AST:Extern /= if {
            $formatter $f.ext.ident L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
        }
        $f.function 0 !.AST:Function /= if {
            $formatter "$" FMT:Formatter-write
            $f.module $formatter U:i32-format
            $formatter ":" FMT:Formatter-write
            $formatter $f.function.ident L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
        }
        $formatter " " FMT:Formatter-write
        $i 1 + #i
    }
    $formatter "))\n" FMT:Formatter-write
    $fs DynArray:free<ExternOrFunction>
}

fn generate(formatter: .FMT:Formatter, stack-start: i32, mem: .S:String, modules: .M:Modules) {
    $formatter "(module\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent

    $formatter $modules generate-externs

    $formatter FMT:Formatter-write-indent
    $formatter "(memory 1 1024)\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
	$formatter "(export \"memory\" (memory 0))\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "(global $stac:k (mut i32) (i32.const " FMT:Formatter-write
    $stack-start 4 CORE:align-to $formatter U:i32-format
    $formatter "))\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "(func $intrinsic:flip (param $a i32) (param $b i32) (result i32 i32) local.get $b local.get $a)\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "(func $intrinsic:dupi32 (param $a i32) (result i32 i32) local.get $a local.get $a)\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "(func $intrinsic:rotate-left (param $a i32) (param $b i32) (param $c i32) (result i32 i32 i32) local.get $b local.get $c local.get $a)\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "(func $intrinsic:rotate-right (param $a i32) (param $b i32) (param $c i32) (result i32 i32 i32) local.get $c local.get $a local.get $b)\n" FMT:Formatter-write

    $formatter $modules generate-table

    $formatter $mem S:String-len $modules generate-global-mems

    $formatter $mem generate-static-mem
    $formatter "\n" FMT:Formatter-write

    $formatter $modules generate-functions

    $formatter FMT:Formatter-dedent
    $formatter ")" FMT:Formatter-write
}

