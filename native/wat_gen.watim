import "../std/format.watim" as FMT
import "../std/io.watim" as IO
import "../std/core.watim" as CORE
import "../std/util.watim" as U
import "../std/string.watim" as S
import "../std/str.watim" as STR
import "../std/i32vec.watim" as IV

import "./ast.watim" as AST
import "./lexer.watim" as L
import "./module.watim" as M

fn generate-type(formatter: .FMT:Formatter, self: .AST:Type) {
     loop {
        $self AST:Type-ty AST:TYPE_I32 = 
        $self AST:Type-ty AST:TYPE_BOOL = or
        $self AST:Type-ty AST:TYPE_PTR = or
        $self AST:Type-ty AST:TYPE_STRUCT = or
        if { 
            $formatter "i32" FMT:Formatter-write break
        }
        $self AST:Type-ty AST:TYPE_I64 = if { 
            $formatter "i64" FMT:Formatter-write break 
        }
        2 "invalid Type-ty" IO:write-all IO:check
        1 CORE:exit
    }
}
fn generate-lop(formatter: .FMT:Formatter, struc-returnals-space-ptr: .i32, locl-copy-space-ptr: .i32, lop: .AST:Words, rets: .AST:Types) {
    $formatter "(block $block " FMT:Formatter-write
    $rets !i32 0 /= if {
        $formatter $rets generate-rets
    }
    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent
    $formatter FMT:Formatter-write-indent
    $formatter "(loop $loop " FMT:Formatter-write
    $rets !i32 0 /= if {
        $formatter $rets generate-rets
    }
    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent
    $formatter $struc-returnals-space-ptr $locl-copy-space-ptr $lop generate-words
    $formatter FMT:Formatter-write-indent
    $formatter "br $loop\n" FMT:Formatter-write
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter ")\n" FMT:Formatter-write
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter ")\n" FMT:Formatter-write
}
fn generate-word(formatter: .FMT:Formatter, struc-returnals-space-ptr: .i32, locl-copy-space-ptr: .i32, self: .AST:Word) {
    loop {
        $self.ty AST:WORD_NUMBER = if {
            $formatter "i32.const " FMT:Formatter-write
            $self.number $formatter U:i32-format
            $formatter "\n" FMT:Formatter-write
            break
        }
        $self.ty AST:WORD_STRING = if {
            $formatter "i32.const " FMT:Formatter-write
            $self.addr $formatter U:i32-format
            $formatter " i32.const " FMT:Formatter-write
            $self.size $formatter U:i32-format
            $formatter "\n" FMT:Formatter-write
            break
        }
        $self.ty AST:WORD_CALL = if {
            $formatter $struc-returnals-space-ptr $self generate-call break
        }
        $self.ty AST:WORD_GLOBAL = if {
            $formatter "global.get $" FMT:Formatter-write
            $self AST:Word-module $formatter U:i32-format
            $formatter ":" FMT:Formatter-write
            $formatter $self AST:Word-ident STR:Str-unpack FMT:Formatter-write
            $formatter "\n" FMT:Formatter-write
            break
        }
        $self.ty AST:WORD_LOOP = if {
            $formatter $struc-returnals-space-ptr $locl-copy-space-ptr $self AST:Word-lop $self AST:Word-rets generate-lop
            break
        }
        $self.ty AST:WORD_BREAK = if {
            $formatter "br $block\n" FMT:Formatter-write
            break    
        }
        $self.ty AST:WORD_IF = if {
            $formatter $struc-returnals-space-ptr $locl-copy-space-ptr $self AST:Word-iff generate-iff
            break
        }
        $self.ty AST:WORD_INTRINSIC = if {
            $formatter $self generate-intrinsic
            break
        }
        $self.ty AST:WORD_CAST = if {
            $self.type AST:Type-ty AST:TYPE_I64 =
            $self.src-type AST:Type-ty AST:TYPE_I32 = 
            $self.src-type AST:Type-ty AST:TYPE_BOOL = or and
            if {
                $formatter "i64.extend_i32_s\n" FMT:Formatter-write break
            }
            $self.type AST:Type-ty AST:TYPE_I32 =
            $self.type AST:Type-ty AST:TYPE_BOOL = or
            $self.src-type AST:Type-ty AST:TYPE_I64 = and
            if {
                $formatter "i32.wrap_i64\n" FMT:Formatter-write break
            }
            $formatter ";; CAST from " FMT:Formatter-write
            $self.src-type $formatter AST:Type-format
            $formatter " to " FMT:Formatter-write
            $self.type $formatter AST:Type-format
            $formatter "\n" FMT:Formatter-write
            break
        }
        $self.ty AST:WORD_DEREF = if {
            $formatter "i32.const " FMT:Formatter-write
            $self.offset $formatter U:i32-format
            $formatter " i32.add " FMT:Formatter-write
            $self.src-type AST:Type-ty AST:TYPE_PTR = if { break }
            $self.type AST:Type-ty AST:TYPE_STRUCT = if {
                $formatter $self.type $locl-copy-space-ptr generate-load-struc
            } else {
                $formatter "i32.load\n" FMT:Formatter-write
            }
            break
        }
        $self.ty AST:WORD_STRUCT_SET = if {
            $formatter $self generate-struc-set break
        }
        $self.ty AST:WORD_GET_REF = if {
            $formatter $self generate-get-ref
            break
        }
        $self.ty AST:WORD_LOCAL = if {
            $formatter $self $locl-copy-space-ptr generate-get-locl
            break
        }
        $self.ty AST:WORD_LOAD = if {
            $self.type AST:Type-ty AST:TYPE_STRUCT = if {
                $formatter $self.type $locl-copy-space-ptr generate-load-struc
                $formatter "\n" FMT:Formatter-write
            } else {
                $self.type $formatter AST:Type-format
                $formatter ".load" FMT:Formatter-write
            }
            break
        }
        $self.ty AST:WORD_SIZEOF = if {
            $formatter "i32.const " FMT:Formatter-write
            $self.number $formatter U:i32-format
            $formatter "\n" FMT:Formatter-write
            break
        }
        $self.ty AST:WORD_STORE = if {
            $formatter $self generate-store break
        }
        $formatter $self.ty AST:word-ty-name FMT:Formatter-write
        break
    } 
}
fn generate-load-struc(formatter: .FMT:Formatter, type: .AST:Type, locl-copy-space-ptr: .i32) { 
    $formatter "local.get $locl-copy-spac:e i32.const " FMT:Formatter-write
    $locl-copy-space-ptr ~ $formatter U:i32-format
    $formatter " i32.add call $intrinsic:dupi32 call $intrinsic:rotate-left i32.const " FMT:Formatter-write
    $type AST:Type-size $formatter U:i32-format
    $formatter " memory.copy" FMT:Formatter-write
}
fn generate-get-ref(formatter: .FMT:Formatter, word: .AST:Word) {
    local i: i32
    local offset: i32
    $formatter "local.get $" FMT:Formatter-write
    $formatter $word AST:Word-ident STR:Str-unpack FMT:Formatter-write
    $formatter " " FMT:Formatter-write
    loop {
        $i $word.loads IV:I32Vec-len = if { break }
        $word.loads $i IV:I32Vec-get #offset

        $i 1 + $word.loads IV:I32Vec-len = if {
            $formatter " i32.const " FMT:Formatter-write
            $offset $formatter U:i32-format
            $formatter " i32.add" FMT:Formatter-write
        } else {
            $formatter " i32.load offset=" FMT:Formatter-write
            $offset $formatter U:i32-format
        }
        $i 1 + #i
    }
    $formatter "\n" FMT:Formatter-write
}
fn generate-store(formatter: .FMT:Formatter, word: .AST:Word) {
    local i: i32
    local offset: i32
    $formatter "local.get $" FMT:Formatter-write
    $formatter $word AST:Word-ident STR:Str-unpack FMT:Formatter-write
    $formatter " " FMT:Formatter-write
    loop {
        $i $word.loads IV:I32Vec-len = if { break }
        $word.loads $i IV:I32Vec-get #offset

        $formatter " i32.load offset=" FMT:Formatter-write
        $offset $formatter U:i32-format
        $i 1 + #i
    }
    $formatter " call $intrinsic:flip " FMT:Formatter-write
    $word.type AST:Type-ty AST:TYPE_STRUCT = if {
        $formatter " i32.const " FMT:Formatter-write
        $word.type AST:Type-size $formatter U:i32-format
        $formatter " memory.copy" FMT:Formatter-write
    } else {
        $formatter $word.type generate-type
        $formatter ".store" FMT:Formatter-write
    }
    $formatter "\n" FMT:Formatter-write
}
fn generate-get-locl(formatter: .FMT:Formatter, word: .AST:Word, locl-copy-space-ptr: .i32) {
    local i: i32
    local offset: i32
    $word.type AST:Type-ty AST:TYPE_STRUCT = if {
        $formatter "local.get $locl-copy-spac:e i32.const " FMT:Formatter-write
        $locl-copy-space-ptr ~ $formatter U:i32-format
        $formatter " i32.add call $intrinsic:dupi32 " FMT:Formatter-write
        $locl-copy-space-ptr ~ $word.type AST:Type-size + >>locl-copy-space-ptr 
    }
    $formatter "local.get $" FMT:Formatter-write
    $formatter $word AST:Word-ident STR:Str-unpack FMT:Formatter-write
    $formatter " " FMT:Formatter-write
    $word.loads IV:I32Vec-len 0 = if {
        $word.type AST:Type-ty AST:TYPE_STRUCT = if {
            $formatter " i32.const " FMT:Formatter-write
            $word.type AST:Type-size $formatter U:i32-format
            $formatter " memory.copy" FMT:Formatter-write
        }
    }
    loop {
        $i $word.loads IV:I32Vec-len = if { break }
        $word.loads $i IV:I32Vec-get #offset

        $word.loads IV:I32Vec-len $i 1 + < 
        $word.type AST:Type-ty AST:TYPE_STRUCT /= 
        or if {
            $formatter "i32.load offset=" FMT:Formatter-write
            $offset $formatter U:i32-format
            $formatter " " FMT:Formatter-write
        } else {
            $formatter " i32.const " FMT:Formatter-write
            $offset $formatter U:i32-format
            $formatter " i32.add i32.const " FMT:Formatter-write
            $word.type AST:Type-size $formatter U:i32-format
            $formatter " memory.copy" FMT:Formatter-write
        }
        $i 1 + #i
    }
    $formatter "\n" FMT:Formatter-write
}
fn generate-call(formatter: .FMT:Formatter, struc-returnals-space-ptr: .i32, word: .AST:Word) {
    local i: i32
    local rets: .AST:Types
    local type: .AST:Type
    local rets-structs: bool
    local struc-size: i32
    $formatter "call $" FMT:Formatter-write
    $word AST:Word-module $formatter U:i32-format
    $formatter ":" FMT:Formatter-write
    $formatter $word AST:Word-ident STR:Str-unpack FMT:Formatter-write
    $formatter "\n" FMT:Formatter-write
    $word AST:Word-rets #rets
    loop {
        $i $rets AST:Types-len = if { 0 1 = break }
        $rets $i AST:Types-get #type
        $type AST:Type-ty AST:TYPE_STRUCT = if {
            1 1 = break
        }
        $i 1 + #i
    } if {
        0 #i
        loop {
            $i $rets AST:Types-len = if { break }
            $formatter FMT:Formatter-write-indent
            $formatter "local.set $s" FMT:Formatter-write
            $i $formatter U:i32-format
            $formatter ":a\n" FMT:Formatter-write

            $i 1 + #i
        }
        0 #i
        $rets AST:Types-len  #i
        loop {
            $i 0 = if { break }
            $rets $rets AST:Types-len $i - AST:Types-get #type
            $formatter FMT:Formatter-write-indent
            $type AST:Type-ty AST:TYPE_STRUCT = if {
                $formatter "local.get $struc-returnals-spac:e i32.const " FMT:Formatter-write
                $struc-returnals-space-ptr ~ $formatter U:i32-format
                $formatter " i32.add call $intrinsic:dupi32 local.get $s" FMT:Formatter-write
                $i 1 - $formatter U:i32-format
                $formatter ":a " FMT:Formatter-write
                $formatter " i32.const " FMT:Formatter-write
                $type AST:Type-struc AST:Struct-size #struc-size
                $struc-size $formatter U:i32-format
                $formatter " memory.copy\n" FMT:Formatter-write
                $struc-returnals-space-ptr ~ $struc-size + >>struc-returnals-space-ptr 
            } else {
                $formatter "local.get $s" FMT:Formatter-write
                $i 1 - $formatter U:i32-format
                $formatter ":a\n" FMT:Formatter-write
            }
            $i 1 - #i
        }
    }
}
fn generate-struc-set(formatter: .FMT:Formatter, word: .AST:Word) {
    local i: i32
    // TODO: this can be simplified
    $word.type AST:Type-ty AST:TYPE_STRUCT = if {
        $word.loads IV:I32Vec-len 0 > if {
            $formatter "local.get $" FMT:Formatter-write
            $formatter $word AST:Word-ident STR:Str-unpack FMT:Formatter-write
            loop {
                $word.loads IV:I32Vec-len $i = if { break }
                $formatter " i32.const " FMT:Formatter-write
                $word.loads $i IV:I32Vec-get $formatter U:i32-format
                $formatter " i32.add " FMT:Formatter-write
                $i 1 + $word.loads IV:I32Vec-len = if {
                    $formatter " call $intrinsic:flip i32.const " FMT:Formatter-write
                    $word.type AST:Type-size $formatter U:i32-format
                    $formatter " memory.copy" FMT:Formatter-write
                } else {
                    $formatter "i32.load" FMT:Formatter-write
                }
                $i 1 + #i
            }
        } else {
            $formatter "local.get $" FMT:Formatter-write
            $formatter $word AST:Word-ident STR:Str-unpack FMT:Formatter-write
            $formatter " call $intrinsic:flip i32.const " FMT:Formatter-write
            $word.type AST:Type-size $formatter U:i32-format
            $formatter " memory.copy" FMT:Formatter-write
        }
    } else {
        $word.loads IV:I32Vec-len 0 > if {
            $formatter "local.get $" FMT:Formatter-write
            $formatter $word AST:Word-ident STR:Str-unpack FMT:Formatter-write
            loop {
                $word.loads IV:I32Vec-len $i = if { break }
                $formatter " i32.const " FMT:Formatter-write
                $word.loads $i IV:I32Vec-get $formatter U:i32-format
                $formatter " i32.add " FMT:Formatter-write
                $i 1 + $word.loads IV:I32Vec-len = if {
                    $formatter " call $intrinsic:flip " FMT:Formatter-write
                    $formatter $word.type generate-type
                    $formatter ".store" FMT:Formatter-write
                } else {
                    $formatter "i32.load" FMT:Formatter-write
                }
                $i 1 + #i
            }
        } else {
            $formatter "local.set $" FMT:Formatter-write
            $formatter $word AST:Word-ident STR:Str-unpack FMT:Formatter-write
        }
    }
    $formatter "\n" FMT:Formatter-write
}
fn generate-intrinsic(formatter: .FMT:Formatter, word: .AST:Word) {
    loop {
        $word.intrinsic AST:INTRINSIC_ADD = if {
            $formatter "i32.add" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_SUB = if {
            $formatter "i32.sub" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_EQ = if {
            $formatter "i32.eq" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_DROP = if {
            $formatter "drop" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_NOT = if {
            $formatter "i32.const 1 i32.and i32.const 1 i32.xor i32.const 1 i32.and" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_MEM_GROW = if {
            $formatter "memory.grow" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_NOT_EQ = if {
            $formatter "i32.ne" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_STORE32 = if {
            $formatter "i32.store" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_LOAD32 = if {
            $formatter "i32.load" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_GREATER_EQ = if {
            $formatter "i32.ge_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_AND = if {
            $formatter "i32.and" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_GREATER = if {
            $formatter "i32.gt_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_STORE8 = if {
            $formatter "i32.store8" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_FLIP = if {
            $formatter "call $intrinsic:flip" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_MOD = if {
            $formatter "i32.rem_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_DIV = if {
            $formatter "i32.div_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_LOAD8 = if {
            $formatter "i32.load8_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_LESS = if {
            $formatter "i32.lt_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_MUL = if {
            $formatter "i32.mul" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_MEM_COPY = if {
            $formatter "memory.copy" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_LESS_EQ = if {
            $formatter "i32.le_u" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_ROTR = if {
            $formatter "i32.rotr" FMT:Formatter-write break
        }
        $word.intrinsic AST:INTRINSIC_ROTL = if {
            $word.type AST:Type-ty AST:TYPE_I32 = if {
                $formatter "i32.rotl" FMT:Formatter-write break
            }
            $word.type AST:Type-ty AST:TYPE_I64 = if {
                $formatter "i64.extend_i32_s i64.rotl" FMT:Formatter-write break
            }
            2 "Unexpted type in INTRINSIC_ROTL" IO:write-all IO:check
            1 CORE:exit
        }
        $word.intrinsic AST:INTRINSIC_OR = if {
            $word.type !i32 0 /= if {
                $formatter $word.type generate-type
                $formatter ".or" FMT:Formatter-write break
            } else {
                $formatter "i32.or" FMT:Formatter-write break
            }
        }
        1 $word.intrinsic AST:intrinsic-name IO:write-all IO:check
        1 CORE:exit
        $formatter $word.intrinsic AST:intrinsic-name FMT:Formatter-write
        break
    }
    $formatter "\n" FMT:Formatter-write
}
fn generate-iff-params(formatter: .FMT:Formatter, params: .AST:Types) {
    local i: i32
    loop {
        $i $params AST:Types-len = if { break }
        $formatter "(param " FMT:Formatter-write
        $formatter $params $i AST:Types-get generate-type
        $formatter ")\n" FMT:Formatter-write
        $i 1 + #i
    }
}
fn generate-iff(formatter: .FMT:Formatter, struc-returnals-space-ptr: .i32, locl-copy-space-ptr: .i32, iff: .AST:If) {
    $formatter "(if " FMT:Formatter-write
    $formatter $iff AST:If-params generate-iff-params
    $formatter $iff AST:If-rets generate-rets
    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent
    $formatter FMT:Formatter-write-indent
    $formatter "(then\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent
    $formatter $struc-returnals-space-ptr $locl-copy-space-ptr $iff AST:If-body generate-words 
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter ")" FMT:Formatter-write
    $iff AST:If-el !i32 0 /= if {
        $formatter " (else\n" FMT:Formatter-write
        $formatter FMT:Formatter-indent
        $formatter $struc-returnals-space-ptr $locl-copy-space-ptr $iff AST:If-el generate-words
        $formatter FMT:Formatter-dedent
        $formatter FMT:Formatter-write-indent
        $formatter ")" FMT:Formatter-write
    }
    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter ")\n" FMT:Formatter-write
}
fn generate-param(formatter: .FMT:Formatter, param: .AST:Local) {
    $formatter "(param $" FMT:Formatter-write
    $formatter $param AST:Local-ident L:Token-lexeme STR:Str-unpack FMT:Formatter-write
    $formatter " " FMT:Formatter-write
    $formatter $param AST:Local-type generate-type
    $formatter ")" FMT:Formatter-write
}
fn generate-params(formatter: .FMT:Formatter, params: .AST:Locals) {
    local i: i32
    loop {
        $i $params AST:Locals-len = if { break }
        $formatter $params $i AST:Locals-get generate-param
        $i 1 + $params AST:Locals-len < if { 
            $formatter " " FMT:Formatter-write
        }
        $i 1 + #i
    }
}
fn generate-ret(formatter: .FMT:Formatter, ret: .AST:Type) {
    $formatter "(result " FMT:Formatter-write
    $formatter $ret generate-type
    $formatter ")" FMT:Formatter-write
}
fn generate-rets(formatter: .FMT:Formatter, rets: .AST:Types) {
    local i: i32
    loop {
        $i $rets AST:Types-len = if { break }
        $formatter $rets $i AST:Types-get generate-ret
        $i 1 + $rets AST:Types-len < if {
            $formatter " " FMT:Formatter-write
        }
        $i 1 + #i
    }
}
fn generate-signature(formatter: .FMT:Formatter, module: i32, ident: .L:Token, qualifier: .L:Token, params: .AST:Locals, rets: .AST:Types) {
    $formatter "func $" FMT:Formatter-write
    $module $formatter U:i32-format
    $formatter ":" FMT:Formatter-write
    $formatter $ident L:Token-lexeme STR:Str-unpack FMT:Formatter-write
    $formatter " " FMT:Formatter-write
    $qualifier !i32 0 /= if {
        $formatter "(export " FMT:Formatter-write
        $formatter $qualifier L:Token-lexeme STR:Str-unpack FMT:Formatter-write
        $formatter ")" FMT:Formatter-write
    }
    $formatter $params generate-params
    $formatter " " FMT:Formatter-write
    $formatter $rets generate-rets
}

fn generate-ext(formatter: .FMT:Formatter, module: i32, ext: .AST:Extern) {
    $formatter FMT:Formatter-write-indent
    $formatter "(import " FMT:Formatter-write
    $formatter $ext AST:Extern-module L:Token-lexeme STR:Str-unpack FMT:Formatter-write
    $formatter " " FMT:Formatter-write
    $formatter $ext AST:Extern-name L:Token-lexeme STR:Str-unpack FMT:Formatter-write
    $formatter " (" FMT:Formatter-write
    $formatter $module $ext AST:Extern-ident 0 !.L:Token $ext AST:Extern-parameters $ext AST:Extern-rets generate-signature
    $formatter "))\n" FMT:Formatter-write
}

fn generate-externs(formatter: .FMT:Formatter, modules: .M:Modules) {
    local i: i32
    local j: i32
    local module: .M:Module
    local item: .AST:TopItem
    loop {
        $i $modules M:Modules-len = if { break }
        $modules $i M:Modules-get-value #module
        0 #j
        loop {
            $j $module M:Module-items AST:TopItems-len = if { break }
            $module M:Module-items $j AST:TopItems-get #item
            $item AST:TopItem-ty AST:TOP_ITEM_EXT = if {
                $formatter $i $item AST:TopItem-ext generate-ext
            }
            $j 1 + #j
        }
        $i 1 + #i
    }
}

fn generate-global-mem(formatter: .FMT:Formatter, module: i32, statics-len: i32, mem: .AST:Memory) {
    $formatter FMT:Formatter-write-indent
    $formatter "(global $" FMT:Formatter-write
    $module $formatter U:i32-format
    $formatter ":" FMT:Formatter-write
    $formatter $mem AST:Memory-ident L:Token-lexeme STR:Str-unpack FMT:Formatter-write
    $formatter " (mut i32) (i32.const " FMT:Formatter-write
    $mem AST:Memory-address $mem AST:Memory-alignment CORE:align-to $formatter U:i32-format
    $formatter "))\n" FMT:Formatter-write
}

fn generate-global-mems(formatter: .FMT:Formatter, statics-len: i32, modules: .M:Modules) {
    local i: i32
    local j: i32
    local module: .M:Module
    local item: .AST:TopItem
    loop {
        $i $modules M:Modules-len = if { break }
        $modules $i M:Modules-get-value #module
        0 #j
        loop {
            $j $module M:Module-items AST:TopItems-len = if { break }
            $module M:Module-items $j AST:TopItems-get #item
            $item AST:TopItem-ty AST:TOP_ITEM_MEM = if {
                $formatter $i $statics-len $item AST:TopItem-mem generate-global-mem
            }
            $j 1 + #j
        }
        $i 1 + #i
    }
}
fn generate-static-mem(formatter: .FMT:Formatter, mem: .S:String) {
    memory buf: i32 4 4;
    local i: i32
    $formatter FMT:Formatter-write-indent
    $formatter "(data (i32.const 0) \"" FMT:Formatter-write
    loop {
        $mem S:String-len $i = if { break }
        $formatter $mem S:String-unpack drop $i + load8 $buf CORE:escape
        $buf flip FMT:Formatter-write
        $i 1 + #i
    }
    $formatter "\")" FMT:Formatter-write
}

fn generate-words(formatter: .FMT:Formatter, struc-returnals-space-ptr: .i32, locl-copy-space-ptr: .i32, words: .AST:Words) {
    local i: i32 
    loop {
        $i $words AST:Words-len = if { break }
        $formatter FMT:Formatter-write-indent
        $formatter $struc-returnals-space-ptr $locl-copy-space-ptr $words $i AST:Words-get generate-word
        $i 1 + #i
    }
}

fn generate-locl(formatter: .FMT:Formatter, locl: .AST:Local) {
    $formatter FMT:Formatter-write-indent
    $formatter "(local $" FMT:Formatter-write
    $formatter $locl AST:Local-ident L:Token-lexeme STR:Str-unpack FMT:Formatter-write
    $formatter " " FMT:Formatter-write
    $locl AST:Local-type AST:Type-ty AST:TYPE_STRUCT = if {
        $formatter "i32" FMT:Formatter-write
    } else {
        $formatter $locl AST:Local-type generate-type
    }
    $formatter ")" FMT:Formatter-write
    $locl AST:Local-type AST:Type-ty AST:TYPE_STRUCT = if {
        $formatter " ;; " FMT:Formatter-write
        $formatter $locl AST:Local-type AST:Type-struc AST:Struct-ident L:Token-lexeme STR:Str-unpack FMT:Formatter-write
    }
    $formatter "\n" FMT:Formatter-write
}

fn generate-locals(formatter: .FMT:Formatter, locals: .AST:Locals) {
    local i: i32
    loop {
        $locals AST:Locals-len $i = if { break }
        $formatter $locals $i AST:Locals-get generate-locl
        $i 1 + #i
    }
}
fn generate-mem(formatter: .FMT:Formatter, alignment: i32, size: i32, ident-ptr: .i32, ident-len: i32) {
    $formatter "global.get $stac:k i32.const " FMT:Formatter-write
    $alignment $formatter U:i32-format
    $formatter " global.get $stac:k i32.const " FMT:Formatter-write
    $alignment $formatter U:i32-format
    $formatter " i32.rem_u i32.sub global.get $stac:k i32.const " FMT:Formatter-write
    $alignment $formatter U:i32-format
    $formatter " i32.rem_u i32.const 0 i32.gt_u i32.mul i32.add global.set $stac:k" FMT:Formatter-write
    $formatter " global.get $stac:k global.get $stac:k i32.const " FMT:Formatter-write
    $size $formatter U:i32-format
    $formatter " i32.add global.set $stac:k local.set $" FMT:Formatter-write
    $formatter $ident-ptr $ident-len FMT:Formatter-write
}
fn generate-memories(formatter: .FMT:Formatter, memories: .AST:Memories) {
    local i: i32
    local mem: .AST:Memory
    loop {
        $i $memories AST:Memories-len = if { break }
        $memories $i AST:Memories-get #mem
        $formatter FMT:Formatter-write-indent
        $formatter 
        $mem AST:Memory-alignment 
        $mem AST:Memory-size 
        $mem AST:Memory-ident L:Token-lexeme STR:Str-unpack
        generate-mem
        $formatter "\n" FMT:Formatter-write
        $i 1 + #i
    }
}
fn generate-struc-mems(formatter: .FMT:Formatter, locals: .AST:Locals) {
    local i: i32
    local locl: .AST:Local
    loop {
        $i $locals AST:Locals-len = if { break }
        $locals $i AST:Locals-get #locl
        $locl AST:Local-type AST:Type-ty AST:TYPE_STRUCT = if {
            $formatter FMT:Formatter-write-indent
            $formatter 
            4
            $locl AST:Local-type AST:Type-struc AST:Struct-size
            $locl AST:Local-ident L:Token-lexeme STR:Str-unpack
            generate-mem
            $formatter "\n" FMT:Formatter-write
        }
        $i 1 + #i
    }
}
fn generate-mem-locals(formatter: .FMT:Formatter, memories: .AST:Memories) {
    local i: i32
    local mem: .AST:Memory
    loop {
        $i $memories AST:Memories-len = if { break }
        $memories $i AST:Memories-get #mem
        $formatter FMT:Formatter-write-indent
        $formatter "(local $" FMT:Formatter-write
        $formatter $mem AST:Memory-local AST:Local-ident L:Token-lexeme STR:Str-unpack FMT:Formatter-write
        $formatter " i32)\n" FMT:Formatter-write
        $i 1 + #i
    }
}
fn generate-params-receiving(formatter: .FMT:Formatter, function: .AST:Function) {
    local i: i32
    local params: .AST:Locals
    $function AST:Function-parameters #params
    loop {
        $i $params AST:Locals-len = if { break }
        $formatter $params $i AST:Locals-get generate-param-receiving
        $i 1 + #i
    }
}
fn generate-param-receiving(formatter: .FMT:Formatter, param: .AST:Local) {
    local struc: .AST:Struct
    $param AST:Local-type AST:Type-ty AST:TYPE_STRUCT = if {
        $formatter "\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $param AST:Local-type AST:Type-struc #struc
        $formatter "local.get $" FMT:Formatter-write
        $formatter $param AST:Local-ident L:Token-lexeme STR:Str-unpack FMT:Formatter-write
        $formatter "\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $formatter 4 $struc AST:Struct-size $param AST:Local-ident L:Token-lexeme STR:Str-unpack generate-mem
        $formatter "\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $formatter "local.get $" FMT:Formatter-write
        $formatter $param AST:Local-ident L:Token-lexeme STR:Str-unpack FMT:Formatter-write
        $formatter "\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $formatter "call $intrinsic:flip\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $formatter "i32.const " FMT:Formatter-write
        $struc AST:Struct-size $formatter U:i32-format
        $formatter "\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $formatter "memory.copy\n" FMT:Formatter-write
    }
}
fn measure-struc-returnals-space(words: .AST:Words) -> i32, i32 {
    local size: i32
    local max-args: i32
    local i: i32
    local j: i32
    local word: .AST:Word
    local function: .AST:Function
    local rets: .AST:Types

    loop {
        $i $words AST:Words-len = if { break }
        $words $i AST:Words-get #word
        $word AST:Word-ty AST:WORD_CALL = if {
            $word AST:Word-rets #rets
            0 #j
            loop {
                $j $rets AST:Types-len = if { break }
                $rets $j AST:Types-get AST:Type-ty AST:TYPE_STRUCT = if {
                    $size $rets $j AST:Types-get AST:Type-struc AST:Struct-size + #size
                }
                $j 1 + #j
            }
            $j 0 > if {
                $max-args $j CORE:max #max-args
            }
        }
        $word AST:Word-ty AST:WORD_LOOP = if {
            $word AST:Word-words measure-struc-returnals-space 
            $max-args CORE:max #max-args 
            $size + #size
        }
        $word AST:Word-ty AST:WORD_IF = if {
            $word AST:Word-iff AST:If-body measure-struc-returnals-space
            $max-args CORE:max #max-args 
            $size + #size
            $word AST:Word-iff AST:If-el !i32 0 /= if {
                $word AST:Word-iff AST:If-el measure-struc-returnals-space
                $max-args CORE:max #max-args 
                $size + #size
            }
        }
        $i 1 + #i
    }
    $size $max-args
}
fn measure-locl-copy-space(words: .AST:Words) -> i32, i32 {
    local size: i32
    local count: i32
    local word: .AST:Word
    local i: i32
    loop {
        $i $words AST:Words-len = if { break }
        $words $i AST:Words-get #word
        $word AST:Word-ty AST:WORD_LOCAL = if {
            $word AST:Word-type AST:Type-ty AST:TYPE_STRUCT = if {
                $word AST:Word-type AST:Type-size $size + #size
                $count 1 + #count
            }
        }
        $word AST:Word-ty AST:WORD_DEREF = if {
            $word AST:Word-type AST:Type-ty AST:TYPE_STRUCT = if {
                $word AST:Word-type AST:Type-size $size + #size
                $count 1 + #count
            }
        }
        $word AST:Word-ty AST:WORD_LOAD = if {
            $word AST:Word-type AST:Type-ty AST:TYPE_STRUCT = if {
                $word AST:Word-type AST:Type-size $size + #size
                $count 1 + #count
            }
        }
        $word AST:Word-ty AST:WORD_LOOP = if {
            $word AST:Word-words measure-locl-copy-space
            $count + #count
            $size + #size
        }
        $word AST:Word-ty AST:WORD_IF = if {
            $word AST:Word-iff AST:If-body measure-locl-copy-space
            $count + #count
            $size + #size
            $word AST:Word-iff AST:If-el !i32 0 /= if {
                $word AST:Word-iff AST:If-el measure-locl-copy-space
                $count + #count
                $size + #size
            }
        }
        $i 1 + #i
    }
    $size $count
}
fn generate-function(formatter: .FMT:Formatter, module: i32, function: .AST:Function) {
    memory struc-returnals-space-ptr: i32 4 4;
    memory locl-copy-space-ptr: i32 4 4;
    local i: i32
    local uses-stack: bool
    local struc-returnals-space: i32
    local max-args: i32
    local locl-copy-space: i32
    local locl-copy-count: i32
    $formatter FMT:Formatter-write-indent
    $formatter "(" FMT:Formatter-write

    $formatter 
    $module $function AST:Function-ident 
    $function.qualifier
    $function AST:Function-parameters 
    $function AST:Function-rets
    generate-signature

    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent

    $formatter $function AST:Function-locals generate-locals
    $formatter $function AST:Function-memories generate-mem-locals

    $function AST:Function-body measure-struc-returnals-space #max-args #struc-returnals-space
    $struc-returnals-space-ptr 0 store32

    $function AST:Function-body measure-locl-copy-space #locl-copy-count #locl-copy-space
    $locl-copy-space-ptr 0 store32

    $function AST:Function-memories AST:Memories-len 0 > 
    $function AST:Function-has-struc-locl or 
    $struc-returnals-space 0 > or
    $locl-copy-count 0 > or
    #uses-stack

    $struc-returnals-space 0 > if { loop {
        $i $max-args = if { break }
        $formatter FMT:Formatter-write-indent
        $formatter "(local $s" FMT:Formatter-write
        $i $formatter U:i32-format
        $formatter ":a i32)\n" FMT:Formatter-write
        $i 1 + #i
    } }
    0 #i

    $locl-copy-count 0 > if {
        $formatter FMT:Formatter-write-indent
        $formatter "(local $locl-copy-spac:e i32)\n" FMT:Formatter-write
    }

    $uses-stack if {
        $formatter FMT:Formatter-write-indent
        $formatter "(local $stac:k i32)\n" FMT:Formatter-write
        $formatter FMT:Formatter-write-indent
        $struc-returnals-space 0 > if {
            $formatter "(local $struc-returnals-spac:e i32)\n" FMT:Formatter-write
            $formatter FMT:Formatter-write-indent
            $formatter "global.get $stac:k local.set $stac:k\n" FMT:Formatter-write
            $formatter FMT:Formatter-write-indent
            $formatter 4 $struc-returnals-space "struc-returnals-spac:e\n" generate-mem
        } else {
            $formatter "global.get $stac:k local.set $stac:k" FMT:Formatter-write
        }
    }
    $formatter $function generate-params-receiving
    $locl-copy-space 0 > if {
        $formatter FMT:Formatter-write-indent
        $formatter 4 $locl-copy-space "locl-copy-spac:e\n" generate-mem
    }
    $formatter $function AST:Function-memories generate-memories
    $formatter $function AST:Function-locals generate-struc-mems
    $formatter $struc-returnals-space-ptr $locl-copy-space-ptr $function AST:Function-body generate-words
    $uses-stack if {
        $formatter FMT:Formatter-write-indent
        $formatter "local.get $stac:k global.set $stac:k\n" FMT:Formatter-write
    }
    $function AST:Function-diverges if {
        loop {
            $i $function AST:Function-rets AST:Types-len = if { break }
            $formatter FMT:Formatter-write-indent
            $formatter "i32.const 0\n" FMT:Formatter-write
            $i 1 + #i
        }
    }
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter ")\n" FMT:Formatter-write
}

fn generate-functions(formatter: .FMT:Formatter, modules: .M:Modules) {
    local i: i32
    local j: i32
    local module: .M:Module
    local item: .AST:TopItem
    loop {
        $i $modules M:Modules-len = if { break }
        $modules $i M:Modules-get-value #module
        0 #j
        loop {
            $j $module M:Module-items AST:TopItems-len = if { break }
            $module M:Module-items $j AST:TopItems-get #item
            $item AST:TopItem-ty AST:TOP_ITEM_FN = if {
                $formatter $i $item AST:TopItem-function generate-function
            }
            $j 1 + #j
        }
        $i 1 + #i
    }
}

fn generate(formatter: .FMT:Formatter, stack-start: i32, mem: .S:String, modules: .M:Modules) {
    $formatter "(module\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent

    $formatter $modules generate-externs

    $formatter FMT:Formatter-write-indent
    $formatter "(memory 1 1024)\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
	$formatter "(export \"memory\" (memory 0))\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "(global $stac:k (mut i32) (i32.const " FMT:Formatter-write
    $stack-start $formatter U:i32-format
    $formatter "))\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "(func $intrinsic:flip (param $a i32) (param $b i32) (result i32 i32) local.get $b local.get $a)\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "(func $intrinsic:dupi32 (param $a i32) (result i32 i32) local.get $a local.get $a)\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "(func $intrinsic:rotate-left (param $a i32) (param $b i32) (param $c i32) (result i32 i32 i32) local.get $b local.get $c local.get $a)\n" FMT:Formatter-write

    $formatter $mem S:String-len $modules generate-global-mems

    $formatter $mem generate-static-mem
    $formatter "\n" FMT:Formatter-write

    $formatter $modules generate-functions

    $formatter FMT:Formatter-dedent
    $formatter ")" FMT:Formatter-write
}

