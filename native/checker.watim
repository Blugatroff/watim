import "../std/alloc.watim" as A
import "../std/io.watim" as IO
import "../std/map.watim" as MAP
import "../std/string.watim" as S
import "../std/str.watim" as STR
import "../std/core.watim" as CORE
import "../std/format.watim" as FMT
import "../std/i32vec.watim" as IV

import "./module.watim" as M
import "./ast.watim" as AST
import "./lexer.watim" as L
import "./util.watim" as U
import "./break_stack.watim" as BS
import "./intrinsic.watim" as INTR

fn check(modules: .M:Modules) {
    local i: i32
    loop {
        $i $modules M:Modules-len = if { break }
        $modules $modules $i M:Modules-get-value check-module
        $i 1 + #i
    }
}
fn check-module(modules: .M:Modules, module: .M:Module) {
    local items: .AST:TopItems
    local i: i32
    $module M:Module-items #items
    loop {
        $i $items AST:TopItems-len = if { break }
        $modules $module $items $i AST:TopItems-get check-item
        $i 1 + #i
    }
}
fn check-item(modules: .M:Modules, module: .M:Module, item: .AST:TopItem) {
    $item AST:TopItem-ty AST:TOP_ITEM_FN = if {
        $modules $module $item AST:TopItem-function check-function
    }
}

fn report-return-type-mismatch(stack: .AST:Types, function: .AST:Function) {
    local formatter: FMT:Formatter
    local msg: S:String
    FMT:Formatter-new #formatter
    &formatter "return type mismatch expected: " FMT:Formatter-write
    $function AST:Function-rets &formatter AST:Types-format
    &formatter " got: " FMT:Formatter-write
    $stack &formatter AST:Types-format
    $formatter FMT:Formatter-into-string #msg
    $function AST:Function-ident L:Token-location
    &msg S:String-unpack
    U:abort-with-location
    $msg S:String-free
}
fn check-function(modules: .M:Modules, module: .M:Module, function: .AST:Function) {
    local stack: .AST:Types
    local temp-types: .AST:Types
    local words: .AST:Words
    local bs: .BS:BreakStacks
    local i: i32
    local scope-id: IO:I32
    AST:Types-new #stack
    AST:Types-new #temp-types

    0 #scope-id.inner
    $scope-id.inner #function.locals.id

    $function AST:Function-body #words
    BS:BreakStacks-new #bs
    $temp-types $bs $modules $module $stack &function.locals &scope-id.inner $words check-words not if {
        // if the function does not diverge, aka does return
        // then check wheter the remaining stack matches the return type
        $stack AST:Types-len $function AST:Function-rets AST:Types-len /= if {
            $stack $function report-return-type-mismatch
        }
        loop {
            $i $function AST:Function-rets AST:Types-len = if { break }
            $stack $stack AST:Types-len 1 - $i - AST:Types-get 
            $function AST:Function-rets $function AST:Function-rets AST:Types-len 1 - $i - AST:Types-get 
            AST:Type-eq not if {
                $stack $function report-return-type-mismatch
            }
            $i 1 + #i
        }
    } else {
        0 0 = #function.diverges
    }

    $stack AST:Types-free-container
    0 #i 
    loop {
        $i $temp-types AST:Types-len = if { break }
        $module.types $temp-types $i AST:Types-get AST:Types-push
        $i 1 + #i
    }
    $temp-types AST:Types-free-container

    // $locals AST:Locals-free
    $bs BS:BreakStacks-free
}
fn check-words(
    temp-types: .AST:Types, 
    bs: .BS:BreakStacks, 
    modules: .M:Modules, 
    module: .M:Module,
    stack: .AST:Types,
    locals: .AST:Locals,
    scope-id: .i32,
    words: .AST:Words,
) -> bool {
    local i: i32
    local diverges: bool
    loop {
        $i $words AST:Words-len = if { break }
        $diverges
        $temp-types $bs $modules $module $stack $locals $scope-id $words $i AST:Words-get check-word
        or
        #diverges
        $i 1 + #i
    }
    $diverges
}

fn check-word(
    temp-types: .AST:Types,
    bs: .BS:BreakStacks,
    modules: .M:Modules,
    module: .M:Module,
    stack: .AST:Types,
    locals: .AST:Locals,
    scope-id: .i32,
    word: .AST:Word
) -> bool {
    loop {
        $word AST:Word-ty AST:WORD_NUMBER = if {
            $stack $temp-types AST:Type-new-int32 U:push-temp-type AST:Types-push
            0 1 = break
        }
        $word AST:Word-ty AST:WORD_STRING = if {
            $stack $temp-types $temp-types AST:Type-new-int32 U:push-temp-type AST:Type-new-ptr U:push-temp-type AST:Types-push
            $stack $temp-types AST:Type-new-int32 U:push-temp-type AST:Types-push
            0 1 = break
        }
        $word AST:Word-ty AST:WORD_CALL = if {
            $modules $module $stack $word check-call break
        }
        $word AST:Word-ty AST:WORD_LOOP = if {
            $temp-types $modules $module $stack $locals $scope-id $word check-lop break
        }
        $word AST:Word-ty AST:WORD_BREAK = if {
            $bs $stack $word check-brek break
        }
        $word AST:Word-ty AST:WORD_INTRINSIC = if {
            $temp-types $stack $word INTR:check-intrinsic break
        }
        $word AST:Word-ty AST:WORD_IF = if {
            $temp-types $bs $modules $module $stack $locals $scope-id $word check-iff break
        }
        $word AST:Word-ty AST:WORD_CAST = if {
            $stack $word check-cast break
        }
        $word AST:Word-ty AST:WORD_DEREF = if {
            $temp-types $stack $word check-deref break
        }
        $word AST:Word-ty AST:WORD_SET = if {
            $modules $module $stack $locals $word check-set break
        }
        $word AST:Word-ty AST:WORD_GET_REF = if {
            $stack $locals $temp-types $word check-get-ref break
        }
        $word AST:Word-ty AST:WORD_GET_LOCAL = if {
            $modules $module $stack $locals $word check-get-locl break
        }
        $word AST:Word-ty AST:WORD_LOAD = if {
            $stack $word check-load break
        }
        $word AST:Word-ty AST:WORD_SIZEOF = if {
            $word.qualifier !i32 0 = if {
                $module 
            } else {
                $modules $module $word.qualifier $word resolve-module
            } $word.ident ~ STR:Str-unpack M:Module-find-struc if {
                AST:Struct-size #word.number
            } else {
                drop
                $word AST:Word-location "struct not found\n" U:abort-with-location
            }
            $stack $temp-types AST:Type-new-int32 U:push-temp-type AST:Types-push
            0 1 = break
        }
        $word AST:Word-ty AST:WORD_STORE = if {
            $stack $modules $module $locals $word check-store break
        }
        $word AST:Word-ty AST:WORD_INIT_LOCAL = if {
            $stack $locals $word check-init-locl break
        }
        $word AST:Word-ty AST:WORD_ANNOTATION = if {
            $stack $word check-annotation break
        }
        $word AST:Word-location "unhandled word in checker\n" U:abort-with-location
        0 0 = break
    }
    $word AST:Word-mark-checked
}
fn check-annotation(stack: .AST:Types, word: .AST:Word) -> bool {
    $stack AST:Types-len 0 = if {
        $word AST:Word-location "cannot annotate empty stack\n" U:abort-with-location
    }
    $stack AST:Types-last @type
    $type $word.type AST:Type-eq not if {
        2 $word AST:Word-location L:print-location
        2 "Type mismatch with annotation:\n" IO:write-all IO:check
        2 "\t" IO:write-all IO:check
        $type 2 AST:Type-print
        2 "\n\t" IO:write-all IO:check
        $word.type 2 AST:Type-print
        2 "\n" IO:write-all IO:check
        1 CORE:exit
    }
    0 1 =
}
fn check-load(stack: .AST:Types, word: .AST:Word) -> bool {
    local type: .AST:Type
    $stack AST:Types-len 0 = if {
        $word AST:Word-location "expected pointer got []\n" U:abort-with-location
    }
    $stack AST:Types-pop #type
    $type AST:Type-ty AST:TYPE_PTR /= if {
        $word AST:Word-location "expected pointer" U:abort-with-location
    }
    $type AST:Type-child #type
    $stack $type AST:Types-push
    $type #word.type
    0 1 =
}
fn check-locl-fields-access(locals: .AST:Locals, word: .AST:Word) -> .AST:Type, .AST:Type, IV:I32Vec, bool {
    local locl: .AST:Local
    $locals $word AST:Word-ident ~ STR:Str-unpack 0 0 = AST:Locals-find if {
        #locl
        $locl.type $word check-fields-access 0 0 =
        $locl.shadow-id #word.shadow-id
        $locl.scope-id #word.scope-id
    } else {
        drop
        0 !.AST:Type 0 !.AST:Type IV:I32Vec-new 0 1 =
    }
}
fn check-fields-access(src-type: .AST:Type, word: .AST:Word) -> .AST:Type, .AST:Type, IV:I32Vec {
    local loads: IV:I32Vec
    local type: .AST:Type
    local offset: i32
    local field: .L:Token
    local struc: .AST:Struct
    local i: i32
    $src-type #type
    IV:I32Vec-new #loads
    loop {
        $i &word.fields L:Tokens-len = if { break }
        $i 0 = 
        $type AST:Type-ty AST:TYPE_STRUCT = 
        and 
        $type AST:Type-ty AST:TYPE_PTR = if { $type AST:Type-child AST:Type-ty AST:TYPE_STRUCT = } else { 0 1 = }
        or
        if { // value on the stack is a pointer to a struct
            0 #offset
            loop { // loop for every field access which can be reduced to one load with offset
                $i &word.fields L:Tokens-len = if { break }
                &word.fields $i L:Tokens-get #field

                $type AST:Type-ty AST:TYPE_PTR = if {
                    $type AST:Type-child #type
                }
                $type AST:Type-struc #struc
                $struc $field L:Token-lexeme ~ STR:Str-unpack AST:Struct-find-field not if {
                    $field L:Token-location "field not found" U:abort-with-location
                }
                $offset + #offset
                AST:Field-type #type
                $i 1 + #i
                $type AST:Type-ty AST:TYPE_STRUCT /= if {
                    break
                }
            }
            &loads $offset IV:I32Vec-push
        } else {
            $field L:Token-location "cannot access field of a non-struct type" U:abort-with-location
        }
    }
    $src-type $type $loads
}
fn check-get-locl(modules: .M:Modules, module: .M:Module, stack: .AST:Types, locals: .AST:Locals, word: .AST:Word) -> bool {
    local type: .AST:Type
    local loads: IV:I32Vec
    $locals $word check-locl-fields-access if {
        #loads #type drop
        $type #word.type
        $loads #word.loads
        $stack $type AST:Types-push
    } else {
        drop drop drop
        $module $word AST:Word-ident ~ STR:Str-unpack M:Module-find-mem if {
            $modules $module M:Modules-find-index #word.module
            AST:WORD_GET_GLOBAL #word.ty
            AST:Local-type $stack flip AST:Types-push
        } else {
            drop
            $word AST:Word-location "local not found\n" U:abort-with-location
        }
    }
    0 1 =
}
fn check-store(stack: .AST:Types, modules: .M:Modules, module: .M:Module, locals: .AST:Locals, word: .AST:Word) -> bool {
    local type: .AST:Type
    local loads: IV:I32Vec
    local src-type: .AST:Type
    local mem: .AST:Local
    $locals $word check-locl-fields-access if {
        #loads #type #src-type
        $type AST:Type-ty AST:TYPE_PTR =
        $src-type AST:Type-ty AST:TYPE_PTR =
        or not if {
            $word AST:Word-location "expected a pointer for the store instruction\n" U:abort-with-location
        }
        $type AST:Type-child #word.type
        $loads #word.loads
        $stack $type AST:Type-child $word U:expect-stack-one
        0 1 =
    } else {
        drop drop drop
        $module $word AST:Word-ident ~ STR:Str-unpack M:Module-find-mem if {
            #mem
            $modules $module M:Modules-find-index #word.module
            $mem AST:Local-type $word check-fields-access #loads #type #src-type
            AST:WORD_STORE_GLOBAL #word.ty
            $loads #word.loads
            $type AST:Type-child #word.type
            $stack $type AST:Type-child $word U:expect-stack-one
            &word.fields 2 L:Tokens-print
            // 2 "TODO at checker.watim:check-store" IO:write-all IO:check
            // 1 CORE:exit
        } else {
            drop
            $word AST:Word-location "local not found\n" U:abort-with-location
        }
        0 1 =
    }
}

fn check-get-ref(stack: .AST:Types, locals: .AST:Locals, temp-types: .AST:Types, word: .AST:Word) -> bool {
    local type: .AST:Type
    local struc: .AST:Struct
    local loads: IV:I32Vec
    local src-type: .AST:Type
    $locals $word check-locl-fields-access not if {
        $word AST:Word-location "local not found\n" U:abort-with-location
    }
    #loads #type #src-type
    $src-type AST:Type-ty AST:TYPE_STRUCT /= if {
        $src-type AST:Type-ty AST:TYPE_PTR = if {
            $src-type AST:Type-child AST:Type-ty AST:TYPE_STRUCT =
        } else { 0 1 = } not if {
            $word AST:Word-location "cannot get pointer of non-struct local" U:abort-with-location
        }
    }
    $loads #word.loads
    $type #word.type
    $stack $temp-types $type AST:Type-new-ptr U:push-temp-type AST:Types-push
    0 1 =
}
fn check-init-locl(stack: .AST:Types, locals: .AST:Locals, word: .AST:Word) -> bool {
    local type: .AST:Type
    local shadow-id: i32
    $stack AST:Types-len 0 = if {
        $word AST:Word-location "stack is empty\n" U:abort-with-location
    }
    $stack AST:Types-pop #word.type
    $locals $word.ident ~ STR:Str-unpack 0 1 = AST:Locals-find if {
        .shadow-id ~ 1 + #shadow-id
    } else {
        0 #shadow-id
        drop
    }
    IV:I32Vec-new #word.loads
    $locals.id #word.scope-id
    $shadow-id #word.shadow-id
    $locals AST:LOCAL_LOCAL $word.token $word.type $locals.id $shadow-id AST:Local-new AST:Locals-push
    0 1 =
}
fn check-set(modules: .M:Modules, module: .M:Module, stack: .AST:Types, locals: .AST:Locals, word: .AST:Word) -> bool {
    local type: .AST:Type
    local struc: .AST:Struct
    local loads: IV:I32Vec
    local src-type: .AST:Type
    $locals $word check-locl-fields-access not if {
        $word AST:Word-location "local not found\n" U:abort-with-location
    }
    #loads #type #src-type
    $loads #word.loads
    $type #word.type
    $stack $type $word U:expect-stack-one
    0 1 =
}
fn report-check-deref-error(stack: .AST:Types, word: .AST:Word) {
    local formatter: FMT:Formatter
    local msg: S:String
    FMT:Formatter-new #formatter
    &formatter "expected a pointer to a struct or a struct, got: " FMT:Formatter-write
    $stack &formatter AST:Types-format
    $formatter FMT:Formatter-into-string #msg
    $word AST:Word-location
    &msg S:String-unpack
    U:abort-with-location
    $msg S:String-free
}
fn check-deref(temp-types: .AST:Types, stack: .AST:Types, word: .AST:Word) -> bool {
    local type: .AST:Type
    $stack AST:Types-len 0 = if { 
        $stack $word report-check-deref-error
    }
    $stack AST:Types-last #type
    $type AST:Type-ty AST:TYPE_STRUCT = if {
        $stack AST:Types-pop #type
        $type AST:Type-struc
        $word AST:Word-ident ~ STR:Str-unpack
        $type #word.src-type
        AST:Struct-find-field if {
            #word.offset
            AST:Field-type #type
            $stack $type AST:Types-push
            $type #word.type
        } else {
            drop drop $word AST:Word-location "field not found" U:abort-with-location
        }
    } else {
        $type AST:Type-ty AST:TYPE_PTR /= if {
            $stack $word report-check-deref-error
        }
        $type AST:Type-child AST:Type-ty AST:TYPE_STRUCT /= if {
            $stack $word report-check-deref-error
        }
        $stack AST:Types-pop #type
        $type #word.src-type
        $type AST:Type-child AST:Type-struc 
        $word AST:Word-ident ~ STR:Str-unpack
        AST:Struct-find-field if {
            #word.offset
            AST:Field-type AST:Type-new-ptr $temp-types flip U:push-temp-type #type
            $stack $type AST:Types-push
            $type #word.type
        } else {
            drop drop $word AST:Word-location "field not found" U:abort-with-location
        }
    }
    0 1 =
}
fn check-cast(stack: .AST:Types, word: .AST:Word) -> bool {
    $stack AST:Types-len 0 = if { 
        $word AST:Word-location "expected [a] got []\n" U:abort-with-location
    }
    // TODO: don't allow all casts
    $stack $stack AST:Types-len 1 - AST:Types-get #word.src-type
    $stack AST:Types-pop drop
    $stack $word AST:Word-type AST:Types-push
    0 1 =
}
fn check-iff(
    temp-types: .AST:Types,
    bs: .BS:BreakStacks,
    modules: .M:Modules,
    module: .M:Module,
    stack: .AST:Types,
    locals: .AST:Locals,
    scope-id: .i32,
    word: .AST:Word
) -> bool {
    local iff: .AST:If
    local true-branch-diverges: bool
    local false-branch-diverges: bool
    local boolean: .AST:Type
    local iff-stack: .AST:Types
    local el-stack: .AST:Types
    local params: .AST:Types
    local rets: .AST:Types
    local i: i32

    AST:Type-new-boolean #boolean
    $stack $boolean $word U:expect-stack-one
    $boolean AST:Type-free

    $stack AST:Types-clone-container #iff-stack
    $stack AST:Types-clone-container #el-stack

    $iff-stack AST:Types-reset-min
    $el-stack AST:Types-reset-min

    0 1 = #true-branch-diverges
    0 1 = #false-branch-diverges

    $word AST:Word-iff #iff

    $locals #iff.locals.parent
    $scope-id ~ 1 + >>scope-id
    $scope-id ~ #iff.locals.id
    
    $temp-types $bs $modules $module $iff-stack &iff.locals $scope-id $iff AST:If-body check-words #true-branch-diverges

    $stack $iff-stack AST:Types-min $stack AST:Types-len AST:Types-clone-slice #params
    $iff-stack $iff-stack AST:Types-min $iff-stack AST:Types-len AST:Types-clone-slice #rets

    $iff.has-el if {
        $temp-types $bs $modules $module $el-stack &iff.locals $scope-id $iff AST:If-el check-words #false-branch-diverges
        loop {
            $iff-stack AST:Types-len $el-stack AST:Types-len /= if {
                0 0 = break
            }
            loop {
                $iff-stack AST:Types-len $i = if { 0 1 = break }
                $iff-stack $i AST:Types-get
                $el-stack $i AST:Types-get
                AST:Type-eq not if {
                    0 0 = break
                }
                $i 1 + #i
            } break
        } if {
            2 $word AST:Word-location L:print-location
            2 "Type mismatch in if branches:\n" IO:write-all IO:check
            2 "\tIf  : " IO:write-all IO:check
            $iff-stack 2 AST:Types-print
            2 "\n\tElse: " IO:write-all IO:check
            $el-stack 2 AST:Types-print
            2 "\n" IO:write-all IO:check
            1 CORE:exit
        }
    }

    // clear stack
    loop {
        $stack AST:Types-len 0 = if { break }
        $stack AST:Types-pop drop
    }
    // and replace with the iff-stack
    loop {
        $iff-stack AST:Types-len $stack AST:Types-len = if { break }
        $stack $iff-stack $stack AST:Types-len AST:Types-get AST:Types-push
    }

    $iff $params AST:If-set-params 
    $rets #iff.rets
    $iff-stack AST:Types-free-container
    $el-stack !i32 0 /= if {
        $el-stack AST:Types-free-container
    }

    $true-branch-diverges $false-branch-diverges or
}
fn check-brek(bs: .BS:BreakStacks, stack: .AST:Types, word: .AST:Word) -> bool {
    local break_stack: .BS:BreakStack
    $bs $word $stack AST:Types-clone-container BS:BreakStack-new BS:BreakStacks-push
    loop {
        0 $stack AST:Types-len = if { break }
        $stack AST:Types-pop drop
    }
    0 1 =
}
fn check-lop(
    temp-types: .AST:Types,
    modules: .M:Modules, 
    module: .M:Module,
    stack: .AST:Types,
    locals: .AST:Locals,
    scope-id: .i32,
    word: .AST:Word,
) -> bool {
    local bs: .BS:BreakStacks
    local i: i32
    BS:BreakStacks-new #bs

    $locals #word.lop.locals.parent
    $scope-id ~ 1 + >>scope-id
    $scope-id ~ #word.lop.locals.id

    $temp-types $bs $modules $module $stack &word.lop.locals $scope-id &word.lop.body check-words drop
    // TODO: check whether all breakstacks in `bs` are equal

    $bs BS:BreakStacks-len 0 = if {
        0 0 = 
        AST:Types-new #word.lop.rets
    } else {
        loop {
            $bs 0 BS:BreakStacks-get BS:BreakStack-types AST:Types-len $i = if { break }
            $stack $bs 0 BS:BreakStacks-get BS:BreakStack-types $i AST:Types-get AST:Types-push
            $i 1 + #i
        }
        $bs 0 BS:BreakStacks-get BS:BreakStack-types AST:Types-clone-container #word.lop.rets
        0 1 =
    }
    $bs BS:BreakStacks-free
}

fn check-call(modules: .M:Modules, module: .M:Module, stack: .AST:Types, word: .AST:Word) -> bool {
    local msg: S:String
    local function: .AST:Function
    local ext: .AST:Extern
    local params: .AST:Types
    local param-locals: .AST:Locals
    local ret: .AST:Types
    local locl: .AST:Local
    local i: i32
    $modules $module $word.qualifier $word resolve-module #module
    $module $word AST:Word-ident ~ STR:Str-unpack M:Module-find-function not if {
        drop drop
        "function: `" S:String-new #msg
        &msg $word AST:Word-ident ~ STR:Str-unpack S:String-append
        &msg "` not found\n" S:String-append
        $word AST:Word-location &msg S:String-unpack U:abort-with-location
        $msg S:String-free
    } else { 
        #function #ext
    }

    AST:Types-new #params
    $function !i32 0 /= if {
        $function AST:Function-locals #param-locals
        $function AST:Function-rets #ret
    } else {
        $ext AST:Extern-parameters #param-locals
        $ext AST:Extern-rets #ret
    }
    loop {
        $i $param-locals AST:Locals-len = if { break }
        $param-locals $i AST:Locals-get #locl
        $locl AST:Local-ty AST:LOCAL_ARGUMENT = if {
            $params $locl AST:Local-type AST:Types-push
        }
        $i 1 + #i
    }

    $ret AST:Types-clone-container #word.rets
    $modules $module M:Modules-find-index #word.module
    $stack 
    $params
    $word U:expect-stack
    $params AST:Types-free-container

    0 #i
    loop {
        $i $ret AST:Types-len = if { break }
        $stack $ret $i AST:Types-get AST:Types-push
        $i 1 + #i
    }
    0 1 = 
}

fn resolve-module(modules: .M:Modules, module: .M:Module, qualifier: .STR:Str, word: .AST:Word) -> .M:Module {
    local path: .S:String
    local b: bool
    $qualifier !i32 0 = if {
        $module
    } else {
        $module M:Module-imports $qualifier ~ STR:Str-unpack AST:Imports-get #b #path 
        $b if {
            $modules $path S:String-unpack M:Modules-get if {

            } else {
                $word AST:Word-location 
                "failed to find module\n"
                U:abort-with-location
            }
        } else {
            $word AST:Word-location 
            "failed to find import\n"
            U:abort-with-location
            0 !.M:Module
        }
    }
}

