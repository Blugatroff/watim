import "../std/alloc.watim" as A
import "../std/io.watim" as IO
import "../std/map.watim" as MAP
import "../std/string.watim" as S
import "../std/str.watim" as STR
import "../std/core.watim" as CORE
import "../std/format.watim" as FMT
import "../std/i32vec.watim" as IV

import "./module.watim" as M
import "./ast.watim" as AST
import "./lexer.watim" as L
import "./util.watim" as U
import "./break_stack.watim" as BS
import "./intrinsic.watim" as INTR
import "./main.watim" as MAIN

struct Checker {
    modules: .M:Modules
    table-index: i32
}
fn Checker-new(modules: .M:Modules) -> Checker {
    local self: Checker
    $modules #self.modules
    1 #self.table-index
    $self
}

fn check(modules: .M:Modules) -> i32 {
    $modules Checker-new @checker
    0 @i
    loop {
        $i $modules M:Modules-len = if { break }
        $modules $i M:Modules-get-value @module
        MAIN:logging-enabled if {
            2 "Typechecking module: " IO:write-all IO:check
            2 $module M:Module-path S:String-unpack IO:write-all IO:check
            2 "\n" IO:write-all IO:check
        }
        &checker $module check-module
        $i 1 + #i
    }
    $checker.table-index
}
fn check-module(self: .Checker, module: .M:Module) {
    local items: .AST:TopItems
    local i: i32
    $module M:Module-items #items
    loop {
        $i $items AST:TopItems-len = if { break }
        $self $module $items $i AST:TopItems-get check-item
        $i 1 + #i
    }
}
fn check-item(self: .Checker, module: .M:Module, item: .AST:TopItem) {
    $item AST:TopItem-ty AST:TOP_ITEM_FN = if {
        $self $module $item AST:TopItem-function check-function
    }
}

fn report-return-type-mismatch(stack: .AST:Types, function: .AST:Function) {
    local formatter: FMT:Formatter
    local msg: S:String
    FMT:Formatter-new #formatter
    &formatter "return type mismatch:\nexpected: " FMT:Formatter-write
    &formatter 0 !.AST:Types $function AST:Function-rets AST:Types-format
    &formatter "\ngot:      " FMT:Formatter-write
    &formatter 0 !.AST:Types $stack AST:Types-format
    &formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-into-string #msg
    $function AST:Function-ident L:Token-location
    &msg S:String-unpack
    U:abort-with-location
    $msg S:String-free
}
fn check-function(self: .Checker, module: .M:Module, function: .AST:Function) {
    local scope-id: CORE:I32
    0 #scope-id.inner

    AST:Types-new @stack
    AST:Types-new @temp-types

    $scope-id.inner #function.locals.id

    $function AST:Function-body @words
    BS:BreakStacks-new @bs
    $temp-types $bs $self $module $stack &function.locals &scope-id.inner $words check-words not if {
        // if the function does not diverge, aka does return
        // then check whether the remaining stack matches the return type
        $stack AST:Types-len $function AST:Function-rets AST:Types-len /= if {
            $stack $function report-return-type-mismatch
        }
        0 @i
        loop {
            $i $function AST:Function-rets AST:Types-len = if { break }
            $stack $stack AST:Types-len 1 - $i - AST:Types-get 
            $function AST:Function-rets $function AST:Function-rets AST:Types-len 1 - $i - AST:Types-get 
            AST:Type-eq not if {
                $stack $function report-return-type-mismatch
            }
            $i 1 + #i
        }
    } else {
        0 0 = #function.diverges
    }

    $stack AST:Types-free-container
    0 @i 
    loop {
        $i $temp-types AST:Types-len = if { break }
        $module.types $temp-types $i AST:Types-get AST:Types-push
        $i 1 + #i
    }
    $temp-types AST:Types-free-container

    // $locals AST:Locals-free
    $bs BS:BreakStacks-free
}
fn check-words(
    temp-types: .AST:Types, 
    bs: .BS:BreakStacks, 
    self: .Checker,
    module: .M:Module,
    stack: .AST:Types,
    locals: .AST:Locals,
    scope-id: .i32,
    words: .AST:Words,
) -> bool {
    local i: i32
    local diverges: bool
    loop {
        $i $words AST:Words-len = if { break }
        $diverges
        $temp-types $bs $self $module $stack $locals $scope-id $words $i AST:Words-get check-word
        or
        #diverges
        $i 1 + #i
    }
    $diverges
}

fn check-word(
    temp-types: .AST:Types,
    bs: .BS:BreakStacks,
    self: .Checker,
    module: .M:Module,
    stack: .AST:Types,
    locals: .AST:Locals,
    scope-id: .i32,
    word: .AST:Word
) -> bool {
    loop {
        $word AST:Word-ty AST:WORD_NUMBER = if {
            $stack $temp-types AST:Type-new-int32 U:push-temp-type AST:Types-push
            0 1 = break
        }
        $word AST:Word-ty AST:WORD_STRING = if {
            $stack $temp-types $temp-types AST:Type-new-int32 U:push-temp-type AST:Type-new-ptr U:push-temp-type AST:Types-push
            $stack $temp-types AST:Type-new-int32 U:push-temp-type AST:Types-push
            0 1 = break
        }
        $word AST:Word-ty AST:WORD_CALL = if {
            $self $module $stack $word check-call break
        }
        $word AST:Word-ty AST:WORD_LOOP = if {
            $temp-types $self $module $stack $locals $scope-id $word check-lop break
        }
        $word AST:Word-ty AST:WORD_BREAK = if {
            $bs $stack $word check-brek break
        }
        $word AST:Word-ty AST:WORD_INTRINSIC = if {
            $temp-types $stack $word INTR:check-intrinsic break
        }
        $word AST:Word-ty AST:WORD_IF = if {
            $temp-types $bs $self $module $stack $locals $scope-id $word check-iff break
        }
        $word AST:Word-ty AST:WORD_CAST = if {
            $stack $word check-cast break
        }
        $word AST:Word-ty AST:WORD_DEREF = if {
            $temp-types $stack $word check-deref break
        }
        $word AST:Word-ty AST:WORD_SET = if {
            $stack $locals $word check-set break
        }
        $word AST:Word-ty AST:WORD_GET_REF = if {
            $stack $locals $temp-types $word check-get-ref break
        }
        $word AST:Word-ty AST:WORD_GET_LOCAL = if {
            $self $module $stack $locals $word check-get-locl break
        }
        $word AST:Word-ty AST:WORD_LOAD = if {
            $stack $word check-load break
        }
        $word AST:Word-ty AST:WORD_SIZEOF = if {
            $stack $temp-types AST:Type-new-int32 U:push-temp-type AST:Types-push
            0 1 = break
        }
        $word AST:Word-ty AST:WORD_STORE = if {
            $stack $self $module $locals $word check-store break
        }
        $word AST:Word-ty AST:WORD_INIT_LOCAL = if {
            $stack $locals $word check-init-locl break
        }
        $word AST:Word-ty AST:WORD_ANNOTATION = if {
            $stack $word check-annotation break
        }
        $word AST:Word-ty AST:WORD_ARRAY_WRITE = if {
            $stack $word check-array-write break
        }
        $word AST:Word-ty AST:WORD_ARRAY_READ = if {
            $stack $word check-array-read break
        }
        $word AST:Word-ty AST:WORD_ARRAY_REF = if {
            $stack $word $temp-types check-array-ref break
        }
        $word AST:Word-ty AST:WORD_BLOCK = if {
            $temp-types $self $module $stack $locals $scope-id $word check-blok break
        }
        $word AST:Word-ty AST:WORD_ARRAY_INIT = if {
            // TODO: this results in miscompilation when the break is missing
            $stack $word $temp-types check-array-init break
        }
        $word AST:Word-ty AST:WORD_ARRAY_INIT_ZERO = if {
            $stack $word $temp-types check-array-init-zero break
        }
        $word AST:Word-ty AST:WORD_CALL_INDIRECT = if {
            $stack $word check-call-indirect break
        }
        $word AST:Word-ty AST:WORD_REF_FUNCTION = if {
            $temp-types $self $module $stack $word check-ref-function break
        }
        $word AST:Word-location " unhandled word in checker\n" U:abort-with-location
        0 0 = break
    }
    $word AST:Word-mark-checked
}

fn check-ref-function(temp-types: .AST:Types, self: .Checker, module: .M:Module, stack: .AST:Types, word: .AST:Word) -> bool {
    $self $module $stack $word 1 1 = check-function-usage drop @rets @params
    
    $stack 

    $temp-types
    $params
    $rets AST:Type-new-function 
    U:push-temp-type 

    AST:Types-push

    0 1 =
}

fn check-call-indirect(stack: .AST:Types, word: .AST:Word) -> bool {
    $stack AST:Types-len 0 = if {
        $word AST:Word-location "call indirect expected function pointer\n" U:abort-with-location
    }
    $stack AST:Types-pop @fn-type
    $stack $fn-type.function.args $word U:expect-stack

    $fn-type.function.args AST:Types-clone-container
    $fn-type.function.rets AST:Types-clone-container
    AST:Type-new-function #word.type

    $fn-type.function.rets @rets

    0 @i
    loop {
        $i $rets AST:Types-len = if { break }
        $rets $i AST:Types-get @type
        $stack $type AST:Types-push
        $i 1 + #i
    }
    0 1 =
}

fn check-array-init(stack: .AST:Types, word: .AST:Word, temp-types: .AST:Types) -> bool {
    $word.number @len
    $stack AST:Types-len $len lt if {
        $word AST:Word-location "not enough values on stack to construct array\n" U:abort-with-location
    }
    $stack AST:Types-len 0 = if {
        $word AST:Word-location "empty arrays not yet supported\n" U:abort-with-location
    }
    $stack AST:Types-pop @elem-type
    $elem-type #word.type

    $len 1 - #len
    loop {
        $len 0 = if { break }
        $stack AST:Types-pop @type
        $type $elem-type AST:Type-eq not if {
            $word AST:Word-location "all elements in array need to be of the same type\n" U:abort-with-location
        }
        $len 1 - #len
    }

    $temp-types $elem-type $word.number AST:Type-new-array U:push-temp-type 
    @array-type

    $stack $array-type AST:Types-push
    $array-type #word.type
    0 1 =
}

fn check-array-init-zero(stack: .AST:Types, word: .AST:Word, temp-types: .AST:Types) -> bool {
    2 "check-array-init-zero TODO\n" IO:write-all IO:check // TODO
    1 CORE:exit
    0 1 =
}

fn check-array-write(stack: .AST:Types, word: .AST:Word) -> bool {
    $stack AST:Types-len 3 lt if {
        $word AST:Word-location "expected at least 3 arguments for array write\n" U:abort-with-location
    }
    $stack AST:Types-pop @type
    $stack AST:Types-pop @index-type
    $index-type AST:Type-ty AST:TYPE_I32 /= if {
        $word AST:Word-location "can only index array with i32\n" U:abort-with-location
    }
    $stack AST:Types-pop @array-type
    $array-type AST:Type-ty AST:TYPE_PTR /= if {
        $word $array-type array-access-mismatch 1 CORE:exit
    }   
    $array-type AST:Type-child AST:Type-child $type AST:Type-eq not if {
        $word $array-type array-access-mismatch 1 CORE:exit
    }
    0 1 =
}

fn array-access-mismatch(word: .AST:Word, array-type: .AST:Type) {
    2 $word AST:Word-location L:print-location
    2 "Type mismatch in array access:" IO:write-all IO:check
    2 "\n\t expected: .[a: n]" IO:write-all IO:check
    2 "\n\t got:      " IO:write-all IO:check
    2 0 !.AST:Types $array-type AST:Type-print
    2 "\n" IO:write-all IO:check
}
fn check-array-read(stack: .AST:Types, word: .AST:Word) -> bool {
    $stack AST:Types-len 2 lt if {
        $word AST:Word-location "expected at least 2 arguments for array read\n" U:abort-with-location
    }
    $stack AST:Types-pop @index-type
    $index-type AST:Type-ty AST:TYPE_I32 /= if {
        $word AST:Word-location "can only read array with i32 index\n" U:abort-with-location
    }
    $stack AST:Types-pop @array-type
    $array-type AST:Type-ty AST:TYPE_PTR /= if {
        $word $array-type array-access-mismatch 1 CORE:exit
    }
    $array-type AST:Type-child AST:Type-ty AST:TYPE_ARRAY /= if {
        $word $array-type array-access-mismatch 1 CORE:exit
    }
    $array-type AST:Type-child AST:Type-child #word.type
    $stack $array-type AST:Type-child AST:Type-child AST:Types-push
    0 1 =
}
fn check-array-ref(stack: .AST:Types, word: .AST:Word, temp-types: .AST:Types) -> bool {
    $stack AST:Types-len 2 lt if {
        $word AST:Word-location "expected at least 2 arguments for array read\n" U:abort-with-location
    }
    $stack AST:Types-pop @index-type
    $index-type AST:Type-ty AST:TYPE_I32 /= if {
        $word AST:Word-location "can only read array with i32 index\n" U:abort-with-location
    }
    $stack AST:Types-pop @array-type
    $array-type AST:Type-ty AST:TYPE_PTR /= if {
        $word $array-type array-access-mismatch 1 CORE:exit
    }
    $array-type AST:Type-child AST:Type-ty AST:TYPE_ARRAY /= if {
        $word $array-type array-access-mismatch 1 CORE:exit
    }
    $array-type AST:Type-child AST:Type-child #word.type
    $stack 
    $temp-types
    $array-type AST:Type-child AST:Type-child AST:Type-new-ptr U:push-temp-type
    AST:Types-push
    0 1 =
}
fn check-annotation(stack: .AST:Types, word: .AST:Word) -> bool {
    $stack AST:Types-len 0 = if {
        $word AST:Word-location "cannot annotate empty stack\n" U:abort-with-location
    }
    $stack AST:Types-last @type
    $type $word.type AST:Type-eq not if {
        2 $word AST:Word-location L:print-location
        2 " Type mismatch with annotation:\n\t" IO:write-all IO:check
        2 0 !.AST:Types $type AST:Type-print
        2 "\n\t" IO:write-all IO:check
        2 0 !.AST:Types $word.type AST:Type-print
        2 "\n" IO:write-all IO:check
        1 CORE:exit
    }
    0 1 =
}
fn check-load(stack: .AST:Types, word: .AST:Word) -> bool {
    local type: .AST:Type
    $stack AST:Types-len 0 = if {
        $word AST:Word-location "expected pointer got []\n" U:abort-with-location
    }
    $stack AST:Types-pop #type
    $type AST:Type-ty AST:TYPE_PTR /= if {
        $word AST:Word-location "expected pointer" U:abort-with-location
    }
    $type AST:Type-child #type
    $stack $type AST:Types-push
    $type #word.type
    0 1 =
}
fn check-locl-fields-access(locals: .AST:Locals, word: .AST:Word) -> .AST:Type, .AST:Type, bool {
    local locl: .AST:Local
    $locals $word AST:Word-ident ~ STR:Str-unpack 0 0 = AST:Locals-find if {
        #locl
        $locl.type
        $locl.type $word check-fields-access 0 0 =
        $locl.shadow-id #word.shadow-id
        $locl.scope-id #word.scope-id
    } else {
        drop
        0 !.AST:Type 0 !.AST:Type 0 1 =
    }
}
fn check-fields-access(src-type: .AST:Type, word: .AST:Word) -> .AST:Type {
    local loads: IV:I32Vec
    local type: .AST:Type
    local struc: .AST:Struct
    local i: i32
    $src-type #word.src-type
    $src-type #type
    loop {
        $i &word.fields L:Tokens-len = if { break }
        $i 0 = 
        $type AST:Type-ty AST:TYPE_STRUCT = 
        and 
        $type AST:Type-ty AST:TYPE_PTR = if { $type AST:Type-child AST:Type-ty AST:TYPE_STRUCT = } else { 0 1 = }
        or
        not if {
            $word.token L:Token-location "cannot access field of a non-struct type" U:abort-with-location
        }
        // value on the stack is a pointer to a struct
        loop { // loop for every field access which can be reduced to one load with offset
            $i &word.fields L:Tokens-len = if { break }

            &word.fields $i L:Tokens-get @field
            $type AST:Type-ty AST:TYPE_PTR = if {
                $type AST:Type-child #type
            }
            $type AST:Type-struc #struc
            // TODO: move this entire function to code gen instead of type checking
            $struc $field L:Token-lexeme ~ STR:Str-unpack AST:Struct-find-field not if {
                $field L:Token-location "field not found" U:abort-with-location
            }
            AST:Field-type #type
            $i 1 + #i
            $type AST:Type-ty AST:TYPE_STRUCT /= if {
                break
            }
        }
    }
    $type
}
fn check-get-locl(self: .Checker, module: .M:Module, stack: .AST:Types, locals: .AST:Locals, word: .AST:Word) -> bool {
    $locals $word check-locl-fields-access if {
        @type @src-type

        $type AST:Type-ty AST:TYPE_GENERIC = 
        $src-type AST:Type-ty AST:TYPE_STRUCT = 
        and if {
            $src-type.generics $type.generic AST:Types-get #type
        }

        $type #word.type
        $stack $type AST:Types-push
    } else {
        drop drop
        $module $word AST:Word-ident ~ STR:Str-unpack M:Module-find-mem if {
            $self.modules $module M:Modules-find-index #word.module
            AST:WORD_GET_GLOBAL #word.ty
            AST:Local-type $stack flip AST:Types-push
        } else {
            drop
            $word AST:Word-location "local not found\n" U:abort-with-location
        }
    }
    0 1 =
}
fn check-store(stack: .AST:Types, self: .Checker, module: .M:Module, locals: .AST:Locals, word: .AST:Word) -> bool {
    local type: .AST:Type
    local src-type: .AST:Type
    local mem: .AST:Local
    $locals $word check-locl-fields-access if {
        #type #src-type
        $type AST:Type-ty AST:TYPE_PTR =
        $src-type AST:Type-ty AST:TYPE_PTR =
        or not if {
            $word AST:Word-location "expected a pointer for the store instruction\n" U:abort-with-location
        }
        $type AST:Type-child #word.type
        $stack $type AST:Type-child $word U:expect-stack-one
        0 1 =
    } else {
        drop drop
        $module $word AST:Word-ident ~ STR:Str-unpack M:Module-find-mem if {
            #mem
            $self.modules $module M:Modules-find-index #word.module
            $mem AST:Local-type $word check-fields-access #type
            AST:WORD_STORE_GLOBAL #word.ty
            $type AST:Type-child #word.type
            $stack $type AST:Type-child $word U:expect-stack-one
            2 &word.fields L:Tokens-print
            // 2 "TODO at checker.watim:check-store" IO:write-all IO:check
            // 1 CORE:exit
        } else {
            drop
            $word AST:Word-location "local not found\n" U:abort-with-location
        }
        0 1 =
    }
}
fn check-deref(temp-types: .AST:Types, stack: .AST:Types, word: .AST:Word) -> bool {
    $stack AST:Types-len 0 = if {
        $word AST:Word-location "stack is empty\n" U:abort-with-location
    }
    $stack AST:Types-pop #word.src-type
    $word.src-type $word check-fields-access #word.type

    $word.src-type AST:Type-ty AST:TYPE_PTR = if {
        $stack $temp-types $word.type AST:Type-new-ptr U:push-temp-type AST:Types-push
    } else {
        $stack $temp-types $word.type AST:Type-new-ptr U:push-temp-type AST:Types-push
        // $stack $word.type AST:Types-push
    }
    0 1 =
}
fn check-get-ref(stack: .AST:Types, locals: .AST:Locals, temp-types: .AST:Types, word: .AST:Word) -> bool {
    $locals $word check-locl-fields-access not if {
        $word AST:Word-location "local not found\n" U:abort-with-location
    }
    @type @src-type
    $src-type AST:Type-ty AST:TYPE_STRUCT /= 
    $src-type AST:Type-ty AST:TYPE_ARRAY /= and
    if {
        $src-type AST:Type-ty AST:TYPE_PTR = if {
            $src-type AST:Type-child AST:Type-ty AST:TYPE_STRUCT =
        } else { 0 1 = } not if {
            $word AST:Word-location "cannot get pointer of non-struct local" U:abort-with-location
        }
    }
    $type AST:Type-ty AST:TYPE_GENERIC = 
    $src-type AST:Type-ty AST:TYPE_STRUCT = 
    and if {
        $src-type.generics $type.generic AST:Types-get #type
    }

    $type #word.type
    $stack $temp-types $type AST:Type-new-ptr U:push-temp-type AST:Types-push
    0 1 =
}
fn check-init-locl(stack: .AST:Types, locals: .AST:Locals, word: .AST:Word) -> bool {
    local type: .AST:Type
    local shadow-id: i32
    $stack AST:Types-len 0 = if {
        $word AST:Word-location "stack is empty\n" U:abort-with-location
    }
    $stack AST:Types-pop #word.type
    $locals $word.ident ~ STR:Str-unpack 0 1 = AST:Locals-find if {
        @locl
        $locl.shadow-id 1 + #shadow-id
    } else {
        0 #shadow-id
        drop
    }
    $locals.id #word.scope-id
    $shadow-id #word.shadow-id

    $locals 
    AST:LOCAL_LOCAL $word.token $word.type $locals.id $shadow-id AST:Local-new 
    AST:Locals-push

    0 1 =
}
fn check-set(stack: .AST:Types, locals: .AST:Locals, word: .AST:Word) -> bool {
    local type: .AST:Type
    local struc: .AST:Struct
    local src-type: .AST:Type
    $locals $word check-locl-fields-access not if {
        $word AST:Word-location "local not found\n" U:abort-with-location
    }
    #type #src-type
    $type #word.type
    $stack $type $word U:expect-stack-one
    0 1 =
}
fn check-cast(stack: .AST:Types, word: .AST:Word) -> bool {
    $stack AST:Types-len 0 = if { 
        $word AST:Word-location "expected [a] got []\n" U:abort-with-location
    }
    // TODO: don't allow all casts
    $stack $stack AST:Types-len 1 - AST:Types-get #word.src-type
    $stack AST:Types-pop drop

    $stack $word AST:Word-type AST:Types-push
    0 1 =
}
fn check-iff(
    temp-types: .AST:Types,
    bs: .BS:BreakStacks,
    self: .Checker,
    module: .M:Module,
    stack: .AST:Types,
    locals: .AST:Locals,
    scope-id: .i32,
    word: .AST:Word
) -> bool {
    local iff: .AST:If
    local params: .AST:Types
    local rets: .AST:Types
    local i: i32

    AST:Type-new-boolean @boolean
    $stack $boolean $word U:expect-stack-one
    $boolean AST:Type-free

    $stack AST:Types-clone-container @iff-stack
    $stack AST:Types-clone-container @el-stack

    $iff-stack AST:Types-reset-min
    $el-stack AST:Types-reset-min

    0 1 = @true-branch-diverges
    0 1 = @false-branch-diverges

    $word AST:Word-iff #iff

    $locals #iff.locals.parent
    $scope-id ~ 1 + =>scope-id
    $scope-id ~ #iff.locals.id
    
    $temp-types $bs $self $module $iff-stack &iff.locals $scope-id $iff AST:If-body check-words #true-branch-diverges

    $stack $iff-stack AST:Types-min $stack AST:Types-len AST:Types-clone-slice #params
    $iff-stack $iff-stack AST:Types-min $iff-stack AST:Types-len AST:Types-clone-slice #rets

    $iff.has-el if {
        $temp-types $bs $self $module $el-stack &iff.locals $scope-id $iff AST:If-el check-words #false-branch-diverges
        loop {
            $iff-stack AST:Types-len $el-stack AST:Types-len /= if {
                0 0 = break
            }
            loop {
                $iff-stack AST:Types-len $i = if { 0 1 = break }
                $iff-stack $i AST:Types-get
                $el-stack $i AST:Types-get
                AST:Type-eq not if {
                    0 0 = break
                }
                $i 1 + #i
            } break
        } if {
            2 $word AST:Word-location L:print-location
            2 "Type mismatch in if branches:\n" IO:write-all IO:check
            2 "\tIf  : " IO:write-all IO:check
            2 0 !.AST:Types $iff-stack AST:Types-print
            2 "\n\tElse: " IO:write-all IO:check
            2 0 !.AST:Types $el-stack AST:Types-print
            2 "\n" IO:write-all IO:check
            1 CORE:exit
        }
    }

    // clear stack
    loop {
        $stack AST:Types-len 0 = if { break }
        $stack AST:Types-pop drop
    }
    // and replace with the iff-stack
    loop {
        $iff-stack AST:Types-len $stack AST:Types-len = if { break }
        $stack $iff-stack $stack AST:Types-len AST:Types-get AST:Types-push
    }

    $iff $params AST:If-set-params 
    $rets #iff.rets
    $iff-stack AST:Types-free-container
    $el-stack !i32 0 /= if {
        $el-stack AST:Types-free-container
    }

    $true-branch-diverges $false-branch-diverges or
}

fn check-brek(bs: .BS:BreakStacks, stack: .AST:Types, word: .AST:Word) -> bool {
    local break_stack: .BS:BreakStack
    $bs $word $stack AST:Types-clone-container BS:BreakStack-new BS:BreakStacks-push
    loop {
        0 $stack AST:Types-len = if { break }
        $stack AST:Types-pop drop
    }
    0 1 =
}

fn check-lop(
    temp-types: .AST:Types,
    self: .Checker,
    module: .M:Module,
    stack: .AST:Types,
    locals: .AST:Locals,
    scope-id: .i32,
    word: .AST:Word,
) -> bool {
    local bs: .BS:BreakStacks
    local i: i32
    BS:BreakStacks-new #bs

    $locals #word.lop.locals.parent
    $scope-id ~ 1 + =>scope-id
    $scope-id ~ #word.lop.locals.id

    $temp-types $bs $self $module $stack &word.lop.locals $scope-id &word.lop.body check-words drop
    $bs "loop" check-brek-stacks

    $bs BS:BreakStacks-len 0 = if {
        0 0 = 
        AST:Types-new #word.lop.rets
    } else {
        loop {
            $bs 0 BS:BreakStacks-get BS:BreakStack-types AST:Types-len $i = if { break }
            $stack $bs 0 BS:BreakStacks-get BS:BreakStack-types $i AST:Types-get AST:Types-push
            $i 1 + #i
        }
        $bs 0 BS:BreakStacks-get BS:BreakStack-types AST:Types-clone-container #word.lop.rets
        0 1 =
    }
    $bs BS:BreakStacks-free
}

fn check-brek-stacks(bs: .BS:BreakStacks, name-ptr: .i32, name-len: i32) { 
    local first: .BS:BreakStack 
    local i: i32
    loop {
    $bs BS:BreakStacks-len 0 = if { break }

    // TODO: $bs 0 BS:BreakStacks-get @first
    $bs 0 BS:BreakStacks-get #first
    
    1 @i
    loop {
        $i $bs BS:BreakStacks-len = if { 0 0 = break }
        $bs $i BS:BreakStacks-get BS:BreakStack-types $first BS:BreakStack-types AST:Types-eq not if {
            0 1 = break
        }
        $i 1 + #i
    } not if {
        $bs $name-ptr $name-len report-brek-stack-mismatch
    }
    break
} }

fn report-brek-stack-mismatch(bs: .BS:BreakStacks, name-ptr: .i32, name-len: i32) {
    2 "type mismatch in " IO:write-all IO:check
    2 $name-ptr $name-len IO:write-all IO:check
    2 ":\n" IO:write-all IO:check
    0 @i
    loop {
        $i $bs BS:BreakStacks-len = if { break }
        $bs $i BS:BreakStacks-get @stack
        2 "\t" IO:write-all IO:check
        2 $stack.word AST:Word-location L:print-location
        2 ": " IO:write-all IO:check
        2 0 !.AST:Types $stack.types AST:Types-print
        2 "\n" IO:write-all IO:check
        $i 1 + #i
    }
    1 CORE:exit
}

fn check-blok(
    temp-types: .AST:Types,
    self: .Checker,
    module: .M:Module,
    stack: .AST:Types,
    locals: .AST:Locals,
    scope-id: .i32,
    word: .AST:Word
) -> bool {
    BS:BreakStacks-new @bs

    $locals #word.blok.locals.parent
    $scope-id ~ 1 + =>scope-id
    $scope-id ~ #word.blok.locals.id
    
    $stack AST:Types-len @orig-stack-len
    $temp-types $bs $self $module $stack &word.blok.locals $scope-id &word.blok.body check-words @diverges

    AST:Types-new @remaining-types
    $orig-stack-len @i
    loop {
        $i $stack AST:Types-len ge if { break }
        $remaining-types $stack $i AST:Types-get AST:Types-push
        $i 1 + #i
    }
    loop {
        $stack AST:Types-len $orig-stack-len le if { break }
        $stack AST:Types-pop drop
    }
    $bs $word $remaining-types BS:BreakStack-new BS:BreakStacks-push
    $bs "block" check-brek-stacks

    $bs BS:BreakStacks-len 0 = if {
        AST:Types-new #word.blok.rets
    } else {
        0 @i
        loop {
            $bs 0 BS:BreakStacks-get BS:BreakStack-types AST:Types-len $i = if { break }
            $stack $bs 0 BS:BreakStacks-get BS:BreakStack-types $i AST:Types-get AST:Types-push
            $i 1 + #i
        }
        $bs 0 BS:BreakStacks-get BS:BreakStack-types AST:Types-clone-container #word.blok.rets
    }
    $bs BS:BreakStacks-free
    $diverges
}

fn check-function-usage(self: .Checker, module: .M:Module, stack: .AST:Types, word: .AST:Word, mark-indirect: bool) -> .AST:Types, .AST:Types, .M:Module {
    local locl: .AST:Local
    $self.modules $module $word.qualifier $word resolve-module #module
    $module $word AST:Word-ident ~ STR:Str-unpack M:Module-find-function not if {
        drop drop
        "function: `" S:String-new @msg
        &msg $word AST:Word-ident ~ STR:Str-unpack S:String-append
        &msg "` not found\n" S:String-append
        $word AST:Word-location &msg S:String-unpack U:abort-with-location
    } else { 
        #word.function #word.ext
    }

    $word.function !i32 0 /= if {
        $word.function AST:Function-locals
        $word.function AST:Function-rets
        &word.function.generics
        $mark-indirect if { 
            $self.table-index $self.table-index 1 + #self.table-index #word.function.table-index 
        }
    } else {
        $word.ext AST:Extern-parameters
        $word.ext AST:Extern-rets
        $mark-indirect if { 
            $self.table-index $self.table-index 1 + #self.table-index #word.ext.table-index 
        }
        0 !.AST:Generics
    } @generics @ret @param-locals

    $word.generics 0 !.AST:Types = if { 0 } else { 
        $word.generics AST:Types-len 
    } @number-generics-call
    $generics 0 !.AST:Generics = if { 0 } else { $generics AST:Generics-len } @number-generics-function
 
    $number-generics-call
    $number-generics-function
    /= if {
        $word AST:Word-location "mismatched number of generics" U:abort-with-location
    }

    $word.generics 0 !.AST:Types /= // there are generic arguments
    $generics 0 !.AST:Generics /=   // the function has generics
    and if {
        AST:Types-new @instance
        0 @i
        loop {
            $generics AST:Generics-len $i = if { break }

            $instance 
            $word.generics $i AST:Types-get
            AST:Types-push

            $i 1 + #i
        }
        $instance
    } else {
        0 !.AST:Types
    } @instance

    AST:Types-new @params
    0 @instance-index
    0 @i
    loop {
        $i $param-locals AST:Locals-len = if { break }
        $param-locals $i AST:Locals-get #locl
        $locl AST:Local-ty AST:LOCAL_ARGUMENT = if {
            $params $locl AST:Local-type @type

            $type AST:Type-ty AST:TYPE_GENERIC = 
            $instance 0 !.AST:Types /= and if {
                $instance $instance-index AST:Types-get
                AST:Types-push
                $instance-index 1 + #instance-index
            } else {
                $type AST:Types-push
            }
        }
        $i 1 + #i
    }

    $word.function !i32 0 /= $instance 0 !.AST:Types /= and if {
        $word.function.instances $instance AST:TypesTypes-contains if {
            #word.instance-index
            $instance AST:Types-free-container
        } else {
            drop
            $word.function.instances AST:TypesTypes-len #word.instance-index
            $word.function.instances $instance AST:TypesTypes-push
        }
    } else {
        0 #word.instance-index
    }

    $params $ret $module
}

fn check-call(self: .Checker, module: .M:Module, stack: .AST:Types, word: .AST:Word) -> bool {
    $self $module $stack $word 0 1 = check-function-usage #module @ret @params
    $ret AST:Types-clone-container #word.rets
    $self.modules $module M:Modules-find-index #word.module

    $stack 
    $params
    $word U:expect-stack
    $params AST:Types-free-container

    0 @i
    loop {
        $i $ret AST:Types-len = if { break }
        $ret $i AST:Types-get @type
        $type AST:Type-ty AST:TYPE_GENERIC = if {
            $word.generics $type.generic AST:Types-get
        } else {
            $type
        } @resolved-type
        $stack $resolved-type AST:Types-push
        $i 1 + #i
    }
    0 1 = 
}

fn resolve-module(modules: .M:Modules, module: .M:Module, qualifier: .STR:Str, word: .AST:Word) -> .M:Module {
    local path: .S:String
    local b: bool
    $qualifier !i32 0 = if {
        $module
    } else {
        $module M:Module-imports $qualifier ~ STR:Str-unpack AST:Imports-get #b #path 
        $b if {
            $modules $path S:String-unpack M:Modules-get if {

            } else {
                $word AST:Word-location 
                "failed to find module\n"
                U:abort-with-location
            }
        } else {
            $word AST:Word-location 
            "failed to find import\n"
            U:abort-with-location
            0 !.M:Module
        }
    }
}

