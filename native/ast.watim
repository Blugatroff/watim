import "../std/alloc.watim" as A
import "../std/string.watim" as S
import "../std/str.watim" as STR
import "../std/i32vec.watim" as IV
import "../std/io.watim" as IO
import "../std/core.watim" as CORE
import "../std/util.watim" as U
import "../std/map.watim" as M
import "../std/format.watim" as FMT

import "./lexer.watim" as L

fn INTRINSIC_ADD() -> i32 { 1 }
fn INTRINSIC_STORE() -> i32 { 2 }
fn INTRINSIC_STORE8() -> i32 { 3 }
fn INTRINSIC_LOAD8() -> i32 { 5 }
fn INTRINSIC_DROP() -> i32 { 6 }
fn INTRINSIC_SUB() -> i32 { 7 }
fn INTRINSIC_EQ() -> i32 { 8 }
fn INTRINSIC_NOT_EQ() -> i32 { 9 }
fn INTRINSIC_MOD() -> i32 { 10 }
fn INTRINSIC_DIV() -> i32 { 11 }
fn INTRINSIC_AND() -> i32 { 12 }
fn INTRINSIC_NOT() -> i32 { 13 }
fn INTRINSIC_OR() -> i32 { 14 }
fn INTRINSIC_LESS() -> i32 { 15 }
fn INTRINSIC_GREATER() -> i32 { 16 }
fn INTRINSIC_LESS_EQ() -> i32 { 17 }
fn INTRINSIC_GREATER_EQ() -> i32 { 18 }
fn INTRINSIC_MUL() -> i32 { 19 }
fn INTRINSIC_ROTR() -> i32 { 20 }
fn INTRINSIC_ROTL() -> i32 { 21 }
fn INTRINSIC_MEM_GROW() -> i32 { 22 }
fn INTRINSIC_MEM_COPY() -> i32 { 23 }
fn INTRINSIC_FLIP() -> i32 { 24 }

fn intrinsic-name(intrinsic: i32) -> .i32, i32 {
    loop {
        $intrinsic INTRINSIC_ADD = if { "INTRINSIC_ADD" break }
        $intrinsic INTRINSIC_STORE = if { "INTRINSIC_STORE" break }
        $intrinsic INTRINSIC_STORE8 = if { "INTRINSIC_STORE8" break }
        $intrinsic INTRINSIC_LOAD8 = if { "INTRINSIC_LOAD8" break }
        $intrinsic INTRINSIC_DROP = if { "INTRINSIC_DROP" break }
        $intrinsic INTRINSIC_SUB = if { "INTRINSIC_SUB" break }
        $intrinsic INTRINSIC_EQ = if { "INTRINSIC_EQ" break }
        $intrinsic INTRINSIC_NOT_EQ = if { "INTRINSIC_NOT_EQ" break }
        $intrinsic INTRINSIC_MOD = if { "INTRINSIC_MOD" break }
        $intrinsic INTRINSIC_DIV = if { "INTRINSIC_DIV" break }
        $intrinsic INTRINSIC_AND = if { "INTRINSIC_AND" break }
        $intrinsic INTRINSIC_NOT = if { "INTRINSIC_NOT" break }
        $intrinsic INTRINSIC_OR = if { "INTRINSIC_OR" break }
        $intrinsic INTRINSIC_LESS = if { "INTRINSIC_LESS" break }
        $intrinsic INTRINSIC_GREATER = if { "INTRINSIC_GREATER" break }
        $intrinsic INTRINSIC_LESS_EQ = if { "INTRINSIC_LESS_EQ" break }
        $intrinsic INTRINSIC_GREATER_EQ = if { "INTRINSIC_GREATER_EQ" break }
        $intrinsic INTRINSIC_MUL = if { "INTRINSIC_MUL" break }
        $intrinsic INTRINSIC_ROTR = if { "INTRINSIC_ROTR" break }
        $intrinsic INTRINSIC_ROTL = if { "INTRINSIC_ROTL" break }
        $intrinsic INTRINSIC_MEM_GROW = if { "INTRINSIC_MEM_GROW" break }
        $intrinsic INTRINSIC_MEM_COPY = if { "INTRINSIC_MEM_COPY" break }
        $intrinsic INTRINSIC_FLIP = if { "INTRINSIC_FLIP" break }

        2 "INVALID INTRINSIC " IO:write-all IO:check
        $intrinsic IO:print
        1 CORE:exit
    }
}

fn WORD_CALL() -> i32 { 1 }
fn WORD_NUMBER() -> i32 { 5 }
fn WORD_INTRINSIC() -> i32 { 6 }
fn WORD_IF() -> i32 { 7 }
fn WORD_LOOP() -> i32 { 8 }
fn WORD_BREAK() -> i32 { 9 }
fn WORD_STRING() -> i32 { 10 }
fn WORD_FIELD() -> i32 { 11 }
fn WORD_CAST() -> i32 { 12 }
fn WORD_DEREF() -> i32 { 13 }
fn WORD_GET_GLOBAL() -> i32 { 14 }
fn WORD_SET() -> i32 { 15 }
fn WORD_GET_REF() -> i32 { 16 }
fn WORD_GET_LOCAL() -> i32 { 17 }
fn WORD_LOAD() -> i32 { 18 }
fn WORD_SIZEOF() -> i32 { 19 }
fn WORD_STORE() -> i32 { 20 }
fn WORD_STORE_GLOBAL() -> i32 { 21 }
fn WORD_INIT_LOCAL() -> i32 { 22 }
fn WORD_ANNOTATION() -> i32 { 23 }

fn word-ty-name(ty: i32) -> .i32, i32 {
    loop {
        $ty WORD_CALL = if { "WORD_CALL" break }
        $ty WORD_NUMBER = if { "WORD_NUMBER" break }
        $ty WORD_INTRINSIC = if { "WORD_INTRINSIC" break }
        $ty WORD_IF = if { "WORD_IF" break }
        $ty WORD_LOOP = if { "WORD_LOOP" break }
        $ty WORD_BREAK = if { "WORD_BREAK" break }
        $ty WORD_STRING = if { "WORD_STRING" break }
        $ty WORD_FIELD = if { "WORD_FIELD" break }
        $ty WORD_CAST = if { "WORD_CAST" break }
        $ty WORD_DEREF = if { "WORD_DEREF" break }
        $ty WORD_GET_GLOBAL = if { "WORD_GET_GLOBAL" break }
        $ty WORD_SET = if { "WORD_SET" break }
        $ty WORD_GET_REF = if { "WORD_GET_REF" break }
        $ty WORD_GET_LOCAL = if { "WORD_GET_LOCAL" break }
        $ty WORD_LOAD = if { "WORD_LOAD" break }
        $ty WORD_SIZEOF = if { "WORD_SIZEOF" break }
        $ty WORD_STORE = if { "WORD_STORE" break }
        $ty WORD_STORE_GLOBAL = if { "WORD_STORE_GLOBAL" break }
        $ty WORD_ANNOTATION = if { "WORD_ANNOTATION" break }
        "INVALID WORD TY" break
    }
}

struct Words {
    ptr: .Word
    len: i32
    cap: i32
}
fn Words-new() -> Words {
    local self: Words
    0 !.Word #self.ptr
    0 #self.len
    0 #self.cap
    $self
}
fn Words-len(self: .Words) -> i32 {
    $self.len
}
fn Words-get(self: .Words, index: i32) -> .Word {
    $index $self.len >= if {
        2 "Words: Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    $self.ptr $index sizeof(Word) * +
}
fn Words-push(self: .Words, word: Word) {
    local new-buf: .Word
    local size: i32
    local dst-ptr: .Word
    $self.len 1 + $self.cap <= if {
        $self.ptr $self.len sizeof(Word) * + #dst-ptr
        $word >>dst-ptr
        $self.len 1 + #self.len
    } else {
        $self.cap 2 CORE:max 2 * #size
        $size sizeof(Word) * A:alloc !.Word #new-buf
        $self.ptr !.i32
        $new-buf !.i32
        $self.len sizeof(Word) *
        CORE:copy
        $size #self.cap
        $self.len 0 > if {
            $self.ptr !.i32 A:free
        }
        $new-buf #self.ptr
        $self $word Words-push
    }
}
fn Words-pop(self: .Words) -> Word {
    $self.len 0 = if {
        2 "Cannot pop from empty Words" IO:write-all IO:check
        1 CORE:exit
    }
    $self $self.len 1 - Words-get ~
    $self.len 1 - #self.len
}
fn Words-free(self: Words) {
    loop {
        $self.len 0 = if { break }
        &self Words-pop Word-free
    }
    $self.cap 0 > if { $self.ptr !.i32 A:free }
}

fn TYPE_I32() -> i32 { 1 }
fn TYPE_I64() -> i32 { 2 }
fn TYPE_BOOL() -> i32 { 3 }
fn TYPE_PTR() -> i32 { 4 }
fn TYPE_STRUCT() -> i32 { 5 }

fn type-ty-name(ty: i32) -> .i32, i32 {
    loop {
        $ty TYPE_I32 = if { "TYPE_I32" break }
        $ty TYPE_I64 = if { "TYPE_I64" break }
        $ty TYPE_BOOL = if { "TYPE_BOOL" break }
        $ty TYPE_PTR = if { "TYPE_PTR" break }
        $ty TYPE_STRUCT = if { "TYPE_STRUCT" break }
        "invalid TYPE TY" break
    }
}

struct Type {
    ty: i32
    // for TYPE_PTR
    child: .Type // actually of type .Type but recursive type not yet possible
    // for TYPE_STRUCT
    ident: .L:Token
    module: .L:Token
    struc: .Struct // actually of type .Struct but indirect recursive type not yet possible
}
fn Type-size(self: .Type) -> i32 {
    $self.ty TYPE_STRUCT = if { 
        $self Type-struc Struct-size
    } else {
        4
    }
}
fn Type-eq(a: .Type, b: .Type) -> bool {
    loop {
        $a $b = if { 0 0 = break }
        $a.ty $b.ty /= if { 0 1 = break }
        $a.ty TYPE_PTR = if {
            $a Type-child $b Type-child Type-eq break
        }
        $a.ty TYPE_STRUCT = if {
            $a.struc $b.struc = break
        }
        0 0 = break
    }
}
fn Type-new(ty: i32) -> .Type {
    local self: .Type
    20 A:alloc !.Type #self
    $ty #self.ty
    0 !.Type #self.child
    $self
}
fn Type-clone(self: .Type) -> .Type {
    local new: .Type
    sizeof(Type) A:alloc !.Type #new
    $self !.i32 $new !.i32 20 CORE:copy
    $new
}
fn Type-new-int32() -> .Type {
    TYPE_I32 Type-new
}
fn Type-new-int64() -> .Type {
    TYPE_I64 Type-new
}
fn Type-new-boolean() -> .Type {
    TYPE_BOOL Type-new
}
fn Type-new-ptr(child: .Type) -> .Type {
    local self: .Type
    TYPE_PTR Type-new #self
    $child !.Type #self.child
    $self
}
fn Type-new-struc(module: .L:Token, ident: .L:Token) -> .Type {
    local self: .Type
    TYPE_STRUCT Type-new #self
    $module #self.module
    $ident #self.ident
    0 !.Struct #self.struc
    $self
}
fn Type-set-struc(self: .Type, struc: .Struct) {
    $struc !.Struct #self.struc
}
fn Type-module(self: .Type) -> .L:Token {
    $self.module
}
fn Type-ident(self: .Type) -> .L:Token {
    $self.ident
}
fn Type-struc(self: .Type) -> .Struct {
    $self.struc !.Struct
}
fn Type-free(self: .Type) {
    $self !.i32 A:free
}
fn Type-ty(self: .Type) -> i32 {
    $self.ty
}
fn Type-child(self: .Type) -> .Type {
    $self.child !.Type
}
fn Type-format(self: .Type, formatter: .FMT:Formatter) {
    loop {
        $self Type-ty TYPE_I32 = if { $formatter "i32" FMT:Formatter-write break }
        $self Type-ty TYPE_I64 = if { $formatter "i64" FMT:Formatter-write break }
        $self Type-ty TYPE_BOOL = if { $formatter "bool" FMT:Formatter-write break }
        $self Type-ty TYPE_PTR = if { 
            $formatter "." FMT:Formatter-write
            $self Type-child $formatter Type-format
            break
        }
        $self Type-ty TYPE_STRUCT = if {
            $self.module !i32 0 /= if {
                $formatter $self.module L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
                $formatter ":" FMT:Formatter-write
            }
            $formatter $self Type-struc Struct-ident L:Token-lexeme ~ STR:Str-unpack FMT:Formatter-write
            break
        }
        2 "Type-format unhandled Type-ty: " IO:write-all IO:check
        2 $self Type-ty type-ty-name IO:write-all IO:check
        2 "\n" IO:write-all IO:check
        0 0 / drop
        1 CORE:exit
    }
}
fn Type-print(self: .Type, fd: i32) {
    FMT:Formatter-new @formatter
    $self &formatter Type-format
    $formatter FMT:Formatter-into-string @string
    $fd &string S:String-unpack IO:write-all IO:check
    $string S:String-free
}

struct Types {
    inner: IV:I32Vec
    min-size: i32
}
fn Types-new() -> .Types {
    local self: .Types
    sizeof(Types) A:alloc !.Types #self
    IV:I32Vec-new #self.inner
    $self
}
fn Types-free(self: .Types) {
    local i: i32
    loop {
        $i &self.inner IV:I32Vec-len = if { break }
        &self.inner $i IV:I32Vec-get !.Type Type-free
        $i 1 + #i
    }
    $self Types-free-container
}
fn Types-reset-min(self: .Types) {
    $self Types-len #self.min-size
}
fn Types-min(self: .Types) -> i32 {
    $self.min-size
}
fn Types-clone-container(self: .Types) -> .Types {
    local new: .Types
    sizeof(Types) A:alloc !.Types #new
    &self.inner IV:I32Vec-clone #new.inner
    $self Types-min #new.min-size
    $new
}
fn Types-free-container(self: .Types) {
    $self.inner IV:I32Vec-free
    $self !.i32 A:free
}
fn Types-push(self: .Types, f: .Type) {
    &self.inner $f !i32 IV:I32Vec-push
}
fn Types-pop(self: .Types) -> .Type {
    &self.inner IV:I32Vec-pop !.Type
    $self Types-min $self Types-len CORE:min #self.min-size
}
fn Types-clone-slice(self: .Types, start: i32, end: i32) -> .Types {
    local new: .Types
    Types-new #new
    loop {
        $start $end = if { break }
        $new $self $start Types-get Type-clone Types-push
        $start 1 + #start
    }
    $new
}
fn Types-len(self: .Types) -> i32 {
    &self.inner IV:I32Vec-len
}
fn Types-get(self: .Types, index: i32) -> .Type {
    &self.inner $index IV:I32Vec-get !.Type
}
fn Types-format(self: .Types, formatter: .FMT:Formatter) {
    local i: i32
    0 $self Types-len = if {
        $formatter "[]" FMT:Formatter-write
    } else {
        $formatter "[" FMT:Formatter-write
        loop {
            $i $self Types-len = if { break }
            $self $i Types-get $formatter Type-format
            $i 1 + $self Types-len < if {
                $formatter ", " FMT:Formatter-write
            }
            $i 1 + #i
        }
        $formatter "]" FMT:Formatter-write
    }
}
fn Types-print(self: .Types, fd: i32) {
    local formatter: FMT:Formatter
    local out: S:String
    FMT:Formatter-new #formatter
    $self &formatter Types-format
    $formatter FMT:Formatter-into-string #out
    $fd &out S:String-unpack IO:write-all IO:check
    $out S:String-free
}
fn Types-last(self: .Types) -> .Type {
    $self $self Types-len 1 - Types-get
}

struct If {
    token: .L:Token
    body: Words
    has-el: bool
    el: Words
    params: .Types
    rets: .Types
    locals: Locals
}
fn If-new(token: .L:Token, body: Words) -> .If {
    local self: .If
    sizeof(If) A:alloc !.If #self
    $token #self.token
    $body #self.body
    0 1 = #self.has-el
    0 !.Types #self.params
    0 !.Types #self.rets
    Locals-new #self.locals
    $self
}
fn If-new-with-el(token: .L:Token, body: Words, el: Words) -> .If {
    local self: .If
    sizeof(If) A:alloc !.If #self
    $token #self.token
    $body #self.body
    0 0 = #self.has-el
    $el #self.el
    0 !.Types #self.params
    0 !.Types #self.rets
    Locals-new #self.locals
    $self
}
fn If-free(self: .If) {
    $self.body Words-free
    $self.has-el if {
        $self.el Words-free
    }
    $self.params !i32 0 /= if {
        $self.params Types-free
    }
    $self.rets !i32 0 /= if {
        $self.rets Types-free
    }
    $self.locals Locals-free
    $self !.i32 A:free
}
fn If-body(self: .If) -> .Words {
    &self.body
}
fn If-el(self: .If) -> .Words {
    &self.el
}
fn If-params(self: .If) -> .Types {
    $self.params
}
fn If-set-params(self: .If, params: .Types) {
    $params #self.params
}

struct Loop {
    token: .L:Token
    body: Words
    rets: .Types
    locals: Locals
}
fn Loop-new(token: .L:Token, body: Words) -> .Loop {
    local self: .Loop
    sizeof(Loop) A:alloc !.Loop #self
    $token #self.token
    $body #self.body
    Locals-new #self.locals
    $self
}
fn Loop-free(self: .Loop) {
    $self.body Words-free
    $self.locals Locals-free
    $self.rets 0 !.Types /= if { $self.rets Types-free-container }
    $self !.i32 A:free
}

struct Word {
    ty: i32
    token: .L:Token
    ident: .STR:Str
    offset: i32
    qualifier: .STR:Str
    number: i32
    intrinsic: i32
    addr: i32
    size: i32
    offset: i32
    module: i32
    fields: L:Tokens
    loads: IV:I32Vec
    lop: .Loop
    rets: .Types
    iff: .If
    type: .Type
    src-type: .Type
    string: S:String
    checked: bool
    shadow-id: i32
    scope-id: i32
}
fn Word-new(ty: i32, token: .L:Token) -> Word {
    local self: Word
    $ty #self.ty
    $token #self.token
    0 1 = #self.checked
    0 !.STR:Str #self.qualifier
    0 #self.shadow-id
    0 #self.scope-id
    $self
}
fn Word-new-annotation(token: .L:Token, type: .Type) -> Word {
    WORD_ANNOTATION $token Word-new @word
    $type #word.type
    $word
}
fn Word-free(self: Word) {
    $self.ty WORD_IF = if {
        $self.iff If-free
    }
    $self.ty WORD_LOOP = if {
        $self.lop Loop-free
    }
    $self.ty WORD_SET = 
    $self.ty WORD_GET_REF = or
    $self.ty WORD_GET_LOCAL = or
    $self.ty WORD_STORE = or
    $self.ty WORD_GET_GLOBAL = or
    if {
        $self.fields L:Tokens-free-container
    }
    $self.ty WORD_SET = 
    $self.ty WORD_GET_REF = or
    $self.ty WORD_GET_LOCAL = or
    $self.ty WORD_STORE = or
    $self.ty WORD_INIT_LOCAL = or
    $self.checked and
    if {
        $self.loads IV:I32Vec-free
    }
    $self.ty WORD_CALL =
    $self.checked and
    if {
        $self.rets Types-free-container
    }
    $self.ty WORD_STRING = if {
        $self.string S:String-free
    }
}
fn Word-mark-checked(self: .Word) {
    1 1 = #self.checked
}
fn Word-location(self: .Word) -> .i32, i32, i32, i32 {
    $self.token L:Token-location
}
fn Word-ty(self: .Word) -> i32 {
    $self.ty
}
fn Word-type(self: .Word) -> .Type {
    $self.type
}
fn Word-iff(self: .Word) -> .If {
    $self.iff
}
fn Word-ident(self: .Word) -> .STR:Str {
    $self.ident
}
fn Word-rets(self: .Word) -> .Types {
    $self.rets
}
fn Word-intrinsic(self: .Word) -> i32 {
    $self.intrinsic
}
fn Word-module(self: .Word) -> i32 {
    $self.module
}

fn LOCAL_ARGUMENT() -> i32 { 1 }
fn LOCAL_LOCAL() -> i32 { 2 }
fn LOCAL_MEMORY() -> i32 { 3 }

fn locl-ty-name(ty: i32) -> .i32, i32 {
    loop {
        $ty LOCAL_ARGUMENT = if { "LOCAL_ARGUMENT" break }
        $ty LOCAL_LOCAL = if { "LOCAL_LOCAL" break }
        $ty LOCAL_MEMORY = if { "LOCAL_MEMORY" break }
        "invalid local ty" break
    }
}

struct Local {
    ident: .L:Token
    type: .Type
    ty: i32
    size: i32
    address: i32
    shadow-id: i32
    scope-id: i32
}
fn Local-new(ty: i32, ident: .L:Token, type: .Type, scope-id: i32, shadow-id: i32) -> .Local {
    local self: .Local
    sizeof(Local) A:alloc !.Local #self
    $ty #self.ty
    $ident #self.ident
    $type #self.type
    $shadow-id #self.shadow-id
    $scope-id #self.scope-id
    $self
}
fn Local-new-mem(ident: .L:Token, type: .Type, size: i32) -> .Local {
    local self: .Local
    LOCAL_MEMORY $ident $type Type-new-ptr 0 0 Local-new #self
    $size #self.size
    $self
}
fn Local-ty(self: .Local) -> i32 {
    $self.ty
}
fn Local-ident(self: .Local) -> .L:Token {
    $self.ident
}
fn Local-type(self: .Local) -> .Type {
    $self.type
}
fn Local-free(self: .Local) {
    $self.ty LOCAL_MEMORY = if {
        $self.type $self.type Type-child #self.type Type-free
    }
    $self !.i32 A:free
}

struct Locals {
    inner: IV:I32Vec
    parent: .Locals
    id: i32
}
fn Locals-new() -> Locals {
    local self: Locals
    IV:I32Vec-new #self.inner
    0 !.Locals #self.parent
    0 #self.id
    $self
}
fn Locals-len(self: .Locals) -> i32 {
    &self.inner IV:I32Vec-len
}
fn Locals-get(self: .Locals, index: i32) -> .Local {
    &self.inner $index IV:I32Vec-get !.Local
}
fn Locals-find(self: .Locals, ident-ptr: .i32, ident-len: i32, search-parents: bool) -> .Local, bool {
    local i: i32
    $self Locals-len 0 /= if {
        $self Locals-len 1 - #i
        loop {
            $self $i Locals-get .ident ~ L:Token-lexeme ~ STR:Str-unpack $ident-ptr $ident-len STR:str-eq if {
                $self $i Locals-get 1 1 = break
            }
            // TODO: figure out why this isn't properly type checked
            0 $i = if { 
                $self.parent 0 !.Locals /= $search-parents and if {
                    $self.parent $ident-ptr $ident-len $search-parents Locals-find break
                } else {
                    0 0 1 = break 
                }
            }
            $i 1 - #i
        }
    } else { 
        $self.parent 0 !.Locals /= $search-parents and if {
            $self.parent $ident-ptr $ident-len $search-parents Locals-find
        } else {
            0 !.Local 0 1 = 
        }
    }
}
fn Locals-push(self: .Locals, locl: .Local) {
    &self.inner $locl !i32 IV:I32Vec-push
}
fn Locals-pop(self: .Locals) -> .Local {
    &self.inner IV:I32Vec-pop !.Local
}
fn Locals-free(self: Locals) {
    local i: i32
    loop {
        0 &self Locals-len = if { break }
        &self Locals-pop Local-free
    }
    $self.inner IV:I32Vec-free
}
fn Locals-contains-mem-or-struc(self: .Locals) -> bool {
    local i: i32
    loop {
        $i $self Locals-len = if { 0 1 = break }
        $self $i Locals-get Local-ty LOCAL_MEMORY =
        $self $i Locals-get Local-type Type-ty TYPE_STRUCT = or if {
            0 0 = break 
        }
        $i 1 + #i
    }
}

struct Function {
    ident: .L:Token
    export: .L:Token
    ret: .Types
    locals: Locals
    body: Words
    diverges: bool
    reachable: bool
}
fn Function-new(
    ident: .L:Token, 
    export: .L:Token, 
    ret: .Types,
    locals: Locals,
    body: Words
) -> .Function {
    local self: .Function
    sizeof(Function) A:alloc !.Function #self
    $ident #self.ident
    $export #self.export
    $ret #self.ret
    $locals #self.locals
    $body #self.body
    0 1 = #self.diverges
    $self
}
fn Function-free(self: .Function) {
    $self.ret Types-free-container
    $self.body Words-free
    $self.locals Locals-free
    $self !.i32 A:free
}
fn Function-rets(self: .Function) -> .Types {
    $self.ret
}
fn Function-locals(self: .Function) -> .Locals {
    &self.locals
}
fn Function-body(self: .Function) -> .Words {
    &self.body
}
fn Function-ident(self: .Function) -> .L:Token {
    $self.ident
}
fn Function-diverges(self: .Function) -> bool {
    $self.diverges
}
fn Function-has-mem-or-struc-locl(self: .Function) -> bool {
    $self Function-locals Locals-contains-mem-or-struc
}
fn Function-mark-reachable(self: .Function) {
    1 1 = #self.reachable
}

struct Extern {
    module: .L:Token
    name: .L:Token
    ident: .L:Token
    params: Locals
    rets: .Types
    reachable: bool
}
fn Extern-new(
    module: .L:Token,
    name: .L:Token,
    ident: .L:Token,
    params: Locals,
    rets: .Types
) -> .Extern {
    local self: .Extern
    sizeof(Extern) A:alloc !.Extern #self
    $module #self.module
    $name #self.name
    $ident #self.ident
    $params #self.params
    $rets #self.rets
    0 1 = #self.reachable
    $self
}
fn Extern-module(self: .Extern) -> .L:Token {
    $self.module
}
fn Extern-name(self: .Extern) -> .L:Token {
    $self.name
}
fn Extern-rets(self: .Extern) -> .Types {
    $self.rets
}
fn Extern-parameters(self: .Extern) -> .Locals {
    &self.params
}
fn Extern-ident(self: .Extern) -> .L:Token {
    $self.ident
}
fn Extern-mark-reachable(self: .Extern) {
    1 1 = #self.reachable
}
fn Extern-free(self: .Extern) {
    $self.params Locals-free
    $self.rets Types-free-container
    $self !.i32 A:free
}

struct Import {
    path: .L:Token
    ident: .L:Token
}
fn Import-new(path: .L:Token, ident: .L:Token) -> .Import {
    local self: .Import
    sizeof(Import) A:alloc !.Import #self
    $path #self.path
    $ident #self.ident
    $self
}
fn Import-free(self: .Import) {
    $self !.i32 A:free
}
fn Import-path(self: .Import) -> .L:Token {
    $self.path
}
fn Import-ident(self: .Import) -> .L:Token {
    $self.ident
}
fn Import-path-content(self: .Import) -> .i32, i32 {
    $self Import-path L:Token-lexeme ~ 1 STR:Str-drop 1 STR:Str-drop-end STR:Str-unpack 
}

struct Field {
    ident: .L:Token
    type: .Type
}
fn Field-new(ident: .L:Token, type: .Type) -> .Field {
    local self: .Field
    sizeof(Field) A:alloc !.Field #self
    $ident #self.ident
    $type #self.type
    $self
}
fn Field-free(self: .Field) {
    $self !.i32 A:free
}
fn Field-ident(self: .Field) -> .L:Token {
    $self.ident
}
fn Field-type(self: .Field) -> .Type {
    $self.type
}
struct Fields {
    inner: IV:I32Vec
}
fn Fields-new() -> .Fields {
    local self: .Fields
    sizeof(Fields) A:alloc !.Fields #self
    IV:I32Vec-new #self.inner
    $self
}
fn Fields-push(self: .Fields, item: .Field) {
    &self.inner $item !i32 IV:I32Vec-push
}
fn Fields-free(self: .Fields) {
    local i: i32
    loop {
        $i &self.inner IV:I32Vec-len = if { break }
        &self.inner $i IV:I32Vec-get !.Field Field-free
        $i 1 + #i
    }
    $self.inner IV:I32Vec-free
    $self !.i32 A:free
}
fn Fields-len(self: .Fields) -> i32 {
    &self.inner IV:I32Vec-len
}
fn Fields-get(self: .Fields, index: i32) -> .Field {
    &self.inner $index IV:I32Vec-get !.Field
}
struct Struct {
    ident: .L:Token
    fields: .Fields
}
fn Struct-new(ident: .L:Token, fields: .Fields) -> .Struct {
    local self: .Struct
    sizeof(Struct) A:alloc !.Struct #self
    $ident #self.ident
    $fields #self.fields
    $self
}
fn Struct-free(self: .Struct) {
    $self.fields Fields-free
    $self !.i32 A:free
}
fn Struct-ident(self: .Struct) -> .L:Token {
    $self.ident
}
fn Struct-fields(self: .Struct) -> .Fields {
    $self.fields
}
fn Struct-find-field(self: .Struct, ident-ptr: .i32, ident-len: i32) -> .Field, i32, bool {
    local i: i32
    local fields: .Fields
    local offset: i32
    $self Struct-fields #fields
    loop {
        $i $fields Fields-len = if { 0 !.Field 0 0 1 = break }
        $fields $i Fields-get Field-ident L:Token-lexeme ~ STR:Str-unpack $ident-ptr $ident-len STR:str-eq if {
            $fields $i Fields-get
            $offset 0 0 = break
        }
        $offset $fields $i Fields-get Field-type Type-size + #offset
        $i 1 + #i
    }
}
fn Struct-size(self: .Struct) -> i32 {
    local size: i32
    local i: i32
    loop {
        $i $self Struct-fields Fields-len = if { break }
        $size 
        $self Struct-fields $i Fields-get Field-type Type-size
        + #size
        $i 1 + #i
    }
    $size
}

fn TOP_ITEM_FN() -> i32 { 1 }
fn TOP_ITEM_MEM() -> i32 { 2 }
fn TOP_ITEM_IMPORT() -> i32 { 3 }
fn TOP_ITEM_STRUCT() -> i32 { 4 }
fn TOP_ITEM_EXT() -> i32 { 5 }

fn top-item-ty-name(ty: i32) -> .i32, i32 {
    loop {
        $ty TOP_ITEM_FN = if { "TOP_ITEM_FN" break }
        $ty TOP_ITEM_MEM = if { "TOP_ITEM_MEM" break }
        $ty TOP_ITEM_IMPORT = if { "TOP_ITEM_IMPORT" break }
        $ty TOP_ITEM_STRUCT = if { "TOP_ITEM_STRUCT" break }
        $ty TOP_ITEM_EXT = if { "TOP_ITEM_EXT" break }
        "UNVALID TOP_ITEM TY" break
    }
}

struct TopItem {
    ty: i32
    function: .Function
    mem: .Local
    ext: .Extern
    imp: .Import
    struc: .Struct
}
fn TopItem-new(ty: i32) -> .TopItem {
    local self: .TopItem
    sizeof(TopItem) A:alloc !.TopItem #self
    $ty #self.ty
    $self
}
fn TopItem-new-function(f: .Function) -> .TopItem {
    local self: .TopItem
    TOP_ITEM_FN TopItem-new #self
    $f #self.function
    $self
}
fn TopItem-new-mem(mem: .Local) -> .TopItem {
    local self: .TopItem
    TOP_ITEM_MEM TopItem-new #self
    $mem #self.mem
    $self
}
fn TopItem-new-ext(ext: .Extern) -> .TopItem {
    local self: .TopItem
    TOP_ITEM_EXT TopItem-new #self
    $ext #self.ext
    $self
}
fn TopItem-new-imp(imp: .Import) -> .TopItem {
    local self: .TopItem
    TOP_ITEM_IMPORT TopItem-new #self
    $imp  #self.imp
    $self
}
fn TopItem-new-struc(struc: .Struct) -> .TopItem {
    local self: .TopItem
    TOP_ITEM_STRUCT TopItem-new #self
    $struc #self.struc
    $self
}
fn TopItem-ty(self: .TopItem) -> i32 {
    $self.ty
}
fn TopItem-struc(self: .TopItem) -> .Struct {
    $self.struc
}
fn TopItem-function(self: .TopItem) -> .Function {
    $self.function
}
fn TopItem-ext(self: .TopItem) -> .Extern {
    $self.ext
}
fn TopItem-free(self: .TopItem) {
    $self TopItem-ty TOP_ITEM_FN = if {
        $self.function Function-free
    }
    $self TopItem-ty TOP_ITEM_MEM = if {
        $self.mem Local-free
    }
    $self TopItem-ty TOP_ITEM_EXT = if {
        $self.ext Extern-free
    }
    $self TopItem-ty TOP_ITEM_IMPORT = if {
        $self.imp Import-free
    }
    $self TopItem-ty TOP_ITEM_STRUCT = if {
        $self.struc Struct-free
    }
    $self !.i32 A:free
}

struct TopItems {
    inner: IV:I32Vec
}
fn TopItems-new() -> .TopItems {
    local self: .TopItems
    sizeof(TopItems) A:alloc !.TopItems #self
    IV:I32Vec-new #self.inner 
    $self
}
fn TopItems-push(self: .TopItems, item: .TopItem) {
    &self.inner $item !i32 IV:I32Vec-push
}
fn TopItems-free(self: .TopItems) {
    local i: i32
    loop {
        $i &self.inner IV:I32Vec-len = if { break }
        &self.inner $i IV:I32Vec-get !.TopItem TopItem-free
        $i 1 + #i
    }
    $self.inner IV:I32Vec-free
    $self !.i32 A:free
}
fn TopItems-len(self: .TopItems) -> i32 {
    &self.inner IV:I32Vec-len
}
fn TopItems-get(self: .TopItems, index: i32) -> .TopItem {
    &self.inner $index IV:I32Vec-get !.TopItem
}

struct Imports {
    map: M:StringMap
}
fn Imports-new() -> .Imports {
    local self: .Imports
    sizeof(Imports) A:alloc !.Imports #self
    M:StringMap-new #self.map
    $self
}
fn Imports-free(self: .Imports) {
    local i: i32
    loop {
        $i &self.map M:StringMap-len = if { break }
        &self.map $i M:StringMap-get-value !.S:String ~ S:String-free // deallocate string itself
        &self.map $i M:StringMap-get-value !.i32 A:free // deallocate string struct
        $i 1 + #i
    }
    $self.map M:StringMap-free
    $self !.i32 A:free
}
fn Imports-insert(self: .Imports, ident: S:String, path: S:String) {
    local alloced-path: .S:String
    sizeof(S:String) A:alloc !.S:String #alloced-path
    $path >>alloced-path
    &self.map $ident $alloced-path !i32 M:StringMap-insert if {
        1 "WARNING: Multiple Imports with same ident\n" IO:write-all IO:check
        !.S:String ~ S:String-free
    } else {
        drop
    }
}
fn Imports-get-value(self: .Imports, index: i32) -> .S:String {
    &self.map $index M:StringMap-get-value !.S:String
}
fn Imports-get(self: .Imports, ident-ptr: .i32, ident-len: i32) -> .S:String, bool {
    local v: i32
    &self.map $ident-ptr $ident-len M:StringMap-get if {
        #v $v !.S:String 0 0 =
    } else {
        drop 0 !.S:String 0 1 =
    }
}
fn Imports-len(self: .Imports) -> i32 {
    &self.map M:StringMap-len
}

