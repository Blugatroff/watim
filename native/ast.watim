import "../std/alloc.watim" as A
import "../std/string.watim" as S
import "../std/string2.watim" as S2
import "../std/i32vec.watim" as IV
import "../std/io.watim" as IO
import "../std/core.watim" as CORE
import "../std/util.watim" as U
import "../std/map.watim" as M
import "../std/format.watim" as FMT

import "./lexer.watim" as L

fn INTRINSIC_ADD() -> i32 { 1 }
fn INTRINSIC_STORE32() -> i32 { 2 }
fn INTRINSIC_STORE8() -> i32 { 3 }
fn INTRINSIC_LOAD32() -> i32 { 4 }
fn INTRINSIC_LOAD8() -> i32 { 5 }
fn INTRINSIC_DROP() -> i32 { 6 }
fn INTRINSIC_SUB() -> i32 { 7 }
fn INTRINSIC_EQ() -> i32 { 8 }
fn INTRINSIC_NOT_EQ() -> i32 { 9 }
fn INTRINSIC_MOD() -> i32 { 10 }
fn INTRINSIC_DIV() -> i32 { 11 }
fn INTRINSIC_AND() -> i32 { 12 }
fn INTRINSIC_NOT() -> i32 { 13 }
fn INTRINSIC_OR() -> i32 { 14 }
fn INTRINSIC_LESS() -> i32 { 15 }
fn INTRINSIC_GREATER() -> i32 { 16 }
fn INTRINSIC_LESS_EQ() -> i32 { 17 }
fn INTRINSIC_GREATER_EQ() -> i32 { 18 }
fn INTRINSIC_MUL() -> i32 { 19 }
fn INTRINSIC_ROTR() -> i32 { 20 }
fn INTRINSIC_ROTL() -> i32 { 21 }
fn INTRINSIC_MEM_GROW() -> i32 { 22 }
fn INTRINSIC_MEM_COPY() -> i32 { 23 }
fn INTRINSIC_FLIP() -> i32 { 24 }

fn intrinsic-name(intrinsic: i32) -> .i32, i32 {
    loop {
        $intrinsic INTRINSIC_ADD = if { "INTRINSIC_ADD" break }
        $intrinsic INTRINSIC_STORE32 = if { "INTRINSIC_STORE32" break }
        $intrinsic INTRINSIC_STORE8 = if { "INTRINSIC_STORE8" break }
        $intrinsic INTRINSIC_LOAD32 = if { "INTRINSIC_LOAD32" break }
        $intrinsic INTRINSIC_LOAD8 = if { "INTRINSIC_LOAD8" break }
        $intrinsic INTRINSIC_DROP = if { "INTRINSIC_DROP" break }
        $intrinsic INTRINSIC_SUB = if { "INTRINSIC_SUB" break }
        $intrinsic INTRINSIC_EQ = if { "INTRINSIC_EQ" break }
        $intrinsic INTRINSIC_NOT_EQ = if { "INTRINSIC_NOT_EQ" break }
        $intrinsic INTRINSIC_MOD = if { "INTRINSIC_MOD" break }
        $intrinsic INTRINSIC_DIV = if { "INTRINSIC_DIV" break }
        $intrinsic INTRINSIC_AND = if { "INTRINSIC_AND" break }
        $intrinsic INTRINSIC_NOT = if { "INTRINSIC_NOT" break }
        $intrinsic INTRINSIC_OR = if { "INTRINSIC_OR" break }
        $intrinsic INTRINSIC_LESS = if { "INTRINSIC_LESS" break }
        $intrinsic INTRINSIC_GREATER = if { "INTRINSIC_GREATER" break }
        $intrinsic INTRINSIC_LESS_EQ = if { "INTRINSIC_LESS_EQ" break }
        $intrinsic INTRINSIC_GREATER_EQ = if { "INTRINSIC_GREATER_EQ" break }
        $intrinsic INTRINSIC_MUL = if { "INTRINSIC_MUL" break }
        $intrinsic INTRINSIC_ROTR = if { "INTRINSIC_ROTR" break }
        $intrinsic INTRINSIC_ROTL = if { "INTRINSIC_ROTL" break }
        $intrinsic INTRINSIC_MEM_GROW = if { "INTRINSIC_MEM_GROW" break }
        $intrinsic INTRINSIC_MEM_COPY = if { "INTRINSIC_MEM_COPY" break }
        $intrinsic INTRINSIC_FLIP = if { "INTRINSIC_FLIP" break }

        2 "INVALID INTRINSIC " IO:write-all IO:check
        $intrinsic IO:print
        1 CORE:exit
    }
}

fn WORD_CALL() -> i32 { 1 }
fn WORD_LOCAL() -> i32 { 2 }
fn WORD_SET() -> i32 { 4 }
fn WORD_NUMBER() -> i32 { 5 }
fn WORD_INTRINSIC() -> i32 { 6 }
fn WORD_IF() -> i32 { 7 }
fn WORD_LOOP() -> i32 { 8 }
fn WORD_BREAK() -> i32 { 9 }
fn WORD_STRING() -> i32 { 10 }
fn WORD_FIELD() -> i32 { 11 }
fn WORD_CAST() -> i32 { 12 }
fn WORD_DEREF() -> i32 { 13 }
fn WORD_GLOBAL() -> i32 { 14 }
fn WORD_STRUCT_SET() -> i32 { 15 }
fn WORD_GET_REF() -> i32 { 16 }
fn WORD_LOCAL2() -> i32 { 17 }
fn WORD_LOAD() -> i32 { 18 }
fn WORD_SIZEOF() -> i32 { 19 }
fn WORD_STORE() -> i32 { 20 }

fn word-ty-name(ty: i32) -> .i32, i32 {
    loop {
        $ty WORD_CALL = if { "WORD_CALL" break }
        $ty WORD_LOCAL = if { "WORD_LOCAL" break }
        $ty WORD_SET = if { "WORD_SET" break }
        $ty WORD_NUMBER = if { "WORD_NUMBER" break }
        $ty WORD_INTRINSIC = if { "WORD_INTRINSIC" break }
        $ty WORD_IF = if { "WORD_IF" break }
        $ty WORD_LOOP = if { "WORD_LOOP" break }
        $ty WORD_BREAK = if { "WORD_BREAK" break }
        $ty WORD_STRING = if { "WORD_STRING" break }
        $ty WORD_FIELD = if { "WORD_FIELD" break }
        $ty WORD_CAST = if { "WORD_CAST" break }
        $ty WORD_DEREF = if { "WORD_DEREF" break }
        $ty WORD_GLOBAL = if { "WORD_GLOBAL" break }
        $ty WORD_STRUCT_SET = if { "WORD_STRUCT_SET" break }
        $ty WORD_GET_REF = if { "WORD_GET_REF" break }
        $ty WORD_LOCAL2 = if { "WORD_LOCAL2" break }
        $ty WORD_LOAD = if { "WORD_LOAD" break }
        $ty WORD_SIZEOF = if { "WORD_SIZEOF" break }
        $ty WORD_STORE = if { "WORD_STORE" break }
        "INVALID WORD TY" break
    }
}

struct Words {
    ptr: ..Word
    len: i32
    cap: i32
}
fn Words-new() -> .Words {
    local self: .Words
    sizeof(Words) A:alloc !.Words @self
    0 !..Word @self.ptr
    0 @self.len
    0 @self.cap
    ?self
}
fn Words-len(self: .Words) -> i32 {
    ?self.len
}
fn Words-get(self: .Words, index: i32) -> .Word {
    ?index ?self.len >= if {
        2 "Words: Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    ?self.ptr ?index 4 * + load32
}
fn Words-push(self: .Words, word: .Word) {
    local new-buf: ..Word
    local size: i32
    local dst-ptr: ..Word
    ?self.len 1 + ?self.cap <= if {
        ?self.ptr ?self.len 4 * + @dst-ptr
        ?self.len 1 + @self.len
        ?word >>dst-ptr
    } else {
        ?self.cap 2 CORE:max 2 * @size
        ?size 4 * A:alloc !..Word @new-buf
        ?self.ptr !.i32
        ?new-buf !.i32
        ?self.len 4 *
        CORE:copy
        ?size @self.cap
        ?self.len 0 > if {
            ?self.ptr !.i32 A:free
        }
        ?new-buf @self.ptr
        ?self ?word Words-push
    }
}
fn Words-pop(self: .Words) -> .Word {
    ?self.len 0 = if {
        2 "Cannot pop from empty Words" IO:write-all IO:check
        1 CORE:exit
    }
    ?self ?self.len 1 - Words-get
    ?self.len 1 - @self.len
}
fn Words-free(self: .Words) {
    loop {
        ?self.len 0 = if { break }
        ?self Words-pop Word-free
    }
    ?self.cap 0 > if { ?self.ptr !.i32 A:free }
    ?self !.i32 A:free
}

fn TYPE_I32() -> i32 { 1 }
fn TYPE_I64() -> i32 { 2 }
fn TYPE_BOOL() -> i32 { 3 }
fn TYPE_PTR() -> i32 { 4 }
fn TYPE_STRUCT() -> i32 { 5 }

fn type-ty-name(ty: i32) -> .i32, i32 {
    loop {
        $ty TYPE_I32 = if { "TYPE_I32" break }
        $ty TYPE_I64 = if { "TYPE_I64" break }
        $ty TYPE_BOOL = if { "TYPE_BOOL" break }
        $ty TYPE_PTR = if { "TYPE_PTR" break }
        $ty TYPE_STRUCT = if { "TYPE_STRUCT" break }
        "invalid TYPE TY" break
    }
}

struct Type {
    ty: i32
    // for TYPE_PTR
    child: .i32 // actually of type .Type but recursive type not yet possible
    // for TYPE_STRUCT
    ident: .L:Token
    module: .L:Token
    struc: .i32 // actually of type .Struct but indirect recursive type not yet possible
}
fn Type-size(self: .Type) -> i32 {
    $self.ty load32 TYPE_STRUCT = if { 
        $self Type-struc Struct-size
    } else {
        4
    }
}
fn Type-eq(a: .Type, b: .Type) -> bool {
    loop {
        $a.ty load32 $b.ty load32 /= if { 0 1 = break }
        $a.ty load32 TYPE_PTR = if {
            $a Type-child $b Type-child Type-eq break
        }
        $a.ty load32 TYPE_STRUCT = if {
            $a.struc load32 $b.struc load32 = break
        }
        0 0 = break
    }
}
fn Type-new(ty: i32) -> .Type {
    local self: .Type
    20 A:alloc !.Type #self
    $self.ty $ty store32
    $self.child 0 !.i32 store32
    $self
}
fn Type-clone(self: .Type) -> .Type {
    local new: .Type
    20 A:alloc !.Type #new
    $self !.i32 $new !.i32 20 CORE:copy
    $new
}
fn Type-new-int32() -> .Type {
    TYPE_I32 Type-new
}
fn Type-new-int64() -> .Type {
    TYPE_I64 Type-new
}
fn Type-new-boolean() -> .Type {
    TYPE_BOOL Type-new
}
fn Type-new-ptr(child: .Type) -> .Type {
    local self: .Type
    TYPE_PTR Type-new #self
    $self.child $child !.i32 store32
    $self
}
fn Type-new-struc(module: .L:Token, ident: .L:Token) -> .Type {
    local self: .Type
    TYPE_STRUCT Type-new #self
    $self.module $module store32
    $self.ident $ident store32
    $self.struc 0 !.i32 store32
    $self
}
fn Type-set-struc(self: .Type, struc: .Struct) {
    $self.struc $struc !.i32 store32
}
fn Type-module(self: .Type) -> .L:Token {
    $self.module load32
}
fn Type-ident(self: .Type) -> .L:Token {
    $self.ident load32
}
fn Type-struc(self: .Type) -> .Struct {
    $self.struc load32 !.Struct
}
fn Type-free(self: .Type) {
    $self !.i32 A:free
}
fn Type-ty(self: .Type) -> i32 {
    $self.ty load32
}
fn Type-child(self: .Type) -> .Type {
    $self.child load32 !.Type
}
fn Type-format(self: .Type, formatter: .FMT:Formatter) {
    loop {
        $self Type-ty TYPE_I32 = if { $formatter "i32" FMT:Formatter-write break }
        $self Type-ty TYPE_I64 = if { $formatter "i64" FMT:Formatter-write break }
        $self Type-ty TYPE_BOOL = if { $formatter "bool" FMT:Formatter-write break }
        $self Type-ty TYPE_PTR = if { 
            $formatter "." FMT:Formatter-write
            $self Type-child $formatter Type-format
            break
        }
        $self Type-ty TYPE_STRUCT = if {
            $self.module load32 !i32 0 /= if {
                $formatter $self.module load32 L:Token-lexeme S:Str-unpack FMT:Formatter-write
                $formatter ":" FMT:Formatter-write
            }
            $formatter $self Type-struc Struct-ident L:Token-lexeme S:Str-unpack FMT:Formatter-write
            break
        }
        2 "invalid Type-ty" IO:write-all IO:check
        1 CORE:exit
    }
}

struct Types {
    inner: .IV:I32Vec
    min-size: i32
}
fn Types-new() -> .Types {
    local self: .Types
    8 A:alloc !.Types #self
    $self.inner IV:I32Vec-new store32
    $self
}
fn Types-free(self: .Types) {
    local i: i32
    loop {
        $i $self.inner load32 IV:I32Vec-len = if { break }
        $self.inner load32 $i IV:I32Vec-get !.Type Type-free
        $i 1 + #i
    }
    $self Types-free-container
}
fn Types-reset-min(self: .Types) {
    $self.min-size $self Types-len store32
}
fn Types-min(self: .Types) -> i32 {
    $self.min-size load32
}
fn Types-clone-container(self: .Types) -> .Types {
    local new: .Types
    8 A:alloc !.Types #new
    $new.inner $self.inner load32 IV:I32Vec-clone store32
    $new.min-size $self Types-min store32
    $new
}
fn Types-free-container(self: .Types) {
    $self.inner load32 IV:I32Vec-free
    $self !.i32 A:free
}
fn Types-push(self: .Types, f: .Type) {
    ?self.inner ?f !i32 IV:I32Vec-push
}
fn Types-pop(self: .Types) -> .Type {
    $self.inner load32 IV:I32Vec-pop !.Type
    $self.min-size $self Types-min $self Types-len CORE:min store32
}
fn Types-clone-slice(self: .Types, start: i32, end: i32) -> .Types {
    local new: .Types
    Types-new #new
    loop {
        $start $end = if { break }
        $new $self $start Types-get Type-clone Types-push
        $start 1 + #start
    }
    $new
}
fn Types-len(self: .Types) -> i32 {
    ?self.inner IV:I32Vec-len
}
fn Types-get(self: .Types, index: i32) -> .Type {
    ?self.inner ?index IV:I32Vec-get !.Type
}
fn Types-format(self: .Types, formatter: .FMT:Formatter) {
    local i: i32
    0 ?self Types-len = if {
        ?formatter "[]" FMT:Formatter-write
    } else {
        ?formatter "[" FMT:Formatter-write
        loop {
            ?i ?self Types-len = if { break }
            ?self ?i Types-get ?formatter Type-format
            ?i 1 + ?self Types-len < if {
                ?formatter ", " FMT:Formatter-write
            }
            ?i 1 + @i
        }
        ?formatter "]" FMT:Formatter-write
    }
}
fn Types-print(self: .Types, fd: i32) {
    local formatter: FMT:Formatter
    local out: S2:String
    FMT:Formatter-new @formatter
    ?self &formatter Types-format
    ?formatter FMT:Formatter-into-string @out
    ?fd &out S2:String-unpack IO:write-all IO:check
    ?out S2:String-free
}
fn Types-last(self: .Types) -> .Type {
    ?self ?self Types-len 1 - Types-get
}

struct If {
    token: .L:Token
    body: .Words
    el: .Words
    params: .Types
    rets: .Types
}
fn If-new(token: .L:Token, body: .Words, el: .Words) -> .If {
    local self: .If
    20 A:alloc !.If #self
    $self.token $token store32
    $self.body $body store32
    $self.el $el store32
    $self.params 0 !.Types store32
    $self.rets 0 !.Types store32
    $self
}
fn If-free(self: .If) {
    $self.body load32 Words-free
    $self.el load32 !i32 0 /= if {
        $self.el load32 Words-free
    }
    $self.params load32 !i32 0 /= if {
        $self.params load32 Types-free
    }
    $self.rets load32 !i32 0 /= if {
        $self.rets load32 Types-free
    }
    $self !.i32 A:free
}
fn If-token(self: .If) -> .L:Token {
    $self.token load32
}
fn If-body(self: .If) -> .Words {
    $self.body load32
}
fn If-el(self: .If) -> .Words {
    $self.el load32
}
fn If-params(self: .If) -> .Types {
    $self.params load32
}
fn If-set-params(self: .If, params: .Types) {
    $self.params $params store32
}
fn If-rets(self: .If) -> .Types {
    $self.rets load32
}
fn If-set-rets(self: .If, params: .Types) {
    $self.rets $params store32
}

struct Word {
    file: S:Str
    ty: i32
    line: i32
    column: i32
    ident: .S:Str
    offset: i32
    qualifier: .S:Str
    number: i32
    intrinsic: i32
    addr: i32
    size: i32
    offset: i32
    module: i32
    fields: L:Tokens
    loads: .IV:I32Vec
    lop: .Words
    rets: .Types
    iff: .If
    type: .Type
    src-type: .Type
}
fn Word-new(ty: i32, file: S:Str, line: i32, column: i32) -> .Word {
    local self: .Word
    sizeof(Word) A:alloc !.Word #self
    ?file @self.file
    ?ty @self.ty
    ?line @self.line
    ?column @self.column
    0 !.S:Str @self.qualifier
    ?self
}
fn Word-free(self: .Word) {
    ?self.ty WORD_IF = if {
        ?self.iff If-free
    }
    ?self.ty WORD_LOOP = if {
        ?self.lop Words-free
    }
    ?self.ty WORD_STRUCT_SET = 
    ?self.ty WORD_GET_REF = or
    ?self.ty WORD_LOCAL2 = or
    ?self.ty WORD_STORE = or
    ?self.ty WORD_GLOBAL = or
    if {
        ?self.fields L:Tokens-free-container
    }
    ?self.ty WORD_STRUCT_SET = 
    ?self.ty WORD_GET_REF = or
    ?self.ty WORD_LOCAL2 = or
    ?self.ty WORD_STORE = or
    if {
        ?self.loads IV:I32Vec-free
    }
    ?self.ty WORD_LOOP = 
    ?self.ty WORD_CALL = or 
    if {
        ?self.rets Types-free-container
    }
    ?self !.i32 A:free
}
fn Word-location(self: .Word) -> .i32, i32, i32, i32 {
    &self.file S:Str-unpack ?self.line ?self.column
}
fn Word-ty(self: .Word) -> i32 {
    ?self.ty
}
fn Word-type(self: .Word) -> .Type {
    ?self.type
}
fn Word-iff(self: .Word) -> .If {
    ?self.iff
}
fn Word-lop(self: .Word) -> .Words {
    ?self.lop
}
fn Word-ident(self: .Word) -> .S:Str {
    ?self.ident
}
fn Word-words(self: .Word) -> .Words {
    ?self.lop
}
fn Word-rets(self: .Word) -> .Types {
    ?self.rets
}
fn Word-intrinsic(self: .Word) -> i32 {
    ?self.intrinsic
}
fn Word-module(self: .Word) -> i32 {
    ?self.module
}

struct Local {
    ident: .L:Token
    type: .Type
}
fn Local-new(ident: .L:Token, type: .Type) -> .Local {
    local self: .Local
    8 A:alloc !.Local #self
    $self.ident $ident store32
    $self.type $type store32
    $self
}
fn Local-ident(self: .Local) -> .L:Token {
    $self.ident load32
}
fn Local-type(self: .Local) -> .Type {
    ?self.type
}
fn Local-set-type(self: .Local, type: .Type) {
    $self.type $type store32
}
fn Local-format(self: .Local, formatter: .FMT:Formatter) {
    $formatter "{ ident: \"" FMT:Formatter-write
    $formatter $self.ident load32 L:Token-lexeme S:Str-unpack FMT:Formatter-write
    $formatter "\", type: " FMT:Formatter-write
    $self.type load32 $formatter Type-format
    $formatter " }" FMT:Formatter-write
}
fn Local-free(self: .Local) {
    $self !.i32 A:free
}

struct Locals {
    inner: .IV:I32Vec
}
fn Locals-new() -> .Locals {
    local self: .Locals
    4 A:alloc !.Locals #self
    $self.inner IV:I32Vec-new store32
    $self
}
fn Locals-free(self: .Locals) {
    local i: i32
    loop {
        $i $self.inner load32 IV:I32Vec-len = if { break }
        $self.inner load32 $i IV:I32Vec-get !.Local Local-free
        $i 1 + #i
    }
    $self.inner load32 IV:I32Vec-free
    $self !.i32 A:free
}
fn Locals-get(self: .Locals, index: i32) -> .Local {
    $self.inner load32 $index IV:I32Vec-get !.Local
}
fn Locals-push(self: .Locals, mem: .Local) {
    $self.inner load32 $mem !i32 IV:I32Vec-push
}
fn Locals-len(self: .Locals) -> i32 {
    $self.inner load32 IV:I32Vec-len
}
fn Locals-format(self: .Locals, formatter: .FMT:Formatter) {
    local i: i32
    $self Locals-len 0 = if { 
        $formatter "[]" FMT:Formatter-write
    } else {
        $formatter "[\n" FMT:Formatter-write
        $formatter FMT:Formatter-indent
        loop {
            $i $self Locals-len = if { break }
            $formatter FMT:Formatter-write-indent
            $self $i Locals-get $formatter Local-format
            $formatter ",\n" FMT:Formatter-write
            $i 1 + #i
        }
        $formatter FMT:Formatter-dedent
        $formatter FMT:Formatter-write-indent
        $formatter "]" FMT:Formatter-write
    }
}
fn Locals-contains-struc(self: .Locals) -> bool {
    local i: i32
    loop {
        $i $self Locals-len = if { 0 1 = break }
        $self $i Locals-get Local-type Type-ty TYPE_STRUCT = if {
            0 0 = break 
        }
        $i 1 + #i
    }
}

struct Memory {
    locl: .Local
    size: i32
    alignment: i32
    address: i32
}
fn Memory-new(ident: .L:Token, type: .Type, size: i32, alignment: i32) -> .Memory {
    local self: .Memory
    16 A:alloc !.Memory #self
    $self.locl $ident $type Local-new store32
    $self.size $size store32
    $self.alignment $alignment store32
    $self.address 0 store32
    $self
}
fn Memory-free(self: .Memory) {
    $self.locl load32 Local-free
    $self !.i32 A:free
}
fn Memory-ident(self: .Memory) -> .L:Token {
    $self.locl load32 Local-ident
}
fn Memory-type(self: .Memory) -> .Type {
    ?self.locl Local-type
}
fn Memory-set-type(self: .Memory, type: .Type) {
    $self.locl load32 $type Local-set-type
}
fn Memory-local(self: .Memory) -> .Local {
    $self.locl load32
}
fn Memory-address(self: .Memory) -> i32 {
    $self.address load32
}
fn Memory-set-address(self: .Memory, address: i32) {
    $self.address $address store32
}
fn Memory-size(self: .Memory) -> i32 {
    $self.size load32
}
fn Memory-alignment(self: .Memory) -> i32 {
    $self.alignment load32
}
fn Memory-format(self: .Memory, formatter: .FMT:Formatter) {
    $formatter "{ ident: " FMT:Formatter-write
    $formatter $self Memory-ident L:Token-lexeme S:Str-unpack FMT:Formatter-write
    $formatter ", type: " FMT:Formatter-write
    $self Memory-type $formatter Type-format
    $formatter ", size: " FMT:Formatter-write
    $self.size load32 $formatter U:i32-format
    $formatter ", alignment: " FMT:Formatter-write
    $self.alignment load32 $formatter U:i32-format
    $formatter " }" FMT:Formatter-write
}

struct Memories {
    inner: .IV:I32Vec
}
fn Memories-new() -> .Memories {
    local self: .Memories
    4 A:alloc !.Memories #self
    $self.inner IV:I32Vec-new store32
    $self
}
fn Memories-free(self: .Memories) {
    local i: i32
    loop {
        $i $self.inner load32 IV:I32Vec-len = if { break }
        $self.inner load32 $i IV:I32Vec-get !.Memory Memory-free
        $i 1 + #i
    }
    $self.inner load32 IV:I32Vec-free
    $self !.i32 A:free
}
fn Memories-get(self: .Memories, index: i32) -> .Memory {
    $self.inner load32 $index IV:I32Vec-get !.Memory
}
fn Memories-push(self: .Memories, mem: .Memory) {
    $self.inner load32 $mem !i32 IV:I32Vec-push
}
fn Memories-len(self: .Memories) -> i32 {
    $self.inner load32 IV:I32Vec-len
}

struct Function {
    ident: .L:Token
    qualifier: .L:Token
    parameters: .Locals
    ret: .Types
    mems: .Memories
    locals: .Locals
    body: .Words
    diverges: bool
}
fn Function-new(
    ident: .L:Token, 
    qualifier: .L:Token, 
    parameters: .Locals,
    ret: .Types,
    mems: .Memories,
    locals: .Locals,
    body: .Words
) -> .Function {
    local self: .Function
    32 A:alloc !.Function #self
    $self.ident $ident store32
    $self.qualifier $qualifier store32
    $self.parameters $parameters store32
    $self.ret $ret store32
    $self.mems $mems store32
    $self.locals $locals store32
    $self.body $body store32
    $self.diverges 0 1 = store32
    $self
}
fn Function-free(self: .Function) {
    $self.parameters load32 Locals-free
    $self.ret load32 Types-free-container
    $self.body load32 Words-free
    $self.mems load32 Memories-free
    $self.locals load32 Locals-free
    $self !.i32 A:free
}
fn Function-rets(self: .Function) -> .Types {
    $self.ret load32
}
fn Function-parameters(self: .Function) -> .Locals {
    $self.parameters load32
}
fn Function-locals(self: .Function) -> .Locals {
    $self.locals load32
}
fn Function-memories(self: .Function) -> .Memories {
    $self.mems load32
}
fn Function-body(self: .Function) -> .Words {
    $self.body load32
}
fn Function-ident(self: .Function) -> .L:Token {
    $self.ident load32
}
fn Function-diverges(self: .Function) -> bool {
    $self.diverges load32
}
fn Function-has-struc-locl(self: .Function) -> bool {
    local locals: .Locals
    local i: i32
    $self Function-locals Locals-contains-struc if { 
        0 0 = 
    } else {
        $self Function-parameters Locals-contains-struc
    }
}

struct Functions {
    inner: .IV:I32Vec
}
fn Functions-new() -> .Functions {
    local self: .Functions
    4 A:alloc !.Functions #self 
    $self.inner IV:I32Vec-new store32
    $self
}
fn Functions-free(self: .Functions) {
    local i: i32
    loop {
        $i $self.inner load32 IV:I32Vec-len = if { break }
        $self.inner load32 $i IV:I32Vec-get !.Function Function-free
        $i 1 + #i
    }
    $self.inner load32 IV:I32Vec-free
    $self !.i32 A:free
}
fn Functions-push(self: .Functions, f: .Function) {
    $self.inner load32 $f !i32 IV:I32Vec-push
}
fn Functions-len(self: .Functions) -> i32 {
    $self.inner load32 IV:I32Vec-len
}
fn Functions-get(self: .Functions, index: i32) -> .Function {
    $self.inner load32 $index IV:I32Vec-get !.Function
}

struct Extern {
    module: .L:Token
    name: .L:Token
    ident: .L:Token
    params: .Locals
    rets: .Types
}
fn Extern-new(
    module: .L:Token,
    name: .L:Token,
    ident: .L:Token,
    params: .Locals,
    rets: .Types
) -> .Extern {
    local self: .Extern
    20 A:alloc !.Extern #self
    $self.module $module store32
    $self.name $name store32
    $self.ident $ident store32
    $self.params $params store32
    $self.rets $rets store32
    $self
}
fn Extern-module(self: .Extern) -> .L:Token {
    $self.module load32
}
fn Extern-name(self: .Extern) -> .L:Token {
    $self.name load32
}
fn Extern-rets(self: .Extern) -> .Types {
    $self.rets load32
}
fn Extern-parameters(self: .Extern) -> .Locals {
    $self.params load32
}
fn Extern-ident(self: .Extern) -> .L:Token {
    $self.ident load32
}
fn Extern-free(self: .Extern) {
    $self.params load32 Locals-free
    $self.rets load32 Types-free-container
    $self !.i32 A:free
}
fn Extern-format(self: .Extern, formatter: .FMT:Formatter) {
    $formatter "{\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent
    $formatter FMT:Formatter-write-indent
    $formatter "module: \"" FMT:Formatter-write 
    $formatter $self.module load32 L:Token-lexeme S:Str-unpack FMT:Formatter-write
    $formatter "\",\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "name: \"" FMT:Formatter-write
    $formatter $self.name load32 L:Token-lexeme S:Str-unpack FMT:Formatter-write
    $formatter "\",\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "ident: \"" FMT:Formatter-write
    $formatter $self.ident load32 L:Token-lexeme S:Str-unpack FMT:Formatter-write
    $formatter "\",\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "params: " FMT:Formatter-write
    $self.params load32 $formatter Locals-format
    $formatter ",\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "rets: " FMT:Formatter-write
    $self.rets load32 $formatter Types-format
    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter "}" FMT:Formatter-write
}

struct Import {
    path: .L:Token
    ident: .L:Token
}
fn Import-new(path: .L:Token, ident: .L:Token) -> .Import {
    local self: .Import
    8 A:alloc !.Import #self
    $self.path $path store32
    $self.ident $ident store32
    $self
}
fn Import-free(self: .Import) {
    $self !.i32 A:free
}
fn Import-path(self: .Import) -> .L:Token {
    $self.path load32
}
fn Import-ident(self: .Import) -> .L:Token {
    $self.ident load32
}
fn Import-format(self: .Import, formatter: .FMT:Formatter) {
    $formatter "{ path: " FMT:Formatter-write
    $formatter $self Import-path L:Token-lexeme S:Str-unpack FMT:Formatter-write
    $formatter ", ident: \"" FMT:Formatter-write
    $formatter $self Import-ident L:Token-lexeme S:Str-unpack FMT:Formatter-write
    $formatter "\" }" FMT:Formatter-write
}
fn Import-path-content(self: .Import) -> .i32, i32 {
    local ptr: .i32
    local len: i32
    $self Import-path L:Token-lexeme S:Str-unpack #len #ptr
    $ptr 1 + $len 2 -
}

struct Field {
    ident: .L:Token
    type: .Type
}
fn Field-new(ident: .L:Token, type: .Type) -> .Field {
    local self: .Field
    8 A:alloc !.Field #self
    $self.ident $ident store32
    $self.type $type store32
    $self
}
fn Field-free(self: .Field) {
    $self !.i32 A:free
}
fn Field-ident(self: .Field) -> .L:Token {
    $self.ident load32
}
fn Field-type(self: .Field) -> .Type {
    $self.type load32
}
fn Field-format(self: .Field, formatter: .FMT:Formatter) {
    $formatter "{ ident: \"" FMT:Formatter-write
    $formatter $self Field-ident L:Token-lexeme S:Str-unpack FMT:Formatter-write
    $formatter "\", type: " FMT:Formatter-write
    $self Field-type $formatter Type-format
    $formatter " }" FMT:Formatter-write
}

struct Fields {
    inner: .IV:I32Vec
}
fn Fields-new() -> .Fields {
    local self: .Fields
    4 A:alloc !.Fields #self
    $self.inner IV:I32Vec-new store32
    $self
}
fn Fields-push(self: .Fields, item: .Field) {
    $self.inner load32 $item !i32 IV:I32Vec-push
}
fn Fields-free(self: .Fields) {
    local i: i32
    loop {
        $i $self.inner load32 IV:I32Vec-len = if { break }
        $self.inner load32 $i IV:I32Vec-get !.Field Field-free
        $i 1 + #i
    }
    $self.inner load32 IV:I32Vec-free
    $self !.i32 A:free
}
fn Fields-len(self: .Fields) -> i32 {
    $self.inner load32 IV:I32Vec-len
}
fn Fields-get(self: .Fields, index: i32) -> .Field {
    $self.inner load32 $index IV:I32Vec-get !.Field
}
fn Fields-format(self: .Fields, formatter: .FMT:Formatter) {
    local i: i32
    0 $self Fields-len = if {
        $formatter "[]" FMT:Formatter-write
    } else {
        $formatter "[\n" FMT:Formatter-write
        $formatter FMT:Formatter-indent
        loop {
            $i $self Fields-len = if { break }
            $formatter FMT:Formatter-write-indent
            $self $i Fields-get $formatter Field-format
            $formatter ",\n" FMT:Formatter-write
            $i 1 + #i 
        }
        $formatter FMT:Formatter-dedent
        $formatter FMT:Formatter-write-indent
        $formatter "]" FMT:Formatter-write
    }
}

struct Struct {
    ident: .L:Token
    fields: .Fields
}
fn Struct-new(ident: .L:Token, fields: .Fields) -> .Struct {
    local self: .Struct
    8 A:alloc !.Struct #self
    $self.ident $ident store32
    $self.fields $fields store32
    $self
}
fn Struct-free(self: .Struct) {
    $self.fields load32 Fields-free
    $self !.i32 A:free
}
fn Struct-format(self: .Struct, formatter: .FMT:Formatter) {
    $formatter "{\n" FMT:Formatter-write
    $formatter FMT:Formatter-indent
    $formatter FMT:Formatter-write-indent
    $formatter "ident: \"" FMT:Formatter-write
    $formatter $self.ident load32 L:Token-lexeme S:Str-unpack FMT:Formatter-write
    $formatter "\"\n" FMT:Formatter-write
    $formatter FMT:Formatter-write-indent
    $formatter "fields: " FMT:Formatter-write
    $self.fields load32 $formatter Fields-format
    $formatter "\n" FMT:Formatter-write
    $formatter FMT:Formatter-dedent
    $formatter FMT:Formatter-write-indent
    $formatter "}" FMT:Formatter-write
}
fn Struct-ident(self: .Struct) -> .L:Token {
    $self.ident load32
}
fn Struct-fields(self: .Struct) -> .Fields {
    $self.fields load32
}
fn Struct-find-field(self: .Struct, ident-ptr: .i32, ident-len: i32) -> .Field, i32, bool {
    local i: i32
    local fields: .Fields
    local offset: i32
    $self Struct-fields #fields
    loop {
        $i $fields Fields-len = if { 0 !.Field 0 0 1 = break }
        $fields $i Fields-get Field-ident L:Token-lexeme S:Str-unpack $ident-ptr $ident-len S:str-eq if {
            $fields $i Fields-get
            $offset 0 0 = break
        }
        $offset $fields $i Fields-get Field-type Type-size + #offset
        $i 1 + #i
    }
}
fn Struct-size(self: .Struct) -> i32 {
    local size: i32
    local i: i32
    loop {
        $i $self Struct-fields Fields-len = if { break }
        $size 
        $self Struct-fields $i Fields-get Field-type Type-size
        + #size
        $i 1 + #i
    }
    $size
}

fn TOP_ITEM_FN() -> i32 { 1 }
fn TOP_ITEM_MEM() -> i32 { 2 }
fn TOP_ITEM_IMPORT() -> i32 { 3 }
fn TOP_ITEM_STRUCT() -> i32 { 4 }
fn TOP_ITEM_EXT() -> i32 { 5 }

fn top-item-ty-name(ty: i32) -> .i32, i32 {
    loop {
        $ty TOP_ITEM_FN = if { "TOP_ITEM_FN" break }
        $ty TOP_ITEM_MEM = if { "TOP_ITEM_MEM" break }
        $ty TOP_ITEM_IMPORT = if { "TOP_ITEM_IMPORT" break }
        $ty TOP_ITEM_STRUCT = if { "TOP_ITEM_STRUCT" break }
        $ty TOP_ITEM_EXT = if { "TOP_ITEM_EXT" break }
        "UNVALID TOP_ITEM TY" break
    }
}

struct TopItem {
    ty: i32
    function: .Function
    mem: .Memory
    ext: .Extern
    imp: .Import
    struc: .Struct
}
fn TopItem-new(ty: i32) -> .TopItem {
    local self: .TopItem
    24 A:alloc !.TopItem #self
    $self.ty $ty store32
    $self
}
fn TopItem-new-function(f: .Function) -> .TopItem {
    local self: .TopItem
    TOP_ITEM_FN TopItem-new #self
    $self.function $f store32
    $self
}
fn TopItem-new-mem(mem: .Memory) -> .TopItem {
    local self: .TopItem
    TOP_ITEM_MEM TopItem-new #self
    $self.mem $mem store32
    $self
}
fn TopItem-new-ext(ext: .Extern) -> .TopItem {
    local self: .TopItem
    TOP_ITEM_EXT TopItem-new #self
    $self.ext $ext store32
    $self
}
fn TopItem-new-imp(imp: .Import) -> .TopItem {
    local self: .TopItem
    TOP_ITEM_IMPORT TopItem-new #self
    $self.imp $imp store32
    $self
}
fn TopItem-new-struc(struc: .Struct) -> .TopItem {
    local self: .TopItem
    TOP_ITEM_STRUCT TopItem-new #self
    $self.struc $struc store32
    $self
}
fn TopItem-ty(self: .TopItem) -> i32 {
    $self.ty load32
}
fn TopItem-struc(self: .TopItem) -> .Struct {
    $self.struc load32
}
fn TopItem-function(self: .TopItem) -> .Function {
    $self.function load32
}
fn TopItem-ext(self: .TopItem) -> .Extern {
    $self.ext load32
}
fn TopItem-mem(self: .TopItem) -> .Memory {
    $self.mem load32
}
fn TopItem-free(self: .TopItem) {
    $self TopItem-ty TOP_ITEM_FN = if {
        $self.function load32 Function-free
    }
    $self TopItem-ty TOP_ITEM_MEM = if {
        $self.mem load32 Memory-free
    }
    $self TopItem-ty TOP_ITEM_EXT = if {
        $self.ext load32 Extern-free
    }
    $self TopItem-ty TOP_ITEM_IMPORT = if {
        $self.imp load32 Import-free
    }
    $self TopItem-ty TOP_ITEM_STRUCT = if {
        $self.struc load32 Struct-free
    }
    $self !.i32 A:free
}

struct TopItems {
    inner: .IV:I32Vec
}
fn TopItems-new() -> .TopItems {
    local self: .TopItems
    4 A:alloc !.TopItems #self
    $self.inner IV:I32Vec-new store32
    $self
}
fn TopItems-push(self: .TopItems, item: .TopItem) {
    $self.inner load32 $item !i32 IV:I32Vec-push
}
fn TopItems-free(self: .TopItems) {
    local i: i32
    loop {
        $i $self.inner load32 IV:I32Vec-len = if { break }
        $self.inner load32 $i IV:I32Vec-get !.TopItem TopItem-free
        $i 1 + #i
    }
    $self.inner load32 IV:I32Vec-free
    $self !.i32 A:free
}
fn TopItems-len(self: .TopItems) -> i32 {
    $self.inner load32 IV:I32Vec-len
}
fn TopItems-get(self: .TopItems, index: i32) -> .TopItem {
    $self.inner load32 $index IV:I32Vec-get !.TopItem
}

struct Imports {
    map: M:StringMap
}
fn Imports-new() -> .Imports {
    local self: .Imports
    sizeof(Imports) A:alloc !.Imports @self
    M:StringMap-new @self.map
    ?self
}
fn Imports-free(self: .Imports) {
    local i: i32
    loop {
        ?i &self.map M:StringMap-len = if { break }
        &self.map ?i M:StringMap-get-value !.S:String S:String-free
        ?i 1 + @i
    }
    ?self.map M:StringMap-free
    ?self !.i32 A:free
}
fn Imports-insert(self: .Imports, ident: S2:String, path: S2:String) {
    local alloced-path: .S2:String
    // TODO: make this work -> sizeof(S2:String) A:alloc !.S2:String @alloced-path
    12 A:alloc !.S2:String @alloced-path
    ?path >>alloced-path
    &self.map ?ident ?alloced-path !i32 M:StringMap-insert if {
        1 "WARNING: Multiple Imports with same ident\n" IO:write-all IO:check
        !.S2:String ~ S2:String-free
    } else {
        drop
    }
}
fn Imports-get-key(self: .Imports, index: i32) -> .S2:String {
    &self.map ?index M:StringMap-get-key
}
fn Imports-get-value(self: .Imports, index: i32) -> .S2:String {
    &self.map ?index M:StringMap-get-value !.S2:String
}
fn Imports-get(self: .Imports, ident-ptr: .i32, ident-len: i32) -> .S2:String, bool {
    local v: i32
    &self.map ?ident-ptr ?ident-len M:StringMap-get if {
        @v ?v !.S2:String 0 0 =
    } else {
        drop 0 !.S2:String 0 1 =
    }
}
fn Imports-len(self: .Imports) -> i32 {
    &self.map M:StringMap-len
}

