import "./lexer.watim" as L
import "./ast.watim" as AST
import "../std/alloc.watim" as A
import "../std/io.watim" as IO
import "../std/core.watim" as CORE
import "../std/string.watim" as S
import "./util.watim" as U

struct Parser {
    tokens: .L:Tokens
    current: i32
    mem: .S:String
    types: .AST:Types
    file: .S:String
}
fn Parser-new(tokens: .L:Tokens, mem: .S:String) -> .Parser {
    local self: .Parser
    20 A:alloc !.Parser #self
    $self.tokens $tokens store32
    $self.current 0 store32
    $self.mem $mem store32
    $self.types AST:Types-new store32
    $tokens L:Tokens-len 0 > if {
        $self.file $tokens 0 L:Tokens-get L:Token-file store32
    } else {
        $self.file 0 !.S:String store32
    }
    $self
} 
fn Parser-free(self: .Parser) -> .AST:Types { 
    $self.types load32
    $self !.i32 A:free
}
fn Parser-peek(self: .Parser) -> .L:Token {
    $self.tokens load32 $self.current load32 L:Tokens-get
}
fn Parser-advance(self: .Parser) -> .L:Token {
    $self Parser-peek
    $self.current $self.current load32 1 + store32
}

fn Parser-parse-module(self: .Parser) -> .AST:TopItems {
    local token: .L:Token
    local items: .AST:TopItems
    AST:TopItems-new #items
    loop {
        $self.tokens load32 L:Tokens-len $self.current load32 = if {
            $items break
        }
        loop {
            $self Parser-peek #token
            $token L:Token-ty L:TOKEN_FN = if {
                $items $self Parser-parse-function AST:TopItem-new-function AST:TopItems-push
                break
            }
            $token L:Token-ty L:TOKEN_MEMORY = if {
                $items $self Parser-parse-mem AST:TopItem-new-mem AST:TopItems-push
                break
            }
            $token L:Token-ty L:TOKEN_EXTERN = if {
                $items $self Parser-parse-ext AST:TopItem-new-ext AST:TopItems-push
                break
            }
            $token L:Token-ty L:TOKEN_IMPORT = if {
                $items $self Parser-parse-imp AST:TopItem-new-imp AST:TopItems-push
                break
            }
            $token L:Token-ty L:TOKEN_STRUCT = if {
                $items $self Parser-parse-struc AST:TopItem-new-struc AST:TopItems-push
                break
            }
            1 $token L:Token-ty L:token-ty-name IO:write-all IO:check
            $token L:Token-location "expected function memory or import" U:abort-with-location
            break
        }
    }
}
fn Parser-parse-struc(self: .Parser) -> .AST:Struct {
    local token: .L:Token
    local fields: .AST:Fields
    local ident: .L:Token
    AST:Fields-new #fields
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected struct" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_STRUCT /= if {
        $token L:Token-location "expected struct" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected identifier" U:abort
    }
    $self Parser-advance #ident
    $ident L:Token-ty L:TOKEN_IDENT /= if {
        $token L:Token-location "expected identifier" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected {" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
        $token L:Token-location "expected {" U:abort-with-location
    }
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if {
            break
        }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_RIGHT_CURLY = if {
            break
        }
        $token L:Token-ty L:TOKEN_IDENT /= if {
            $token L:Token-location "expected identifier" U:abort-with-location
        }
        $fields
        $token
        $self.current load32 $self.tokens load32 L:Tokens-len = if {
            $self.file load32 "expected colon" U:abort
        }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_COLON /= if {
            $token L:Token-location "expected colon" U:abort-with-location
        }
        $self Parser-parse-type
        AST:Field-new AST:Fields-push
    }
    $ident $fields AST:Struct-new
}
fn Parser-parse-imp(self: .Parser) -> .AST:Import {
    local token: .L:Token

    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected import" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_IMPORT /= if {
        $token L:Token-location "expected import" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected string" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_STRING /= if {
        $token L:Token-location "exected string" U:abort-with-location
    }
    $token
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected as" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_AS /= if {
        $token L:Token-location "exected as" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected identifier" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_IDENT /= if {
        $token L:Token-location "exected identifier" U:abort-with-location
    }
    $token
    AST:Import-new
}
fn Parser-parse-ext(self: .Parser) -> .AST:Extern {
    local token: .L:Token
    local module: .L:Token
    local name: .L:Token
    local ident: .L:Token
    local params: .AST:Locals
    local rets: .AST:Types
    $self.tokens load32 L:Tokens-len $self.current load32 = if {
        $self.file load32 "expected extern" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_EXTERN /= if {
        $token L:Token-location "expected extern" U:abort-with-location
    }
    $self.tokens load32 L:Tokens-len $self.current load32 = if {
        $self.file load32 "expected string" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_STRING /= if {
        $token L:Token-location "expected string" U:abort-with-location
    }
    $token #module
    $self.tokens load32 L:Tokens-len $self.current load32 = if {
        $self.file load32 "expected string" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_STRING /= if {
        $token L:Token-location "expected string" U:abort-with-location
    }
    $token #name
    $module
    $name
    $self Parser-parse-signature #rets #params drop #ident
    $ident
    $params
    $rets
    AST:Extern-new
}
fn Parser-parse-loc(self: .Parser) -> .AST:Local {
    local token: .L:Token
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected local" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LOCAL /= if {
        $token L:Token-location "expected local" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected identifier" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_IDENT /= if {
        $token L:Token-location "expected identifier" U:abort-with-location
    }
    $token
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected colon" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_COLON /= if {
        $token L:Token-location "expected colon" U:abort-with-location
    }
    $self Parser-parse-type
    AST:Local-new
}
fn Parser-parse-mem(self: .Parser) -> .AST:Memory {
    local token: .L:Token
    local ident: .L:Token
    local type: .AST:Type
    $self.tokens load32 L:Tokens-len $self.current load32 = if {
        $self.file load32 "expected memory found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_MEMORY /= if {
        $token L:Token-location "expected memory" U:abort-with-location
    }
    $self.tokens load32 L:Tokens-len $self.current load32 = if {
        $self.file load32 "expected identifier found EOF" U:abort
    }
    $self Parser-advance #ident
    $ident L:Token-ty L:TOKEN_IDENT /= if {
        $ident L:Token-location "expected identifier" U:abort-with-location
    }
    $self.tokens load32 L:Tokens-len $self.current load32 = if {
        $self.file load32 "expected colon found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_COLON /= if {
        $token L:Token-location "expected colon" U:abort-with-location
    }
    $self Parser-parse-type #type
    $ident
    $type
    $self Parser-parse-number
    $self.current load32 $self.tokens load32 L:Tokens-len /= if {
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_NUMBER = if {
            $self Parser-parse-number
        } else {
            1
        }
    } else {
        1
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected semicolon found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_SEMICOLON /= if {
        $token L:Token-location "expected semicolon" U:abort-with-location
    }
    AST:Memory-new
}
fn Parser-parse-body(self: .Parser) -> .AST:Locals, .AST:Memories, .AST:Words {
    local token: .L:Token
    local mems: .AST:Memories
    local locals: .AST:Locals
    AST:Memories-new #mems
    AST:Locals-new #locals
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_MEMORY /= if { break }
        $mems $self Parser-parse-mem AST:Memories-push
    }
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_LOCAL /= if { break }
        $locals $self Parser-parse-loc AST:Locals-push
    }
    $locals $mems 
    $self Parser-parse-words
}
fn Parser-parse-words(self: .Parser) -> .AST:Words {
    local words: .AST:Words
    local token: .L:Token
    AST:Words-new #words
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if { break }
        $self Parser-peek #token

        $token is-start-of-word not if { break }
        $words $self Parser-parse-word AST:Words-push
    }
    $words
}

fn Parser-parse-signature(self: .Parser) -> .L:Token, .L:Token, .AST:Locals, .AST:Types {
    local ident: .L:Token
    local qualifier: .L:Token
    local token: .L:Token
    local parameters: .AST:Locals
    local ret: .AST:Types
    local body: .AST:Words
    $self.current load32 $self.tokens load32 L:Tokens-len = if { 
        $self.file load32 "expected fn found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_FN /= if {
        $token L:Token-location "expected fn" U:abort-with-location
    }
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if { 
            $self.file load32 "expected identifier found EOF" U:abort
        }
        $self Parser-advance #ident
        $ident L:Token-ty L:TOKEN_IDENT /= if {
            $ident L:Token-location "expected identifier" U:abort-with-location
        }
        $self.current load32 $self.tokens load32 L:Tokens-len = if { 
            $self.file load32 "expected string or ( found EOF" U:abort
        }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_STRING /= 
        $token L:Token-ty L:TOKEN_LEFT_PAREN /= 
        and if {
            $ident L:Token-location "expected string or (" U:abort-with-location
        }
        $token L:Token-ty L:TOKEN_STRING = if {
            $token #qualifier
            $self.current load32 $self.tokens load32 L:Tokens-len = if { 
                $self.file load32 "expected string or ( found EOF" U:abort
            }
            $self Parser-advance #token
        }
        $self Parser-parse-parameters #parameters
        $self.current load32 $self.tokens load32 L:Tokens-len = if {
            $self.file load32 "expected ) found EOF" U:abort
        }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_RIGHT_PAREN /= if {
            $token L:Token-location "expected )" U:abort-with-location
        }
        $self.current load32 $self.tokens load32 L:Tokens-len < if {
            $self Parser-peek L:Token-ty L:TOKEN_ARROW = if {
                $self Parser-advance drop
                0 0 =
            } else {
                0 1 =
            }
        } else {
            0 1 =
        } if {
            $self Parser-parse-return-types #ret
        } else {
            AST:Types-new #ret
        }
        
        $ident
        $qualifier
        $parameters
        $ret
        break
    }
}
fn Parser-parse-function(self: .Parser) -> .AST:Function {
    local ident: .L:Token
    local qualifier: .L:Token
    local token: .L:Token
    local parameters: .AST:Locals
    local ret: .AST:Types
    local body: .AST:Words
    local mems: .AST:Memories
    local locals: .AST:Locals

    $self Parser-parse-signature #ret #parameters #qualifier #ident
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected { found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
        $token L:Token-location "expected {" U:abort-with-location
    }
    $self Parser-parse-body #body #mems #locals
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected } found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_RIGHT_CURLY /= if {
        $token L:Token-location "expected }" U:abort-with-location
    }
    $ident
    $qualifier
    $parameters
    $ret
    $mems
    $locals
    $body
    AST:Function-new
}
fn Parser-parse-return-types(self: .Parser) -> .AST:Types {
    local token: .L:Token
    local rets: .AST:Types
    AST:Types-new #rets
    $rets $self Parser-parse-type AST:Types-push
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if {
            $self.file load32 "expected , or { found EOF" U:abort
        }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_COMMA /= if {
            break
        }
        $self Parser-advance drop
        $rets $self Parser-parse-type AST:Types-push
    }
    $rets
}
fn Parser-parse-parameters(self: .Parser) -> .AST:Locals {
    local params: .AST:Locals
    local token: .L:Token
    AST:Locals-new #params
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected ( found EOF" U:abort 
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LEFT_PAREN /= if {
        $token L:Token-location "expected (" U:abort-with-location
    }
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_RIGHT_PAREN = if { break }
        $params $self Parser-parse-parameter AST:Locals-push
        $self.current load32 $self.tokens load32 L:Tokens-len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_COMMA /= if {
            break
        }
        $self Parser-advance drop
    }
    $params
}
fn Parser-parse-parameter(self: .Parser) -> .AST:Local {
    local ident: .L:Token
    local token: .L:Token
    $self.current load32 $self.tokens load32 L:Tokens-len = if { 
        $self.file load32 "expected identifier found EOF" U:abort
    }
    $self Parser-advance #ident
    $ident L:Token-ty L:TOKEN_IDENT /= if {
        $ident L:Token-location "expected identifier" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if { 
        $self.file load32 "expected : found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_COLON /= if {
        $ident L:Token-location "expected colon" U:abort-with-location
    }
    $ident
    $self Parser-parse-type
    AST:Local-new
}
fn Parser-parse-type(self: .Parser) -> .AST:Type {
    local type: .AST:Type
    $self Parser-parse-type-inner #type
    $self.types load32 $type AST:Types-push
    $type
}
fn Parser-parse-type-inner(self: .Parser) -> .AST:Type {
    local token: .L:Token
    local module: .L:Token
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected type found EOF" U:abort
    }
    $self Parser-advance #token
    loop {
        $token L:Token-ty L:TOKEN_DOT = if {
            $self Parser-parse-type AST:Type-new-ptr break
        }
        $token L:Token-ty L:TOKEN_I32 = if {
            AST:Type-new-int32 break
        }
        $token L:Token-ty L:TOKEN_I64 = if {
            AST:Type-new-int64 break
        }
        $token L:Token-ty L:TOKEN_BOOL = if {
            AST:Type-new-boolean break
        }
        $token L:Token-ty L:TOKEN_IDENT = if {
            $self.current load32 $self.tokens load32 L:Tokens-len < if {
                $self Parser-peek L:Token-ty L:TOKEN_COLON = if {
                    $self Parser-advance drop
                    $self.current load32 $self.tokens load32 L:Tokens-len = if {
                        $self.file load32 "expected identifier" U:abort
                    }
                    $token #module
                    $self Parser-advance #token
                    $token L:Token-ty L:TOKEN_IDENT /= if {
                        $token L:Token-location "expected identifier" U:abort-with-location
                    }
                    $module $token AST:Type-new-struc break
                }
            }
            0 !.L:Token $token AST:Type-new-struc break
        }
        $token L:Token-location "expected type" U:abort-with-location
    }
}
fn parse-intrinsic(token: .L:Token) -> .AST:Word, bool {
    local file: .S:String
    local line: i32
    local column: i32
    local word: .AST:Word
    $token L:Token-file #file
    $token L:Token-line #line
    $token L:Token-column #column
    loop {
        $token L:Token-lexeme S:Str-unpack "drop" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_DROP store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "flip" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_FLIP store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "+" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_ADD store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "<" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_LESS store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack ">" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_GREATER store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "=" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_EQ store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack ">=" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_GREATER_EQ store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "<=" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_LESS_EQ store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "not" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_NOT store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "mem-grow" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_MEM_GROW store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "store32" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_STORE32 store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "load32" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_LOAD32 store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "-" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_SUB store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "and" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_AND store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "store8" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_STORE8 store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "load8" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_LOAD8 store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "%" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_MOD store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "/" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_DIV store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "/=" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_NOT_EQ store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "*" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_MUL store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "mem-copy" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_MEM_COPY store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "rotl" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_ROTL store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "rotr" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_ROTR store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "or" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_OR store32
            $word 0 0 = break
        }

        0 !.AST:Word 0 1 = break
    }
}
fn Parser-parse-word(self: .Parser) -> .AST:Word {
    local token: .L:Token
    local ty: i32
    local file: .S:String
    local line: i32
    local column: i32
    local word: .AST:Word
    $self.current load32 $self.tokens load32 L:Tokens-len = if { 
        $self.file load32 "Expected word found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty #ty
    $token L:Token-file #file
    $token L:Token-line #line
    $token L:Token-column #column
    loop {
        $ty L:TOKEN_IDENT = if {
            $token parse-intrinsic if {
                break
            } else { drop }
            AST:WORD_CALL $file $line $column AST:Word-new #word
            $self.current load32 $self.tokens load32 L:Tokens-len < if {
                $self Parser-peek L:Token-ty L:TOKEN_COLON = if {
                    $self Parser-advance drop
                    $self.current load32 $self.tokens load32 L:Tokens-len = if { 
                        $self.file load32 "Expected ident found EOF" U:abort
                    }
                    $word.qualifier $token L:Token-lexeme store32
                    $self Parser-advance #token
                    $token L:Token-ty L:TOKEN_IDENT /= if {
                        $token L:Token-location "expected ident" U:abort-with-location
                    }
                    $word.ident $token L:Token-lexeme store32
                    $word break
                }
            }
            $word.ident $token L:Token-lexeme store32
            $word break
        }
        $ty L:TOKEN_NUMBER = if {
            AST:WORD_NUMBER $file $line $column AST:Word-new #word
            $word.number $token.number load32 store32
            $word break
        }
        $ty L:TOKEN_STRING = if {
            AST:WORD_STRING $file $line $column AST:Word-new #word
            $word.addr $self.mem load32 S:String-len store32
            $word.size $token.string load32 S:String-len store32
            //2 "token.string: " IO:write-all IO:check
            //$token.string load32 S:String-unpack U:print-bytes
            //2 $token.string load32 S:String-unpack IO:write-all IO:check
            //2 "\n" IO:write-all IO:check
            $self.mem load32 $token.string load32 S:String-unpack S:String-append
            $word break
        }
        $ty L:TOKEN_BREAK = if {
            AST:WORD_BREAK $file $line $column AST:Word-new break
        }
        $ty L:TOKEN_DOLLAR = if {
            AST:WORD_LOCAL $file $line $column AST:Word-new #word
            $self.current load32 $self.tokens load32 L:Tokens-len = if {
                $self.file load32 "Expected identifier found EOF" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_IDENT /= if {
                $token L:Token-location "expected identifier" U:abort-with-location
            }
            $word.ident $token L:Token-lexeme store32
            $word break
        }
        $ty L:TOKEN_HASH = if {
            AST:WORD_SET $file $line $column AST:Word-new #word
            $self.current load32 $self.tokens load32 L:Tokens-len = if {
                $self.file load32 "Expected identifier found EOF" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_IDENT /= if {
                $token L:Token-location "expected identifier" U:abort-with-location
            }
            $word.ident $token L:Token-lexeme store32
            $word break
        }
        $ty L:TOKEN_IF = if {
            $self.current $self.current load32 1 - store32
            AST:WORD_IF $file $line $column AST:Word-new #word
            $word.iff $self Parser-parse-iff store32
            $word break
        }
        $ty L:TOKEN_BANG = if {
            AST:WORD_CAST $file $line $column AST:Word-new #word
            $word.type $self Parser-parse-type store32
            $word break
        }
        $ty L:TOKEN_LOOP = if {
            $self.current $self.current load32 1 - store32
            AST:WORD_LOOP $file $line $column AST:Word-new #word
            $word.lop $self Parser-parse-lop store32
            $word break
        }
        $ty L:TOKEN_DOT = if {
            AST:WORD_DEREF $file $line $column AST:Word-new #word
            $self.current load32 $self.tokens load32 L:Tokens-len = if {
                $self.file load32 "Expected identifier found EOF" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_IDENT /= if {
                $token L:Token-location "expected identifier" U:abort-with-location
            }
            $word.ident $token L:Token-lexeme store32
            $word break
        }
        1 "Unexpected Token: " IO:write-all IO:check
        1 $ty L:token-ty-name IO:write-all IO:check
        1 "\n" IO:write-all IO:check
        1 CORE:exit
        0 !.AST:Word break
    }
}
fn Parser-parse-lop(self: .Parser) -> .AST:Words {
    local token: .L:Token
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected loop" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LOOP /= if {
        $token L:Token-location "expected loop" U:abort-with-location
    }

    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected {" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
        $token L:Token-location "expected {" U:abort-with-location
    }
    $self Parser-parse-words
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "expected }" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_RIGHT_CURLY /= if {
        $token L:Token-location "expected }" U:abort-with-location
    }
}
fn Parser-parse-iff(self: .Parser) -> .AST:If {
    local token: .L:Token
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "exected if" U:abort
    }
    $self Parser-advance #token
    $token
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "exected {" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
        $token L:Token-location "expected {" U:abort-with-location
    }
    $self Parser-parse-words
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        $self.file load32 "exected }" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_RIGHT_CURLY /= if {
        $token L:Token-location "expected }" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len < if {
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_ELSE = if {
            $self Parser-advance drop
            $self.current load32 $self.tokens load32 L:Tokens-len = if {
                $self.file load32 "expected {" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
                $token L:Token-location "expected {" U:abort-with-location
            }
            $self Parser-parse-words
            $self.current load32 $self.tokens load32 L:Tokens-len = if {
                $self.file load32 "expected }" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_RIGHT_CURLY /= if {
                $token L:Token-location "expected }" U:abort-with-location
            }
        } else {
            0 !.AST:Words
        }
    } else {
        0 !.AST:Words
    }
    AST:If-new
}
fn Parser-parse-number(self: .Parser) -> i32 {
    local token: .L:Token
    $self.current load32 $self.tokens load32 L:Tokens-len = if { 
        $self.file load32 "expected number found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_NUMBER /= if {
        $token L:Token-location "expected number" U:abort-with-location
    }
    $token.number load32
}
fn is-start-of-word(token: .L:Token) -> bool {
    local ty: i32
    $token L:Token-ty #ty
    $ty L:TOKEN_IDENT = 
    $ty L:TOKEN_DOLLAR = or
    $ty L:TOKEN_NUMBER = or
    $ty L:TOKEN_IF = or
    $ty L:TOKEN_LOOP = or
    $ty L:TOKEN_BREAK = or
    $ty L:TOKEN_HASH = or
    $ty L:TOKEN_STRING = or
    $ty L:TOKEN_BANG = or
    $ty L:TOKEN_DOT = or
}

fn parse(mem: .S:String, tokens: .L:Tokens) -> .AST:TopItems, .AST:Types {
    local parser: .Parser
    local items: .AST:TopItems
    $tokens $mem Parser-new #parser
    $parser Parser-parse-module #items
    $items
    $parser Parser-free
}

