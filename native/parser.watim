import "../std/alloc.watim" as A
import "../std/io.watim" as IO
import "../std/core.watim" as CORE
import "../std/str.watim" as STR
import "../std/array.watim" as Array
import "../std/arena.watim" as Arena
import "../std/byte-array.watim" as ByteArray

import "./lexer.watim" as L
import "./ast.watim" as AST
import "./util.watim" as U

struct Parser {
    tokens: .Array:Array<L:Token>
    current: i32
    mem: .ByteArray:T
    types: Array:Array<.AST:Type>
    fields: Array:Array<AST:Field>
    file: STR:Str
    arena: .Arena:Arena
}
fn Parser-new(arena: .Arena:Arena, tokens: .Array:Array<L:Token>, mem: .ByteArray:T) -> Parser {
    local self: Parser
    $arena #self.arena
    $tokens #self.tokens
    0 #self.current
    $mem #self.mem
    Array:new<.AST:Type> #self.types
    $tokens.len 0 gt if {
        $tokens 0 Array:get<L:Token> L:Token-file ~ #self.file
    }
    Array:new<AST:Field> #self.fields
    $self
} 
fn Parser-free(self: Parser) -> Array:Array<.AST:Type>, Array:Array<AST:Field> { 
    $self.types $self.fields
}
fn Parser-peek(self: .Parser) -> .L:Token {
    $self.tokens $self.current Array:get<L:Token>
}
fn Parser-advance(self: .Parser) -> .L:Token {
    $self Parser-peek
    $self.current 1 + #self.current
}
fn Parser-retreat(self: .Parser) {
    $self.current 0 gt if { $self.current 1 - #self.current }
}

fn Parser-parse-module(self: .Parser) -> Array:Array<.AST:TopItem> {
    Array:new<.AST:TopItem> @items
    loop {
        $self.tokens.len $self.current = if {
            $items break
        }
        loop {
            $self Parser-peek @token
            $token L:Token-ty L:TOKEN_FN = if {
                $self.arena &items $self Parser-parse-function AST:TopItem-new-function Array:push<.AST:TopItem>
                break
            }
            $token L:Token-ty L:TOKEN_MEMORY = if {
                $self.arena &items $self Parser-parse-mem AST:TopItem-new-mem Array:push<.AST:TopItem>
                break
            }
            $token L:Token-ty L:TOKEN_EXTERN = if {
                $self.arena &items $self Parser-parse-ext AST:TopItem-new-ext Array:push<.AST:TopItem>
                break
            }
            $token L:Token-ty L:TOKEN_IMPORT = if {
                $self.arena &items $self Parser-parse-imp AST:TopItem-new-imp Array:push<.AST:TopItem>
                break
            }
            $token L:Token-ty L:TOKEN_STRUCT = if {
                $self.arena &items $self Parser-parse-struc AST:TopItem-new-struc Array:push<.AST:TopItem>
                break
            }
            2 $token L:Token-ty L:token-ty-name IO:write-all IO:check
            $token L:Token-location "expected function memory or import" U:abort-with-location
            break
        }
    }
}
fn Parser-parse-struc(self: .Parser) -> .AST:Struct {
    local token: .L:Token
    local ident: .L:Token
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected struct" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_STRUCT /= if {
        $token L:Token-location "expected struct" U:abort-with-location
    }
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected identifier" U:abort
    }
    $self Parser-advance #ident
    $ident L:Token-ty L:TOKEN_IDENT /= if {
        $token L:Token-location "expected identifier" U:abort-with-location
    }
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected { or <" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LEFT_CURLY /= 
    $token L:Token-ty L:TOKEN_LEFT_TRIANGLE /= and
    if {
        $token L:Token-location "expected { or <" U:abort-with-location
    }
    AST:Generics-new @generics
    $token L:Token-ty L:TOKEN_LEFT_TRIANGLE = if {
        loop {
            $self.current $self.tokens.len = if { break }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_RIGHT_TRIANGLE = if { break }
            $token L:Token-ty L:TOKEN_IDENT /= if {
                $token L:Token-location "expected identifier" U:abort-with-location
            }

            &generics $token AST:Generic-new AST:Generics-push

            $self.current $self.tokens.len = if { break }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_RIGHT_TRIANGLE = if { break }
            $token L:Token-ty L:TOKEN_COMMA /= if {
                $token L:Token-location "expected , or >" U:abort-with-location
            }
        }
        $self.current $self.tokens.len = if {
            $self.file STR:Str-unpack "expected {" U:abort
        }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
            $token L:Token-location "expected {" U:abort-with-location
        }
    }
    Array:new<AST:Field> @fields
    loop {
        $self.current $self.tokens.len = if { break }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_RIGHT_CURLY = if { break }
        $token L:Token-ty L:TOKEN_IDENT /= if {
            $token L:Token-location "expected identifier" U:abort-with-location
        }
        $token
        $self.current $self.tokens.len = if {
            $self.file STR:Str-unpack "expected colon" U:abort
        }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_COLON /= if {
            $token L:Token-location "expected colon" U:abort-with-location
        }
        $self Parser-parse-type
        AST:Field-new @field
        $self.arena &self.fields $field Array:push<AST:Field>
        $self.arena &fields $field Array:push<AST:Field>
    }
    $ident $fields $generics 1 1 = AST:Struct-new
}
fn Parser-parse-imp(self: .Parser) -> AST:Import {
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected import" U:abort
    }
    $self Parser-advance @token
    $token L:Token-ty L:TOKEN_IMPORT /= if {
        $token L:Token-location "expected import" U:abort-with-location
    }
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected string" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_STRING /= if {
        $token L:Token-location "exected string" U:abort-with-location
    }
    $token
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected as" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_AS /= if {
        $token L:Token-location "exected as" U:abort-with-location
    }
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected identifier" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_IDENT /= if {
        $token L:Token-location "exected identifier" U:abort-with-location
    }
    $token
    AST:Import-new
}
fn Parser-parse-ext(self: .Parser) -> AST:Extern {
    $self.tokens.len $self.current = if {
        $self.file STR:Str-unpack "expected extern" U:abort
    }
    $self Parser-advance @token
    $token L:Token-ty L:TOKEN_EXTERN /= if {
        $token L:Token-location "expected extern" U:abort-with-location
    }
    $self.tokens.len $self.current = if {
        $self.file STR:Str-unpack "expected string" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_STRING /= if {
        $token L:Token-location "expected string" U:abort-with-location
    }
    $token @module
    $self.tokens.len $self.current = if {
        $self.file STR:Str-unpack "expected string" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_STRING /= if {
        $token L:Token-location "expected string" U:abort-with-location
    }
    $token @name
    $module
    $name
    $self Parser-parse-signature @rets @params @generics drop @ident

    &generics AST:Generics-len 0 /= if {
        $name L:Token-location "externs cannot have generics" U:abort-with-location
    }

    $ident
    $params
    $rets
    AST:Extern-new
}
fn Parser-parse-loc(self: .Parser) -> AST:Local {
    local token: .L:Token
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected local" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LOCAL /= if {
        $token L:Token-location "expected local" U:abort-with-location
    }
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected identifier" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_IDENT /= if {
        $token L:Token-location "expected identifier" U:abort-with-location
    }
    AST:LOCAL_LOCAL
    $token
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected colon" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_COLON /= if {
        $token L:Token-location "expected colon" U:abort-with-location
    }
    $self Parser-parse-type
    0
    0
    AST:Local-new
}
fn Parser-parse-mem(self: .Parser) -> AST:Local {
    $self.tokens.len $self.current = if {
        $self.file STR:Str-unpack "expected memory found EOF" U:abort
    }
    $self Parser-advance @token
    $token L:Token-ty L:TOKEN_MEMORY /= if {
        $token L:Token-location "expected memory" U:abort-with-location
    }
    $self.tokens.len $self.current = if {
        $self.file STR:Str-unpack "expected identifier found EOF" U:abort
    }
    $self Parser-advance @ident
    $ident L:Token-ty L:TOKEN_IDENT /= if {
        $ident L:Token-location "expected identifier" U:abort-with-location
    }
    $self.tokens.len $self.current = if {
        $self.file STR:Str-unpack "expected colon found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_COLON /= if {
        $token L:Token-location "expected colon" U:abort-with-location
    }
    $self Parser-parse-type @type

    $self.arena 
    &self.types
    $ident
    $type
    $self Parser-parse-number
    AST:Local-new-mem
}
fn Parser-parse-body(self: .Parser, locals: .AST:Locals) -> Array:Array<AST:Word> {
    local token: .L:Token
    loop {
        $self.current $self.tokens.len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_MEMORY /= if { break }
        $self.arena $locals $self Parser-parse-mem AST:Locals-push
    }
    loop {
        $self.current $self.tokens.len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_LOCAL /= if { break }
        $self.arena $locals $self Parser-parse-loc AST:Locals-push
    }
    $self Parser-parse-words
}
fn Parser-parse-words(self: .Parser) -> Array:Array<AST:Word> {
    Array:new<AST:Word> @words
    loop {
        $self.current $self.tokens.len = if { break }
        $self Parser-peek @token

        $token is-start-of-word not if { break }
        $self.arena &words $self Parser-parse-word Array:push<AST:Word>
    }
    $words
}

fn Parser-parse-signature(self: .Parser) -> .L:Token, .L:Token, AST:Generics, AST:Locals, .AST:Types {
    local ident: .L:Token
    local qualifier: .L:Token
    local token: .L:Token
    local parameters: AST:Locals
    local ret: .AST:Types
    AST:Generics-new @generics
    $self.current $self.tokens.len = if { 
        $self.file STR:Str-unpack "expected fn found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_FN /= if {
        $token L:Token-location "expected fn" U:abort-with-location
    }
    block {
        $self.current $self.tokens.len = if { 
            $self.file STR:Str-unpack "expected identifier found EOF" U:abort
        }
        $self Parser-advance #ident
        $ident L:Token-ty L:TOKEN_IDENT /= if {
            $ident L:Token-location "expected identifier" U:abort-with-location
        }
        $self.current $self.tokens.len = if { 
            $self.file STR:Str-unpack "expected string, ( or < found EOF" U:abort
        }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_STRING /= 
        $token L:Token-ty L:TOKEN_LEFT_PAREN /= and
        $token L:Token-ty L:TOKEN_LEFT_TRIANGLE /= and
        if {
            $ident L:Token-location "expected string, ( or <" U:abort-with-location
        }
        $token L:Token-ty L:TOKEN_STRING = if {
            $token #qualifier
            $self.current $self.tokens.len = if { 
                $self.file STR:Str-unpack "expected ( found EOF" U:abort
            }
            $self Parser-advance #token
        }
        $token L:Token-ty L:TOKEN_LEFT_TRIANGLE = if {
            $self Parser-advance #token
            loop {
                $self.current $self.tokens.len = if {
                    $self.file STR:Str-unpack "expected Generic found EOF" U:abort
                }
                $self Parser-advance #token
                $token L:Token-ty L:TOKEN_RIGHT_TRIANGLE = if {
                    break
                }
                $token L:Token-ty L:TOKEN_IDENT /= if {
                    $token L:Token-location "expected identifier" U:abort-with-location
                }
                &generics $token AST:Generic-new AST:Generics-push
                $self.current $self.tokens.len = if {
                    $self.file STR:Str-unpack "expected > or , found EOF" U:abort
                }
                $self Parser-advance #token
                $token L:Token-ty L:TOKEN_RIGHT_TRIANGLE = if {
                    break
                }
                $token L:Token-ty L:TOKEN_COMMA /= if {
                    break
                }
            }
        }
        $self Parser-parse-parameters #parameters
        $self.current $self.tokens.len = if {
            $self.file STR:Str-unpack "expected ) found EOF\n" U:abort
        }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_RIGHT_PAREN /= if {
            $token L:Token-location "expected )\n" U:abort-with-location
        }
        $self.current $self.tokens.len lt if {
            $self Parser-peek L:Token-ty L:TOKEN_ARROW = if {
                $self Parser-advance drop
                0 0 =
            } else {
                0 1 =
            }
        } else {
            0 1 =
        } if {
            $self Parser-parse-return-types #ret
        } else {
            $self.arena AST:Types-new #ret
        }
        
        $ident
        $qualifier
        $generics
        $parameters
        $ret
    }
}
fn Parser-parse-function(self: .Parser) -> .AST:Function {
    $self Parser-parse-signature @ret @locals @generics @qualifier @ident
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected { found EOF" U:abort
    }
    $self Parser-advance @token
    $token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
        $token L:Token-location "expected {" U:abort-with-location
    }
    $self &locals Parser-parse-body @body
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected } found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_RIGHT_CURLY /= if {
        $token L:Token-location "expected }" U:abort-with-location
    }
    $self.arena
    $ident
    $qualifier
    $generics
    $ret
    $locals
    $body
    AST:Function-new
}
fn Parser-parse-return-types(self: .Parser) -> .AST:Types {
    $self.arena AST:Types-new @rets
    $self.arena $rets $self Parser-parse-type AST:Types-push
    loop {
        $self.current $self.tokens.len = if {
            $self.file STR:Str-unpack "expected , or { found EOF" U:abort
        }
        $self Parser-peek @token
        $token L:Token-ty L:TOKEN_COMMA /= if {
            break
        }
        $self Parser-advance drop
        $self.arena $rets $self Parser-parse-type AST:Types-push
    }
    $rets
}
fn Parser-parse-parameters(self: .Parser) -> AST:Locals {
    local params: AST:Locals
    local token: .L:Token
    AST:Locals-new #params
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected ( found EOF" U:abort 
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LEFT_PAREN /= if {
        $token L:Token-location "expected (" U:abort-with-location
    }
    loop {
        $self.current $self.tokens.len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_RIGHT_PAREN = if { break }
        $self.arena &params $self Parser-parse-parameter AST:Locals-push
        $self.current $self.tokens.len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_COMMA /= if {
            break
        }
        $self Parser-advance drop
    }
    $params
}
fn Parser-parse-parameter(self: .Parser) -> AST:Local {
    $self.current $self.tokens.len = if { 
        $self.file STR:Str-unpack "expected identifier found EOF" U:abort
    }
    $self Parser-advance @ident
    $ident L:Token-ty L:TOKEN_IDENT /= if {
        $ident L:Token-location "expected identifier" U:abort-with-location
    }
    $self.current $self.tokens.len = if { 
        $self.file STR:Str-unpack "expected : found EOF" U:abort
    }
    $self Parser-advance @token
    $token L:Token-ty L:TOKEN_COLON /= if {
        $ident L:Token-location "expected colon" U:abort-with-location
    }
    AST:LOCAL_ARGUMENT
    $ident
    $self Parser-parse-type
    0 0 AST:Local-new
}
fn Parser-parse-type(self: .Parser) -> .AST:Type {
    $self Parser-parse-type-inner @type
    $self.arena &self.types $type Array:push<.AST:Type>
    $type
}
fn Parser-parse-type-inner(self: .Parser) -> .AST:Type {
    local token: .L:Token
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected type found EOF" U:abort
    }
    $self Parser-advance #token

    block {
        $token L:Token-ty L:TOKEN_DOT = if {
            $self.arena $self Parser-parse-type AST:Type-new-ptr break
        }
        $token L:Token-ty L:TOKEN_I32 = if {
            $self.arena AST:Type-new-int32 break
        }
        $token L:Token-ty L:TOKEN_I64 = if {
            $self.arena AST:Type-new-int64 break
        }
        $token L:Token-ty L:TOKEN_BOOL = if {
            $self.arena AST:Type-new-boolean break
        }
        $token L:Token-ty L:TOKEN_LEFT_PAREN = if {
            $self.arena AST:Types-new @args
            $self.arena AST:Types-new @rets
            
            loop {
                $self.current $self.tokens.len = if { break }
                $self Parser-peek L:Token-ty L:TOKEN_ARROW = if { break }
                $self.arena $args $self Parser-parse-type AST:Types-push

                $self.current $self.tokens.len = if { break }
                $self Parser-peek L:Token-ty L:TOKEN_ARROW = if { break }
                $self Parser-advance #token
                $token L:Token-ty L:TOKEN_COMMA /= if {
                    $token L:Token-location "expected ," U:abort-with-location
                }
            }
            $self.current $self.tokens.len = if {
                $self.file STR:Str-unpack "expected ->" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_ARROW /= if {
                $token L:Token-location "expected ->" U:abort-with-location
            }
            loop {
                $self.current $self.tokens.len = if { break }
                $self Parser-peek L:Token-ty L:TOKEN_RIGHT_PAREN = if { break }
                $self.arena $rets $self Parser-parse-type AST:Types-push

                $self.current $self.tokens.len = if { break }
                $self Parser-peek L:Token-ty L:TOKEN_RIGHT_PAREN = if { break }
                $self Parser-advance #token
                $token L:Token-ty L:TOKEN_COMMA /= if {
                    $token L:Token-location "expected ," U:abort-with-location
                }
            }
            $self.current $self.tokens.len = if { 
                $self.file STR:Str-unpack "expected )" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_RIGHT_PAREN /= if {
                $token L:Token-location "expected )" U:abort-with-location
            }
            $self.arena $args $rets AST:Type-new-function break
        }
        $token L:Token-ty L:TOKEN_IDENT = if {
            loop {
                $self.current $self.tokens.len lt if {
                    $self Parser-peek L:Token-ty L:TOKEN_COLON = if {
                        $self Parser-advance drop
                        $self.current $self.tokens.len = if {
                            $self.file STR:Str-unpack "expected identifier" U:abort
                        }
                        $token @module
                        $self Parser-advance #token
                        $token L:Token-ty L:TOKEN_IDENT /= if {
                            $token L:Token-location "expected identifier" U:abort-with-location
                        }
                        $module $token break
                    }
                }
                0 !.L:Token $token
                break
            } @token @module

            $self.arena AST:Types-new @generics
            
            $self.current $self.tokens.len = if {
                $self.arena $module $token $generics AST:Type-new-struc break
            }
            $self Parser-peek L:Token-ty L:TOKEN_LEFT_TRIANGLE /= if {
                $self.arena $module $token $generics AST:Type-new-struc break
            }
            $self Parser-advance drop // skip the <

            loop {
                $self.current $self.tokens.len = if { break }
                $self Parser-peek L:Token-ty L:TOKEN_RIGHT_TRIANGLE = if { 
                    $self Parser-advance drop // drop the >
                    break
                }

                $self Parser-parse-type @type
                $self.arena $generics $type AST:Types-push

                $self Parser-peek L:Token-ty L:TOKEN_RIGHT_TRIANGLE = if {
                    $self Parser-advance drop // drop the >
                    break
                }
                $self Parser-peek L:Token-ty L:TOKEN_COMMA = if { 
                    $self Parser-advance drop // drop the comma
                } else {
                    $self Parser-peek L:Token-location "expected , or >" U:abort-with-location
                }
            }
            $self.arena  $module $token $generics AST:Type-new-struc break
        }
        $token L:Token-ty L:TOKEN_LEFT_BRACKET = if {
            $self Parser-parse-type @type
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_COLON /= if {
                $token L:Token-location "expected :\n" U:abort-with-location
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_NUMBER /= if {
                $token L:Token-location "expected number\n" U:abort-with-location
            }
            $token.number @length
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_RIGHT_BRACKET /= if {
                $token L:Token-location "expected ]\n" U:abort-with-location
            }
            $self.arena $type $length AST:Type-new-array break
        }
        $token L:Token-location "expected type\n" U:abort-with-location
        CORE:unreachable<.AST:Type>
    }
}
fn Parser-parse-intrinsic(self: .Parser, token: .L:Token) -> AST:Word, bool {
    local file: STR:Str
    local line: i32
    local column: i32
    local word: AST:Word
    $token L:Token-file ~ #file
    $token L:Token-line #line
    $token L:Token-column #column
    block {
        $token L:Token-lexeme ~ STR:Str-unpack "drop" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_DROP #word.intrinsic
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "flip" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_FLIP #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "+" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_ADD #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "lt" STR:str-eq 
        $token L:Token-lexeme ~ STR:Str-unpack "<" STR:str-eq or
        if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_LESS #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "gt" STR:str-eq 
        $token L:Token-lexeme ~ STR:Str-unpack ">" STR:str-eq or
        if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_GREATER #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "=" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_EQ #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "le" STR:str-eq 
        $token L:Token-lexeme ~ STR:Str-unpack "<=" STR:str-eq or
        if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_LESS_EQ #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "ge" STR:str-eq 
        $token L:Token-lexeme ~ STR:Str-unpack ">=" STR:str-eq or
        if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_GREATER_EQ #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "not" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_NOT #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "mem-grow" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_MEM_GROW #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "-" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_SUB #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "and" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_AND #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "store8" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_STORE8 #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "load8" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_LOAD8 #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "%" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_MOD #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "/" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_DIV #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "/=" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_NOT_EQ #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "*" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_MUL #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "mem-copy" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_MEM_COPY #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "rotl" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_ROTL #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "rotr" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_ROTR #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "or" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_OR #word.intrinsic 
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "store" STR:str-eq if {
            AST:WORD_INTRINSIC $token AST:Word-new #word
            AST:INTRINSIC_STORE #word.intrinsic
            $word 0 0 = break
        }
        $token L:Token-lexeme ~ STR:Str-unpack "sizeof" STR:str-eq if {
            AST:WORD_SIZEOF $token AST:Word-new #word
            $self.current $self.tokens.len = if {
                $self.file STR:Str-unpack "Expected ( found EOF" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_LEFT_PAREN /= if  {
                $token L:Token-location "expected (" U:abort-with-location
            }
            $self Parser-parse-type #word.type
            $token L:Token-lexeme #word.ident

            $self.current $self.tokens.len = if {
                $self.file STR:Str-unpack "Expected ) found EOF" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_RIGHT_PAREN /= if {
                $token L:Token-location "expected )\n" U:abort-with-location
            }
            $word 0 0 = break
        }
        AST:Word-new-uninit 0 1 =
    }
}

fn Parser-parse-word(self: .Parser) -> AST:Word {
    local token: .L:Token
    local ty: i32
    local file: STR:Str
    local line: i32
    local column: i32
    local word: AST:Word
    $self.current $self.tokens.len = if { 
        $self.file STR:Str-unpack "Expected word found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty #ty
    $token L:Token-file ~ #file
    $token L:Token-line #line
    $token L:Token-column #column
    block {
        $ty L:TOKEN_IDENT = if {
            $self $token Parser-parse-intrinsic if {
                break
            } else { drop }
            $self $token Parser-parse-call break
        }
        $ty L:TOKEN_DOLLAR = if {
            $self $file $line $column Parser-parse-get-locl break
        }
        $ty L:TOKEN_NUMBER = if {
            AST:WORD_NUMBER $token AST:Word-new #word
            $token.number #word.number
            $word break
        }
        $ty L:TOKEN_STRING = if {
            AST:WORD_STRING $token AST:Word-new #word

            $token.string.len #word.size
            $token.string #word.string
            $self.mem ByteArray:unpack
            $token.string STR:Str-unpack
            STR:str-find-str if {
                #word.addr
            } else {
                drop
                $self.mem.len #word.addr
                $self.arena $self.mem $token.string STR:Str-unpack ByteArray:push
            }
            $word break
        }
        $ty L:TOKEN_BREAK = if {
            AST:WORD_BREAK $token AST:Word-new break
        }
        $ty L:TOKEN_IF = if {
            AST:WORD_IF $token AST:Word-new #word
            $self Parser-parse-iff #word.iff
            $word break
        }
        $ty L:TOKEN_BANG = if {
            AST:WORD_CAST $token AST:Word-new #word
            $self Parser-parse-type #word.type
            $word break
        }
        $ty L:TOKEN_LOOP = if {
            AST:WORD_LOOP $token AST:Word-new #word
            $token $self Parser-parse-block AST:Loop-new #word.lop
            $word break
        }
        $ty L:TOKEN_BLOCK = if {
            AST:WORD_BLOCK $token AST:Word-new #word
            $token $self Parser-parse-block AST:Block-new #word.blok
            $word break
        }
        $ty L:TOKEN_DOT = if {
            $self $token Parser-parse-deref break
        }
        $ty L:TOKEN_HASH = if {
            $self $token Parser-parse-set-locl break
        }
        $ty L:TOKEN_AT = if {
            $self $token Parser-parse-init-locl break
        }
        $ty L:TOKEN_AMPERSAND = if {
            $self $token Parser-parse-get-ref break
        }
        $ty L:TOKEN_TILDE = if {
            AST:WORD_LOAD $token AST:Word-new break
        }
        $ty L:TOKEN_DOUBLE_ARROW = if {
            $self $token Parser-parse-store break
        }
        $ty L:TOKEN_COLON_COLON = if {
            $self $token Parser-parse-annotation break
        }
        $ty L:TOKEN_LEFT_BRACKET = if {
            $self $token Parser-parse-array-access break
        }
        $ty L:TOKEN_BRACKET_EQUAL = if {
            $self $token Parser-parse-array-init-zero break
        }
        $ty L:TOKEN_ARROW = if {
            AST:WORD_CALL_INDIRECT $token AST:Word-new break
        }
        $ty L:TOKEN_BACKSLASH = if {
            $self.current $self.tokens.len = if {
                $self.file STR:Str-unpack "Expected ident found EOF" U:abort
            }
            AST:WORD_REF_FUNCTION $token AST:Word-new @word

            $self Parser-advance #token
            $self $token &word Parser-parse-call-inner
            $word break
        }
        $token L:Token-location "Unexpected Token\n" U:abort-with-location
        AST:Word-new-uninit
    }
}

fn Parser-parse-call(self: .Parser, token: .L:Token) -> AST:Word { 
    $token L:Token-ty L:TOKEN_IDENT /= if {
        $token L:Token-location "expected ident" U:abort-with-location
    }
    AST:WORD_CALL $token AST:Word-new @word
    $self $token &word Parser-parse-call-inner
    $word
}
fn Parser-parse-call-inner(self: .Parser, token: .L:Token, word: .AST:Word) { block {
    $token L:Token-lexeme #word.ident
    $self.current $self.tokens.len ge if { break }
    $self Parser-peek L:Token-ty L:TOKEN_COLON = if {
        $self Parser-advance drop
        $self.current $self.tokens.len = if { 
            $self.file STR:Str-unpack "Expected ident found EOF" U:abort
        }
        $token L:Token-lexeme #word.qualifier
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_IDENT /= if {
            $token L:Token-location "expected ident" U:abort-with-location
        }
        $token L:Token-lexeme #word.ident
    }
    $self.current $self.tokens.len ge if { break }
    $self Parser-peek L:Token-ty L:TOKEN_LEFT_TRIANGLE /= if { break }
    $self Parser-advance drop
    $self.arena AST:Types-new #word.generics
    loop {
        $self.current $self.tokens.len ge if { break }
        $self Parser-peek L:Token-ty L:TOKEN_RIGHT_TRIANGLE = if { break }

        $self Parser-parse-type @type

        $self.arena $word.generics $type AST:Types-push

        $self.current $self.tokens.len ge if { 
            $self.file STR:Str-unpack "Expected > or , found EOF" U:abort
        }
        $self Parser-peek L:Token-ty L:TOKEN_COMMA /= if { break }
        $self Parser-advance drop
    }
    $self.current $self.tokens.len ge if {
        $self.file STR:Str-unpack "Expected > found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_RIGHT_TRIANGLE /= if {
        $self.file STR:Str-unpack "Expected >" U:abort
    }
} }

fn Parser-parse-array-access(self: .Parser, token: .L:Token) -> AST:Word {
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected #, $, & or = found EOF" U:abort
    }
    $token @start-token
    $self Parser-advance #token
    block {
        $token L:Token-ty L:TOKEN_HASH = if { AST:WORD_ARRAY_WRITE break }
        $token L:Token-ty L:TOKEN_DOLLAR = if { AST:WORD_ARRAY_READ break }
        $token L:Token-ty L:TOKEN_AMPERSAND = if { AST:WORD_ARRAY_REF break }
        $token L:Token-ty L:TOKEN_NUMBER = if { AST:WORD_ARRAY_INIT break }
        $token L:Token-location "Expected #, $, &, = or an integer\n" U:abort-with-location
        CORE:unreachable<i32>
    } $start-token AST:Word-new @word

    $word.ty AST:WORD_ARRAY_INIT = if {
        $token.number #word.size
    }

    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "Expected ] found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_RIGHT_BRACKET /= if {
        $token L:Token-location "Expected ]\n" U:abort-with-location
    }
    $word
}

fn Parser-parse-array-init-zero(self: .Parser, token: .L:Token) -> AST:Word {
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "Expected number found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_NUMBER /= if {
        $token L:Token-location "Expected number\n" U:abort-with-location
    }
    AST:WORD_ARRAY_INIT_ZERO $token AST:Word-new @word
    $token.number #word.size

    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "Expected ] found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_RIGHT_BRACKET /= if {
        $token L:Token-location "Expected ]\n" U:abort-with-location
    }
    $word
}

fn Parser-parse-annotation(self: .Parser, token: .L:Token) -> AST:Word {
    $self Parser-parse-type @type
    $token $type AST:Word-new-annotation
}

fn Parser-parse-get-locl(self: .Parser, file: STR:Str, line: i32, column: i32) -> AST:Word {
    local word: AST:Word
    local token: .L:Token
    $self.current $self.tokens.len = if {
        $file STR:Str-unpack "expected identifier found EOF" U:abort
    }
    $self Parser-advance #token
    $self.current $self.tokens.len = if {
        $file STR:Str-unpack $line $column "expected identifier" U:abort-with-location
    }
    AST:WORD_GET_LOCAL $token AST:Word-new #word
    $token L:Token-lexeme #word.ident
    Array:new<.L:Token> #word.fields
    loop {
        $self.current $self.tokens.len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_DOT /= if { break }
        $self Parser-advance #token
        $self.current $self.tokens.len = if {
            $file STR:Str-unpack "expected identifier found EOF" U:abort
        }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_IDENT /= if {
            $token L:Token-location "expected identifier" U:abort-with-location
        }
        $self.arena &word.fields $token Array:push<.L:Token>
    }
    $word
}
fn Parser-parse-ident-and-fields-access(self: .Parser, token: .L:Token) -> Array:Array<.L:Token>, .STR:Str {
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected identifier found EOF" U:abort
    }
    $self Parser-advance @ident
    $ident L:Token-ty L:TOKEN_IDENT /= if {
        $ident L:Token-location "expected identifier" U:abort-with-location
    }
    $self Parser-parse-fields-access $ident L:Token-lexeme
}
fn Parser-parse-fields-access(self: .Parser) -> Array:Array<.L:Token> {
    Array:new<.L:Token> @fields
    loop {
        $self.current $self.tokens.len = if { break }
        $self Parser-peek @token
        $token L:Token-ty L:TOKEN_DOT /= if { break }
        $self Parser-advance #token
        $self.current $self.tokens.len = if {
            $self.file STR:Str-unpack "expected identifier found EOF" U:abort
        }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_IDENT /= if {
            $token L:Token-location "expected identifier" U:abort-with-location
        }
        $self.arena &fields $token Array:push<.L:Token>
    }
    $fields
}
fn Parser-parse-deref(self: .Parser, token: .L:Token) -> AST:Word {
    AST:WORD_DEREF $token AST:Word-new @word
    $self Parser-retreat
    $self Parser-parse-fields-access #word.fields
    $word
}
fn Parser-parse-get-ref(self: .Parser, token: .L:Token) -> AST:Word {
    local word: AST:Word
    AST:WORD_GET_REF $token AST:Word-new #word
    $self $token Parser-parse-ident-and-fields-access
    #word.ident
    #word.fields
    $word
}
fn Parser-parse-store(self: .Parser, token: .L:Token) -> AST:Word {
    local word: AST:Word
    AST:WORD_STORE $token AST:Word-new #word
    $self $token Parser-parse-ident-and-fields-access 
    #word.ident
    #word.fields
    $word
}
fn Parser-parse-init-locl(self: .Parser, token: .L:Token) -> AST:Word {
    local word: AST:Word
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "Expected identifier found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_IDENT /= if {
        $token L:Token-location "expected identifier" U:abort-with-location
    }
    AST:WORD_INIT_LOCAL $token AST:Word-new #word
    $token L:Token-lexeme #word.ident
    $word
}
fn Parser-parse-set-locl(self: .Parser, token: .L:Token) -> AST:Word {
    local word: AST:Word
    AST:WORD_SET $token AST:Word-new #word
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "Expected identifier found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_IDENT /= if {
        $token L:Token-location "expected identifier" U:abort-with-location
    }
    $token L:Token-lexeme #word.ident
    Array:new<.L:Token> #word.fields
    loop {
        $self.current $self.tokens.len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_DOT /= if { break }
        $self Parser-advance #token
        $self.current $self.tokens.len = if { 
            $self.file STR:Str-unpack "expected identifier found EOF" U:abort
        }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_IDENT /= if {
            $token L:Token-location "expected identifier" U:abort-with-location
        }
        $self.arena &word.fields $token Array:push<.L:Token>
    }
    $word
}

fn Parser-parse-block(self: .Parser) -> Array:Array<AST:Word> {
    local token: .L:Token
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
        $token L:Token-location "expected {" U:abort-with-location
    }
    $self Parser-parse-words
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "expected }" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_RIGHT_CURLY /= if {
        $token L:Token-location "expected }" U:abort-with-location
    }
}

fn Parser-parse-iff(self: .Parser) -> AST:If {
    local token: .L:Token
    $self.current 1 - #self.current
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "exected if" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_IF /= if {
        $token L:Token-location "exected if" U:abort-with-location
    }
    $token
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "exected {" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
        $token L:Token-location "expected {" U:abort-with-location
    }
    $self Parser-parse-words
    $self.current $self.tokens.len = if {
        $self.file STR:Str-unpack "exected }" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_RIGHT_CURLY /= if {
        $token L:Token-location "expected }" U:abort-with-location
    }
    $self.current $self.tokens.len lt if {
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_ELSE = if {
            $self Parser-advance drop
            $self.current $self.tokens.len = if {
                $self.file STR:Str-unpack "expected {" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
                $token L:Token-location "expected {" U:abort-with-location
            }
            $self Parser-parse-words
            $self.current $self.tokens.len = if {
                $self.file STR:Str-unpack "expected }" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_RIGHT_CURLY /= if {
                $token L:Token-location "expected }" U:abort-with-location
            }
            AST:If-new-with-el
        } else {
            AST:If-new
        }
    } else {
        AST:If-new
    }
}
fn Parser-parse-number(self: .Parser) -> i32 {
    local token: .L:Token
    $self.current $self.tokens.len = if { 
        $self.file STR:Str-unpack "expected number found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_NUMBER /= if {
        $token L:Token-location "expected number" U:abort-with-location
    }
    $token.number
}
fn is-start-of-word(token: .L:Token) -> bool {
    local ty: i32
    $token L:Token-ty #ty
    $ty L:TOKEN_IDENT = 
    $ty L:TOKEN_DOLLAR = or
    $ty L:TOKEN_NUMBER = or
    $ty L:TOKEN_IF = or
    $ty L:TOKEN_LOOP = or
    $ty L:TOKEN_BREAK = or
    $ty L:TOKEN_HASH = or
    $ty L:TOKEN_AT = or
    $ty L:TOKEN_STRING = or
    $ty L:TOKEN_BANG = or
    $ty L:TOKEN_DOT = or
    $ty L:TOKEN_AMPERSAND = or
    $ty L:TOKEN_TILDE = or
    $ty L:TOKEN_DOUBLE_ARROW = or
    $ty L:TOKEN_COLON_COLON = or
    $ty L:TOKEN_LEFT_BRACKET = or
    $ty L:TOKEN_BLOCK = or
    $ty L:TOKEN_BRACKET_EQUAL = or
    $ty L:TOKEN_BACKSLASH = or
    $ty L:TOKEN_ARROW = or
}

fn parse(arena: .Arena:Arena, mem: .ByteArray:T, tokens: .Array:Array<L:Token>) -> Array:Array<.AST:TopItem>, Array:Array<.AST:Type>, Array:Array<AST:Field> {
    $arena $tokens $mem Parser-new @parser
    &parser Parser-parse-module
    $parser Parser-free
}

