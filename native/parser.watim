import "./lexer.watim" as L
import "./ast.watim" as AST
import "../std/alloc.watim" as A
import "../std/io.watim" as IO
import "../std/core.watim" as CORE
import "../std/string.watim" as S
import "../std/string2.watim" as S2
import "./util.watim" as U

struct Parser {
    tokens: .L:Tokens
    current: i32
    mem: .S2:String
    types: .AST:Types
    file: S:Str
}
fn Parser-new(tokens: .L:Tokens, mem: .S2:String) -> Parser {
    local self: Parser
    ?tokens @self.tokens
    0 @self.current
    ?mem @self.mem
    AST:Types-new @self.types
    ?tokens L:Tokens-len 0 > if {
        ?tokens 0 L:Tokens-get L:Token-file ~ @self.file
    }
    ?self
} 
fn Parser-free(self: Parser) -> .AST:Types { 
    ?self.types
}
fn Parser-peek(self: .Parser) -> .L:Token {
    ?self.tokens ?self.current L:Tokens-get
}
fn Parser-peek2(self: .Parser) -> .L:Token {
    ?self.tokens ?self.current 2 + L:Tokens-get
}
fn Parser-advance(self: .Parser) -> .L:Token {
    ?self Parser-peek
    ?self.current 1 + @self.current
}

fn Parser-parse-module(self: .Parser) -> .AST:TopItems {
    local token: .L:Token
    local items: .AST:TopItems
    AST:TopItems-new #items
    loop {
        $self.tokens load32 L:Tokens-len $self.current load32 = if {
            $items break
        }
        loop {
            $self Parser-peek #token
            $token L:Token-ty L:TOKEN_FN = if {
                $items $self Parser-parse-function AST:TopItem-new-function AST:TopItems-push
                break
            }
            $token L:Token-ty L:TOKEN_MEMORY = if {
                $items $self Parser-parse-mem AST:TopItem-new-mem AST:TopItems-push
                break
            }
            $token L:Token-ty L:TOKEN_EXTERN = if {
                $items $self Parser-parse-ext AST:TopItem-new-ext AST:TopItems-push
                break
            }
            $token L:Token-ty L:TOKEN_IMPORT = if {
                $items $self Parser-parse-imp AST:TopItem-new-imp AST:TopItems-push
                break
            }
            $token L:Token-ty L:TOKEN_STRUCT = if {
                $items $self Parser-parse-struc AST:TopItem-new-struc AST:TopItems-push
                break
            }
            1 $token L:Token-ty L:token-ty-name IO:write-all IO:check
            $token L:Token-location "expected function memory or import" U:abort-with-location
            break
        }
    }
}
fn Parser-parse-struc(self: .Parser) -> .AST:Struct {
    local token: .L:Token
    local fields: .AST:Fields
    local ident: .L:Token
    AST:Fields-new #fields
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected struct" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_STRUCT /= if {
        $token L:Token-location "expected struct" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected identifier" U:abort
    }
    $self Parser-advance #ident
    $ident L:Token-ty L:TOKEN_IDENT /= if {
        $token L:Token-location "expected identifier" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected {" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
        $token L:Token-location "expected {" U:abort-with-location
    }
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if {
            break
        }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_RIGHT_CURLY = if {
            break
        }
        $token L:Token-ty L:TOKEN_IDENT /= if {
            $token L:Token-location "expected identifier" U:abort-with-location
        }
        $fields
        $token
        $self.current load32 $self.tokens load32 L:Tokens-len = if {
            &self.file S:Str-unpack "expected colon" U:abort
        }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_COLON /= if {
            $token L:Token-location "expected colon" U:abort-with-location
        }
        $self Parser-parse-type
        AST:Field-new AST:Fields-push
    }
    $ident $fields AST:Struct-new
}
fn Parser-parse-imp(self: .Parser) -> .AST:Import {
    local token: .L:Token

    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected import" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_IMPORT /= if {
        $token L:Token-location "expected import" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected string" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_STRING /= if {
        $token L:Token-location "exected string" U:abort-with-location
    }
    $token
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected as" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_AS /= if {
        $token L:Token-location "exected as" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected identifier" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_IDENT /= if {
        $token L:Token-location "exected identifier" U:abort-with-location
    }
    $token
    AST:Import-new
}
fn Parser-parse-ext(self: .Parser) -> .AST:Extern {
    local token: .L:Token
    local module: .L:Token
    local name: .L:Token
    local ident: .L:Token
    local params: .AST:Locals
    local rets: .AST:Types
    $self.tokens load32 L:Tokens-len $self.current load32 = if {
        &self.file S:Str-unpack "expected extern" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_EXTERN /= if {
        $token L:Token-location "expected extern" U:abort-with-location
    }
    $self.tokens load32 L:Tokens-len $self.current load32 = if {
        &self.file S:Str-unpack "expected string" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_STRING /= if {
        $token L:Token-location "expected string" U:abort-with-location
    }
    $token #module
    $self.tokens load32 L:Tokens-len $self.current load32 = if {
        &self.file S:Str-unpack "expected string" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_STRING /= if {
        $token L:Token-location "expected string" U:abort-with-location
    }
    $token #name
    $module
    $name
    $self Parser-parse-signature #rets #params drop #ident
    $ident
    $params
    $rets
    AST:Extern-new
}
fn Parser-parse-loc(self: .Parser) -> .AST:Local {
    local token: .L:Token
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected local" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LOCAL /= if {
        $token L:Token-location "expected local" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected identifier" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_IDENT /= if {
        $token L:Token-location "expected identifier" U:abort-with-location
    }
    $token
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected colon" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_COLON /= if {
        $token L:Token-location "expected colon" U:abort-with-location
    }
    $self Parser-parse-type
    AST:Local-new
}
fn Parser-parse-mem(self: .Parser) -> .AST:Memory {
    local token: .L:Token
    local ident: .L:Token
    local type: .AST:Type
    $self.tokens load32 L:Tokens-len $self.current load32 = if {
        &self.file S:Str-unpack "expected memory found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_MEMORY /= if {
        $token L:Token-location "expected memory" U:abort-with-location
    }
    $self.tokens load32 L:Tokens-len $self.current load32 = if {
        &self.file S:Str-unpack "expected identifier found EOF" U:abort
    }
    $self Parser-advance #ident
    $ident L:Token-ty L:TOKEN_IDENT /= if {
        $ident L:Token-location "expected identifier" U:abort-with-location
    }
    $self.tokens load32 L:Tokens-len $self.current load32 = if {
        &self.file S:Str-unpack "expected colon found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_COLON /= if {
        $token L:Token-location "expected colon" U:abort-with-location
    }
    $self Parser-parse-type #type
    $ident
    $type
    $self Parser-parse-number
    $self.current load32 $self.tokens load32 L:Tokens-len /= if {
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_NUMBER = if {
            $self Parser-parse-number
        } else {
            1
        }
    } else {
        1
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected semicolon found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_SEMICOLON /= if {
        $token L:Token-location "expected semicolon" U:abort-with-location
    }
    AST:Memory-new
}
fn Parser-parse-body(self: .Parser) -> .AST:Locals, .AST:Memories, .AST:Words {
    local token: .L:Token
    local mems: .AST:Memories
    local locals: .AST:Locals
    AST:Memories-new #mems
    AST:Locals-new #locals
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_MEMORY /= if { break }
        $mems $self Parser-parse-mem AST:Memories-push
    }
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_LOCAL /= if { break }
        $locals $self Parser-parse-loc AST:Locals-push
    }
    $locals $mems 
    $self Parser-parse-words
}
fn Parser-parse-words(self: .Parser) -> .AST:Words {
    local words: .AST:Words
    local token: .L:Token
    AST:Words-new #words
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if { break }
        $self Parser-peek #token

        $token is-start-of-word not if { break }
        $words $self Parser-parse-word AST:Words-push
    }
    $words
}

fn Parser-parse-signature(self: .Parser) -> .L:Token, .L:Token, .AST:Locals, .AST:Types {
    local ident: .L:Token
    local qualifier: .L:Token
    local token: .L:Token
    local parameters: .AST:Locals
    local ret: .AST:Types
    local body: .AST:Words
    $self.current load32 $self.tokens load32 L:Tokens-len = if { 
        &self.file S:Str-unpack "expected fn found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_FN /= if {
        $token L:Token-location "expected fn" U:abort-with-location
    }
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if { 
            &self.file S:Str-unpack "expected identifier found EOF" U:abort
        }
        $self Parser-advance #ident
        $ident L:Token-ty L:TOKEN_IDENT /= if {
            $ident L:Token-location "expected identifier" U:abort-with-location
        }
        $self.current load32 $self.tokens load32 L:Tokens-len = if { 
            &self.file S:Str-unpack "expected string or ( found EOF" U:abort
        }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_STRING /= 
        $token L:Token-ty L:TOKEN_LEFT_PAREN /= 
        and if {
            $ident L:Token-location "expected string or (" U:abort-with-location
        }
        $token L:Token-ty L:TOKEN_STRING = if {
            $token #qualifier
            $self.current load32 $self.tokens load32 L:Tokens-len = if { 
                &self.file S:Str-unpack "expected string or ( found EOF" U:abort
            }
            $self Parser-advance #token
        }
        $self Parser-parse-parameters #parameters
        $self.current load32 $self.tokens load32 L:Tokens-len = if {
            &self.file S:Str-unpack "expected ) found EOF" U:abort
        }
        $self Parser-advance #token
        $token L:Token-ty L:TOKEN_RIGHT_PAREN /= if {
            $token L:Token-location "expected )" U:abort-with-location
        }
        $self.current load32 $self.tokens load32 L:Tokens-len < if {
            $self Parser-peek L:Token-ty L:TOKEN_ARROW = if {
                $self Parser-advance drop
                0 0 =
            } else {
                0 1 =
            }
        } else {
            0 1 =
        } if {
            $self Parser-parse-return-types #ret
        } else {
            AST:Types-new #ret
        }
        
        $ident
        $qualifier
        $parameters
        $ret
        break
    }
}
fn Parser-parse-function(self: .Parser) -> .AST:Function {
    local ident: .L:Token
    local qualifier: .L:Token
    local token: .L:Token
    local parameters: .AST:Locals
    local ret: .AST:Types
    local body: .AST:Words
    local mems: .AST:Memories
    local locals: .AST:Locals

    $self Parser-parse-signature #ret #parameters #qualifier #ident
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected { found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
        $token L:Token-location "expected {" U:abort-with-location
    }
    $self Parser-parse-body #body #mems #locals
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected } found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_RIGHT_CURLY /= if {
        $token L:Token-location "expected }" U:abort-with-location
    }
    $ident
    $qualifier
    $parameters
    $ret
    $mems
    $locals
    $body
    AST:Function-new
}
fn Parser-parse-return-types(self: .Parser) -> .AST:Types {
    local token: .L:Token
    local rets: .AST:Types
    AST:Types-new #rets
    $rets $self Parser-parse-type AST:Types-push
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if {
            &self.file S:Str-unpack "expected , or { found EOF" U:abort
        }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_COMMA /= if {
            break
        }
        $self Parser-advance drop
        $rets $self Parser-parse-type AST:Types-push
    }
    $rets
}
fn Parser-parse-parameters(self: .Parser) -> .AST:Locals {
    local params: .AST:Locals
    local token: .L:Token
    AST:Locals-new #params
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected ( found EOF" U:abort 
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_LEFT_PAREN /= if {
        $token L:Token-location "expected (" U:abort-with-location
    }
    loop {
        $self.current load32 $self.tokens load32 L:Tokens-len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_RIGHT_PAREN = if { break }
        $params $self Parser-parse-parameter AST:Locals-push
        $self.current load32 $self.tokens load32 L:Tokens-len = if { break }
        $self Parser-peek #token
        $token L:Token-ty L:TOKEN_COMMA /= if {
            break
        }
        $self Parser-advance drop
    }
    $params
}
fn Parser-parse-parameter(self: .Parser) -> .AST:Local {
    local ident: .L:Token
    local token: .L:Token
    $self.current load32 $self.tokens load32 L:Tokens-len = if { 
        &self.file S:Str-unpack "expected identifier found EOF" U:abort
    }
    $self Parser-advance #ident
    $ident L:Token-ty L:TOKEN_IDENT /= if {
        $ident L:Token-location "expected identifier" U:abort-with-location
    }
    $self.current load32 $self.tokens load32 L:Tokens-len = if { 
        &self.file S:Str-unpack "expected : found EOF" U:abort
    }
    $self Parser-advance #token
    $token L:Token-ty L:TOKEN_COLON /= if {
        $ident L:Token-location "expected colon" U:abort-with-location
    }
    $ident
    $self Parser-parse-type
    AST:Local-new
}
fn Parser-parse-type(self: .Parser) -> .AST:Type {
    local type: .AST:Type
    $self Parser-parse-type-inner #type
    $self.types load32 $type AST:Types-push
    $type
}
fn Parser-parse-type-inner(self: .Parser) -> .AST:Type {
    local token: .L:Token
    local module: .L:Token
    $self.current load32 $self.tokens load32 L:Tokens-len = if {
        &self.file S:Str-unpack "expected type found EOF" U:abort
    }
    $self Parser-advance #token
    loop {
        $token L:Token-ty L:TOKEN_DOT = if {
            $self Parser-parse-type AST:Type-new-ptr break
        }
        $token L:Token-ty L:TOKEN_I32 = if {
            AST:Type-new-int32 break
        }
        $token L:Token-ty L:TOKEN_I64 = if {
            AST:Type-new-int64 break
        }
        $token L:Token-ty L:TOKEN_BOOL = if {
            AST:Type-new-boolean break
        }
        $token L:Token-ty L:TOKEN_IDENT = if {
            $self.current load32 $self.tokens load32 L:Tokens-len < if {
                $self Parser-peek L:Token-ty L:TOKEN_COLON = if {
                    $self Parser-advance drop
                    $self.current load32 $self.tokens load32 L:Tokens-len = if {
                        &self.file S:Str-unpack "expected identifier" U:abort
                    }
                    $token #module
                    $self Parser-advance #token
                    $token L:Token-ty L:TOKEN_IDENT /= if {
                        $token L:Token-location "expected identifier" U:abort-with-location
                    }
                    $module $token AST:Type-new-struc break
                }
            }
            0 !.L:Token $token AST:Type-new-struc break
        }
        $token L:Token-location "expected type" U:abort-with-location
    }
}
fn Parser-parse-intrinsic(self: .Parser, token: .L:Token) -> .AST:Word, bool {
    local file: S:Str
    local line: i32
    local column: i32
    local word: .AST:Word
    ?token L:Token-file ~ @file
    ?token L:Token-line @line
    ?token L:Token-column @column
    loop {
        $token L:Token-lexeme S:Str-unpack "drop" S:str-eq if {
            AST:WORD_INTRINSIC ?file ?line ?column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_DROP store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "flip" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_FLIP store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "+" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_ADD store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "<" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_LESS store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack ">" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_GREATER store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "=" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_EQ store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack ">=" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_GREATER_EQ store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "<=" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_LESS_EQ store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "not" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_NOT store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "mem-grow" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_MEM_GROW store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "store32" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_STORE32 store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "load32" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_LOAD32 store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "-" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_SUB store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "and" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_AND store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "store8" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_STORE8 store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "load8" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_LOAD8 store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "%" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_MOD store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "/" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_DIV store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "/=" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_NOT_EQ store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "*" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_MUL store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "mem-copy" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_MEM_COPY store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "rotl" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_ROTL store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "rotr" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_ROTR store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "or" S:str-eq if {
            AST:WORD_INTRINSIC $file $line $column AST:Word-new #word
            $word.intrinsic AST:INTRINSIC_OR store32
            $word 0 0 = break
        }
        $token L:Token-lexeme S:Str-unpack "sizeof" S:str-eq if {
            AST:WORD_SIZEOF $file $line $column AST:Word-new #word
            $self.current load32 $self.tokens load32 L:Tokens-len = if {
                &self.file S:Str-unpack "Expected ( found EOF" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_LEFT_PAREN /= if  {
                $token L:Token-location "expected (" U:abort-with-location
            }
            $self.current load32 $self.tokens load32 L:Tokens-len = if {
                &self.file S:Str-unpack "Expected identifier found EOF" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_IDENT /= if {
                $token L:Token-location "expected identifier" U:abort-with-location
            }
            $word.ident $token L:Token-lexeme store32
            $self.current load32 $self.tokens load32 L:Tokens-len = if {
                &self.file S:Str-unpack "Expected ) found EOF" U:abort
            }
            $self Parser-advance #token
            $token L:Token-ty L:TOKEN_RIGHT_PAREN /= if {
                $token L:Token-location "expected )" U:abort-with-location
            }
            $word 0 0 = break
        }
        0 !.AST:Word 0 1 = break
    }
}
fn Parser-parse-word(self: .Parser) -> .AST:Word {
    local token: .L:Token
    local ty: i32
    local file: S:Str
    local line: i32
    local column: i32
    local word: .AST:Word
    ?self.current ?self.tokens L:Tokens-len = if { 
        &self.file S:Str-unpack "Expected word found EOF" U:abort
    }
    ?self Parser-advance @token
    ?token L:Token-ty @ty
    ?token L:Token-file ~ @file
    ?token L:Token-line @line
    ?token L:Token-column @column
    loop {
        ?ty L:TOKEN_IDENT = if {
            ?self ?token Parser-parse-intrinsic if {
                break
            } else { drop }
            AST:WORD_CALL ?file ?line ?column AST:Word-new @word
            ?self.current ?self.tokens L:Tokens-len < if {
                ?self Parser-peek L:Token-ty L:TOKEN_COLON = if {
                    ?self Parser-advance drop
                    ?self.current ?self.tokens L:Tokens-len = if { 
                        &self.file S:Str-unpack "Expected ident found EOF" U:abort
                    }
                    ?token L:Token-lexeme @word.qualifier
                    ?self Parser-advance @token
                    ?token L:Token-ty L:TOKEN_IDENT /= if {
                        ?token L:Token-location "expected ident" U:abort-with-location
                    }
                    ?token L:Token-lexeme @word.ident
                    ?word break
                }
            }
            ?token L:Token-lexeme @word.ident
            ?word break
        }
        ?ty L:TOKEN_NUMBER = if {
            AST:WORD_NUMBER ?file ?line ?column AST:Word-new @word
            ?token.number @word.number
            ?word break
        }
        ?ty L:TOKEN_STRING = if {
            AST:WORD_STRING ?file ?line ?column AST:Word-new @word

            ?token.string S:String-len @word.size
            ?self.mem S2:String-unpack 
            ?token.string S:String-unpack
            S:str-find-str if {
                @word.addr
            } else {
                drop
                ?self.mem S2:String-len @word.addr
                ?self.mem ?token.string S:String-unpack S2:String-append
            }
            ?word break
        }
        ?ty L:TOKEN_BREAK = if {
            AST:WORD_BREAK ?file ?line ?column AST:Word-new break
        }
        ?ty L:TOKEN_DOLLAR = if {
            ?self ?file ?line ?column Parser-parse-get-locl break
        }
        ?ty L:TOKEN_HASH = if {
            AST:WORD_SET ?file ?line ?column AST:Word-new #word
            ?self.current ?self.tokens L:Tokens-len = if {
                &self.file S:Str-unpack "Expected identifier found EOF" U:abort
            }
            ?self Parser-advance @token
            ?token L:Token-ty L:TOKEN_IDENT /= if {
                ?token L:Token-location "expected identifier" U:abort-with-location
            }
            ?token L:Token-lexeme @word.ident
            ?word break
        }
        ?ty L:TOKEN_IF = if {
            AST:WORD_IF ?file ?line ?column AST:Word-new @word
            ?self Parser-parse-iff @word.iff
            ?word break
        }
        ?ty L:TOKEN_BANG = if {
            AST:WORD_CAST ?file ?line ?column AST:Word-new @word
            ?self Parser-parse-type @word.type
            ?word break
        }
        ?ty L:TOKEN_LOOP = if {
            AST:WORD_LOOP ?file ?line ?column AST:Word-new @word
            ?self Parser-parse-lop @word.lop
            ?word break
        }
        ?ty L:TOKEN_DOT = if {
            AST:WORD_DEREF ?file ?line ?column AST:Word-new @word
            ?self.current ?self.tokens L:Tokens-len = if {
                &self.file S:Str-unpack "Expected identifier found EOF" U:abort
            }
            ?self Parser-advance @token
            ?token L:Token-ty L:TOKEN_IDENT /= if {
                ?token L:Token-location "expected identifier" U:abort-with-location
            }
            ?token L:Token-lexeme @word.ident
            ?word break
        }
        ?ty L:TOKEN_AT = if {
            ?self ?file ?line ?column Parser-parse-struc-set break
        }
        ?ty L:TOKEN_AMPERSAND = if {
            ?self ?file ?line ?column Parser-parse-get-ref break
        }
        ?ty L:TOKEN_QUESTION = if {
            ?self ?file ?line ?column Parser-parse-get-locl2 break
        }
        ?ty L:TOKEN_TILDE = if {
            AST:WORD_LOAD ?file ?line ?column AST:Word-new break
        }
        ?ty L:TOKEN_RIGHT_RIGHT = if {
            ?self ?file ?line ?column Parser-parse-store break
        }
        2 "Unexpected Token: " IO:write-all IO:check
        2 ?ty L:token-ty-name IO:write-all IO:check
        2 "\n" IO:write-all IO:check
        1 CORE:exit
        0 !.AST:Word break
    }
}
fn Parser-parse-get-locl(self: .Parser, file: S:Str, line: i32, column: i32) -> .AST:Word {
    local word: .AST:Word
    local token: .L:Token
    AST:WORD_LOCAL ?file ?line ?column AST:Word-new @word
    ?self.current ?self.tokens L:Tokens-len = if {
        &file S:Str-unpack "expected identifier found EOF" U:abort
    }
    ?self Parser-advance @token
    ?self.current ?self.tokens L:Tokens-len = if {
        &file S:Str-unpack ?line ?column "expected identifier" U:abort-with-location
    }
    ?token L:Token-lexeme @word.ident
    ?word 
}
fn Parser-parse-get-locl2(self: .Parser, file: S:Str, line: i32, column: i32) -> .AST:Word {
    local word: .AST:Word
    local token: .L:Token
    AST:WORD_LOCAL2 ?file ?line ?column AST:Word-new @word
    ?self.current ?self.tokens L:Tokens-len = if {
        &file S:Str-unpack "expected identifier found EOF" U:abort
    }
    ?self Parser-advance @token
    ?self.current ?self.tokens L:Tokens-len = if {
        &file S:Str-unpack ?line ?column "expected identifier" U:abort-with-location
    }
    ?token L:Token-lexeme @word.ident
    L:Tokens-new @word.fields
    loop {
        ?self.current ?self.tokens L:Tokens-len = if { break }
        ?self Parser-peek @token
        ?token L:Token-ty L:TOKEN_DOT /= if { break }
        ?self Parser-advance @token
        ?self.current ?self.tokens L:Tokens-len = if {
            &file S:Str-unpack "expected identifier found EOF" U:abort
        }
        ?self Parser-advance @token
        ?token L:Token-ty L:TOKEN_IDENT /= if {
            ?token L:Token-location "expected identifier" U:abort-with-location
        }
        &word.fields ?token L:Tokens-push
    }
    ?word
}
fn Parser-parse-fields-access(self: .Parser, file: S:Str, line: i32, column: i32) -> L:Tokens, .S:Str {
    local token: .L:Token
    local fields: L:Tokens
    local ident: .L:Token
    ?self.current ?self.tokens L:Tokens-len = if {
        &file S:Str-unpack "expected identifier found EOF" U:abort
    }
    ?self Parser-advance @ident
    ?ident L:Token-ty L:TOKEN_IDENT /= if {
        ?ident L:Token-location "expected identifier" U:abort-with-location
    }
    L:Tokens-new @fields
    loop {
        ?self.current ?self.tokens L:Tokens-len = if { break }
        ?self Parser-peek @token
        ?token L:Token-ty L:TOKEN_DOT /= if { break }
        ?self Parser-advance @token
        ?self.current ?self.tokens L:Tokens-len = if {
            &file S:Str-unpack "expected identifier found EOF" U:abort
        }
        ?self Parser-advance @token
        ?token L:Token-ty L:TOKEN_IDENT /= if {
            ?token L:Token-location "expected identifier" U:abort-with-location
        }
        &fields ?token L:Tokens-push
    }
    ?fields ?ident L:Token-lexeme
}
fn Parser-parse-get-ref(self: .Parser, file: S:Str, line: i32, column: i32) -> .AST:Word {
    local word: .AST:Word
    AST:WORD_GET_REF ?file ?line ?column AST:Word-new @word
    ?self ?file ?line ?column Parser-parse-fields-access 
    @word.ident
    @word.fields
    ?word
}
fn Parser-parse-store(self: .Parser, file: S:Str, line: i32, column: i32) -> .AST:Word {
    local word: .AST:Word
    AST:WORD_STORE ?file ?line ?column AST:Word-new @word
    ?self ?file ?line ?column Parser-parse-fields-access 
    @word.ident
    @word.fields
    ?word
}
fn Parser-parse-struc-set(self: .Parser, file: S:Str, line: i32, column: i32) -> .AST:Word {
    local token: .L:Token
    local word: .AST:Word
    AST:WORD_STRUCT_SET ?file ?line ?column AST:Word-new @word
    ?self.current ?self.tokens L:Tokens-len = if {
        &self.file S:Str-unpack "Expected identifier found EOF" U:abort
    }
    ?self Parser-advance @token
    ?token L:Token-ty L:TOKEN_IDENT /= if {
        ?token L:Token-location "expected identifier" U:abort-with-location
    }
    ?token L:Token-lexeme @word.ident
    L:Tokens-new @word.fields
    loop {
        ?self.current ?self.tokens L:Tokens-len = if { break }
        ?self Parser-peek @token
        ?token L:Token-ty L:TOKEN_DOT /= if { break }
        ?self Parser-advance @token
        ?self.current ?self.tokens L:Tokens-len = if { 
            &file S:Str-unpack "expected identifier found EOF" U:abort
        }
        ?self Parser-advance @token
        ?token L:Token-ty L:TOKEN_IDENT /= if {
            ?token L:Token-location "expected identifier" U:abort-with-location
        }
        &word.fields ?token L:Tokens-push
    }
    ?word
}
fn Parser-parse-lop(self: .Parser) -> .AST:Words {
    local token: .L:Token
    ?self.current 1 - @self.current
    ?self.current ?self.tokens L:Tokens-len = if {
        &self.file S:Str-unpack "expected loop" U:abort
    }
    ?self Parser-advance @token
    ?token L:Token-ty L:TOKEN_LOOP /= if {
        ?token L:Token-location "expected loop" U:abort-with-location
    }

    ?self.current ?self.tokens L:Tokens-len = if {
        &self.file S:Str-unpack "expected {" U:abort
    }
    ?self Parser-advance @token
    ?token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
        ?token L:Token-location "expected {" U:abort-with-location
    }
    ?self Parser-parse-words
    ?self.current ?self.tokens L:Tokens-len = if {
        &self.file S:Str-unpack "expected }" U:abort
    }
    ?self Parser-advance @token
    ?token L:Token-ty L:TOKEN_RIGHT_CURLY /= if {
        ?token L:Token-location "expected }" U:abort-with-location
    }
}
fn Parser-parse-iff(self: .Parser) -> .AST:If {
    local token: .L:Token
    ?self.current 1 - @self.current
    ?self.current ?self.tokens L:Tokens-len = if {
        &self.file S:Str-unpack "exected if" U:abort
    }
    ?self Parser-advance @token
    ?token L:Token-ty L:TOKEN_IF /= if {
        ?token L:Token-location "exected if" U:abort-with-location
    }
    ?token
    ?self.current ?self.tokens L:Tokens-len = if {
        &self.file S:Str-unpack "exected {" U:abort
    }
    ?self Parser-advance @token
    ?token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
        ?token L:Token-location "expected {" U:abort-with-location
    }
    ?self Parser-parse-words
    ?self.current ?self.tokens L:Tokens-len = if {
        &self.file S:Str-unpack "exected }" U:abort
    }
    ?self Parser-advance @token
    ?token L:Token-ty L:TOKEN_RIGHT_CURLY /= if {
        ?token L:Token-location "expected }" U:abort-with-location
    }
    ?self.current ?self.tokens L:Tokens-len < if {
        ?self Parser-peek @token
        ?token L:Token-ty L:TOKEN_ELSE = if {
            ?self Parser-advance drop
            ?self.current ?self.tokens L:Tokens-len = if {
                &self.file S:Str-unpack "expected {" U:abort
            }
            ?self Parser-advance @token
            ?token L:Token-ty L:TOKEN_LEFT_CURLY /= if {
                ?token L:Token-location "expected {" U:abort-with-location
            }
            ?self Parser-parse-words
            ?self.current ?self.tokens L:Tokens-len = if {
                &self.file S:Str-unpack "expected }" U:abort
            }
            ?self Parser-advance @token
            ?token L:Token-ty L:TOKEN_RIGHT_CURLY /= if {
                ?token L:Token-location "expected }" U:abort-with-location
            }
        } else {
            0 !.AST:Words
        }
    } else {
        0 !.AST:Words
    }
    AST:If-new
}
fn Parser-parse-number(self: .Parser) -> i32 {
    local token: .L:Token
    ?self.current ?self.tokens L:Tokens-len = if { 
        &self.file S:Str-unpack "expected number found EOF" U:abort
    }
    ?self Parser-advance @token
    ?token L:Token-ty L:TOKEN_NUMBER /= if {
        ?token L:Token-location "expected number" U:abort-with-location
    }
    ?token.number
}
fn is-start-of-word(token: .L:Token) -> bool {
    local ty: i32
    $token L:Token-ty #ty
    $ty L:TOKEN_IDENT = 
    $ty L:TOKEN_DOLLAR = or
    $ty L:TOKEN_NUMBER = or
    $ty L:TOKEN_IF = or
    $ty L:TOKEN_LOOP = or
    $ty L:TOKEN_BREAK = or
    $ty L:TOKEN_HASH = or
    $ty L:TOKEN_STRING = or
    $ty L:TOKEN_BANG = or
    $ty L:TOKEN_DOT = or
    $ty L:TOKEN_AMPERSAND = or
    $ty L:TOKEN_AT = or
    $ty L:TOKEN_QUESTION = or
    $ty L:TOKEN_TILDE = or
    $ty L:TOKEN_RIGHT_RIGHT = or
}

fn parse(mem: .S2:String, tokens: .L:Tokens) -> .AST:TopItems, .AST:Types {
    local parser: Parser
    local items: .AST:TopItems
    $tokens ?mem Parser-new @parser
    &parser Parser-parse-module #items
    $items
    ?parser Parser-free
}

