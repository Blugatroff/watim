import "../std/core.watim" as Core (exit)
import "../std/maybe.watim" as Maybe (Maybe, assert-some)
import "../std/result.watim" as Result (Result)
import "../std/io.watim" as IO
import "../std/arena.watim" as Arena (Arena)
import "../std/array.watim" as Array (Array)
import "../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../std/fmt.watim" as Fmt (Formatter)
import "../std/util.watim" as Util (i32-format)

import "./lexer.watim" as Lexer (Token, TokenTy, Token-ty, TokenTy-name, Token-lexeme, Token-format, Token-print, Token-location, Token-column, Token-eq-by-lexeme, Token-string-content)

struct Import {
    start: Token
    path: Token
    qualifier: Token
    items: Array<Token>
}
fn Import-format(fmt: .Formatter, self: .Import) {
    $fmt "(Import " Fmt:write
    $fmt &self.start Token-format
    $fmt " " Fmt:write
    $fmt &self.path Token-format
    $fmt " " Fmt:write
    $fmt &self.qualifier Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.items Array:format<Token>
    $fmt ")" Fmt:write
}

struct ForeignCustomType {
    module: Token
    name: Token
    generic-arguments: Array<Type>
}
fn ForeignCustomType-format(fmt: .Formatter, self: .ForeignCustomType) {
    $fmt "(ForeignCustomType " Fmt:write
    $fmt &self.module Token-format
    $fmt " " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt \Type-format &self.generic-arguments Array:format<Type>
    $fmt ")" Fmt:write
}

struct LocalCustomType {
    name: Token
    generic-arguments: Array<Type>
}
fn LocalCustomType-format(fmt: .Formatter, self: .LocalCustomType) {
    $fmt "(LocalCustomType " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt \Type-format &self.generic-arguments Array:format<Type>
    $fmt ")" Fmt:write
}

variant CustomType {
    case Local -> LocalCustomType
    case Foreign -> ForeignCustomType
}
fn CustomType-format(fmt: .Formatter, self: .CustomType) {
    $fmt $self match {
        case Local -> { LocalCustomType-format }
        case Foreign -> { ForeignCustomType-format }
    }
}

struct PtrType {
    dot: Token
    type: .Type
}

struct FunType {
    token: Token
    parameters: Array<Type>
    returns: Array<Type>
}
fn FunType-format(fmt: .Formatter, self: .FunType) {
    $fmt "(FunType " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \Type-format &self.parameters Array:format<Type>
    $fmt " " Fmt:write
    $fmt \Type-format &self.returns Array:format<Type>
    $fmt ")" Fmt:write
}

struct GenericType {
    name: Token
    index: i32
}
fn GenericType-format(fmt: .Formatter, self: .GenericType) {
    $fmt "(GenericType " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt $self.index i32-format
    $fmt ")" Fmt:write
}
fn GenericType-pretty(fmt: .Formatter, self: .GenericType) {
    $fmt &self.name Token-lexeme Fmt:write
}

struct TupleType {
    token: Token
    items: Array<Type>
}
fn TupleType-format(fmt: .Formatter, self: .TupleType) {
    $fmt "(TupleType " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \Type-format &self.items Array:format<Type>
    $fmt ")" Fmt:write
}

variant Type {
    case Bool -> Token
    case I8 -> Token
    case I32 -> Token
    case I64 -> Token
    case Ptr -> PtrType
    case Custom -> CustomType
    case Fun -> FunType
    case Tuple -> TupleType
    case Generic -> GenericType
    case Hole -> Token
}
fn Type-format(fmt: .Formatter, self: .Type) { block {
    $self match {
        case Bool -> { drop "bool" }
        case I8 -> { drop "I8" }
        case I32 -> { drop "I32" }
        case I64 -> { drop "I64" }
        case Ptr -> { .type $fmt "." Fmt:write ~ $fmt flip Type-format break }
        case Custom -> { $fmt flip CustomType-format break }
        case Fun -> { $fmt flip FunType-format break }
        case Tuple -> { $fmt flip TupleType-format break }
        case Generic -> { $fmt flip GenericType-format break }
        case Hole -> { drop "Hole" }
    } @len @ptr
    $fmt $ptr $len Fmt:write
} }

struct NamedType {
    name: Token
    type: Type
}
fn NamedType-format(fmt: .Formatter, self: .NamedType) {
    $fmt "(NamedType " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

struct LocalCall {
    name: Token
    generic-arguments: Array<Type>
}
fn LocalCall-format(fmt: .Formatter, self: .LocalCall) {
    $fmt "(LocalCall " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt \Type-format &self.generic-arguments Array:format-multi-line<Type>
    $fmt ")" Fmt:write
}

struct ForeignCall {
    module: Token
    name: Token
    generic-arguments: Array<Type>
}
fn ForeignCall-format(fmt: .Formatter, self: .ForeignCall) {
    $fmt "(ForeignCall " Fmt:write
    $fmt &self.module Token-format
    $fmt " " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt \Type-format &self.generic-arguments Array:format-multi-line<Type>
    $fmt ")" Fmt:write
}

struct InitLocal {
    start: Token
    ident: Token
}
fn InitLocal-format(fmt: .Formatter, self: .InitLocal) {
    $fmt "(RefLocal " Fmt:write
    $fmt &self.start Token-format
    $fmt " " Fmt:write
    $fmt &self.ident Token-format
    $fmt ")" Fmt:write
}

struct RefLocal {
    start: Token
    ident: Token
    fields: Array<Token>
}
fn RefLocal-format(fmt: .Formatter, self: .RefLocal) {
    $fmt "(RefLocal " Fmt:write
    $fmt &self.start Token-format
    $fmt " " Fmt:write
    $fmt &self.ident Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.fields Array:format<Token>
    $fmt ")" Fmt:write
}

struct GetLocal {
    start: Token
    ident: Token
    fields: Array<Token>
}
fn GetLocal-format(fmt: .Formatter, self: .GetLocal) {
    $fmt "(GetLocal " Fmt:write
    $fmt &self.start Token-format
    $fmt " " Fmt:write
    $fmt &self.ident Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.fields Array:format<Token>
    $fmt ")" Fmt:write
}

struct SetLocal {
    start: Token
    ident: Token
    fields: Array<Token>
}
fn SetLocal-format(fmt: .Formatter, self: .SetLocal) {
    $fmt "(SetLocal " Fmt:write
    $fmt &self.start Token-format
    $fmt " " Fmt:write
    $fmt &self.ident Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.fields Array:format<Token>
    $fmt ")" Fmt:write
}

struct Words {
    words: Array<Word>
    end: Token
}
fn Words-format(fmt: .Formatter, self: .Words) {
    $fmt "(Words " Fmt:write
    $fmt \Word-format &self.words Array:format-multi-line<Word>
    $fmt " " Fmt:write
    $fmt &self.end Token-format
    $fmt ")" Fmt:write
}

struct If {
    token: Token
    true-words: Words
    false-words: Maybe<Words>
}
fn If-format(fmt: .Formatter, self: .If) {
    $fmt "(If " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.true-words Words-format
    $fmt " " Fmt:write
    $fmt \Words-format &self.false-words Maybe:format<Words>
    $fmt ")" Fmt:write
}

struct BlockAnnotation {
    parameters: Array<Type>
    returns: Array<Type>
}
fn BlockAnnotation-format(fmt: .Formatter, self: .BlockAnnotation) {
    $fmt "(BlockAnnotation " Fmt:write
    $fmt \Type-format &self.parameters Array:format<Type>
    $fmt " " Fmt:write
    $fmt \Type-format &self.returns Array:format<Type>
    $fmt ")" Fmt:write
}

struct Block {
    token: Token
    annotation: Maybe<BlockAnnotation>
    words: Words
}
fn Block-format(fmt: .Formatter, self: .Block) {
    $fmt "(Block " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \BlockAnnotation-format &self.annotation Maybe:format<BlockAnnotation>
    $fmt " " Fmt:write
    $fmt &self.words Words-format
    $fmt ")" Fmt:write
}

struct Loop {
    token: Token
    annotation: Maybe<BlockAnnotation>
    words: Words
}
fn Loop-format(fmt: .Formatter, self: .Loop) {
    $fmt "(Loop " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \BlockAnnotation-format &self.annotation Maybe:format<BlockAnnotation>
    $fmt " " Fmt:write
    $fmt &self.words Words-format
    $fmt ")" Fmt:write
}

struct Cast {
    token: Token
    type: Type
}
fn Cast-format(fmt: .Formatter, self: .Cast) {
    $fmt "(Cast " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

struct MakeStruct {
    token: Token
    type: CustomType
}
fn MakeStruct-format(fmt: .Formatter, self: .MakeStruct) {
    $fmt "(MakeStruct " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type CustomType-format
    $fmt ")" Fmt:write
}

struct MakeStructNamed {
    token: Token
    type: CustomType
    body: Words
}
fn MakeStructNamed-format(fmt: .Formatter, self: .MakeStructNamed) {
    $fmt "(MakeStructNamed " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type CustomType-format
    $fmt " " Fmt:write
    $fmt \Word-format &self.body.words Array:format-multi-line<Word>
    $fmt ")" Fmt:write
}

struct MakeVariant {
    token: Token
    type: CustomType
    cays: Token
}
fn MakeVariant-format(fmt: .Formatter, self: .MakeVariant) {
    $fmt "(MakeVariant " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type CustomType-format
    $fmt " " Fmt:write
    $fmt &self.cays Token-format
    $fmt ")" Fmt:write
}

variant Call {
    case Local -> LocalCall
    case Foreign -> ForeignCall
}
fn Call-format(fmt: .Formatter, self: .Call) {
    $self match {
        case Local -> { $fmt flip LocalCall-format }
        case Foreign -> { $fmt flip ForeignCall-format }
    }
}

struct FunRef {
    start: Token
    function: Call
}
fn FunRef-format(fmt: .Formatter, self: .FunRef) {
    $fmt "(FunRef " Fmt:write
    $fmt &self.start Token-format
    $fmt " " Fmt:write
    $fmt &self.function Call-format
    $fmt ")" Fmt:write
}

struct MatchCase {
    token: Token
    name: Token
    body: Words
}
fn MatchCase-format(fmt: .Formatter, self: .MatchCase) {
    $fmt "(MatchCase " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.body Words-format
    $fmt ")" Fmt:write
}

struct Match {
    token: Token
    cases: Array<MatchCase>
    default: Maybe<MatchCase>
    end: Token
}
fn Match-format(fmt: .Formatter, self: .Match) {
    $fmt "(Match " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \MatchCase-format &self.cases Array:format-multi-line<MatchCase>
    $fmt " " Fmt:write
    $fmt &self.end Token-format
    $fmt ")" Fmt:write
}

struct GetField {
    token: Token
    fields: Array<Token>
}
fn GetField-format(fmt: .Formatter, self: .GetField) {
    $fmt "(GetField " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.fields Array:format<Token>
    $fmt ")" Fmt:write
}

struct Store {
    start: Token
    name: Token
    fields: Array<Token>
}
fn Store-format(fmt: .Formatter, self: .Store) {
    $fmt "(Store " Fmt:write
    $fmt &self.start Token-format
    $fmt " " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.fields Array:format<Token>
    $fmt ")" Fmt:write
}

struct Sizeof {
    token: Token
    type: Type
}
fn Sizeof-format(fmt: .Formatter, self: .Sizeof) {
    $fmt "(Sizeof " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

struct MakeTuple {
    token: Token
    items: Token
}
fn MakeTuple-format(fmt: .Formatter, self: .MakeTuple) {
    $fmt "(MakeTuple " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.items Token-format
    $fmt ")" Fmt:write
}

struct StringWord {
    token: Token
    data: ByteSlice
}
fn StringWord-format(fmt: .Formatter, self: .StringWord) {
    $fmt "(StringWord " Fmt:write
    $fmt &self.token Token-format
    $fmt ")" Fmt:write
}

struct StackAnnotation {
    token: Token
    types: Array<Type>
}
fn StackAnnotation-format(fmt: .Formatter, self: .StackAnnotation) {
    $fmt "(StackAnnotation " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \Type-format &self.types Array:format<Type>
    $fmt ")" Fmt:write
}

variant Word {
    case Call -> Call
    case String -> StringWord
    case InitLocal -> InitLocal
    case RefLocal -> RefLocal
    case GetLocal -> GetLocal
    case SetLocal -> SetLocal
    case Ref -> Token
    case Number -> Token
    case If -> If
    case Block -> Block
    case Load -> Token
    case Cast -> Cast
    case Break -> Token
    case Loop -> Loop
    case MakeStruct -> MakeStruct
    case MakeStructNamed -> MakeStructNamed
    case MakeVariant -> MakeVariant
    case FunRef -> FunRef
    case Match -> Match
    case GetField -> GetField
    case Sizeof -> Sizeof
    case IndirectCall -> Token
    case Store -> Store
    case MakeTuple -> MakeTuple
    case UnpackTuple -> Token
    case StackAnnotation -> StackAnnotation
}
fn Word-format(fmt: .Formatter, self: .Word) { block {
    $self match {
        case Call -> { $fmt flip Call-format break }
        case String -> { $fmt flip StringWord-format break }
        case InitLocal -> { $fmt flip InitLocal-format break }
        case RefLocal -> { $fmt flip RefLocal-format break }
        case GetLocal -> { $fmt flip GetLocal-format break }
        case SetLocal -> { $fmt flip SetLocal-format break }
        case Ref -> { "Ref" }
        case Number -> { "Number" }
        case If -> { $fmt flip If-format break }
        case Block -> { $fmt flip Block-format break }
        case Load -> { "Load" }
        case Cast -> { $fmt flip Cast-format break }
        case Break -> { "Break" }
        case Loop -> { $fmt flip Loop-format break }
        case MakeStruct -> { $fmt flip MakeStruct-format break }
        case MakeStructNamed -> { $fmt flip MakeStructNamed-format break }
        case MakeVariant -> { $fmt flip MakeVariant-format break }
        case FunRef -> { $fmt flip FunRef-format break }
        case Match -> { $fmt flip Match-format break }
        case GetField -> { $fmt flip GetField-format break }
        case Sizeof -> { $fmt flip Sizeof-format break }
        case Store -> { $fmt flip Store-format break }
        case IndirectCall -> { "IndirectCall" }
        case MakeTuple -> { $fmt flip MakeTuple-format break }
        case UnpackTuple -> { "UnpackTuple" }
        case StackAnnotation -> { $fmt flip StackAnnotation-format break }
    } @name-len @name-ptr
    $fmt "(" Fmt:write
    $fmt $name-ptr $name-len Fmt:write
    $fmt " " Fmt:write
    $fmt flip Token-format
    $fmt ")" Fmt:write
} }

struct Signature {
    generic-parameters: Array<Token>
    parameters: Array<NamedType>
    returns: Array<Type>
}
fn Signature-format(fmt: .Formatter, self: .Signature) {
    $fmt "(Signature " Fmt:write
    $fmt \Token-format &self.generic-parameters Array:format<Token>
    $fmt " " Fmt:write
    $fmt \NamedType-format &self.parameters Array:format<NamedType>
    $fmt " " Fmt:write
    $fmt \Type-format &self.returns Array:format<Type>
    $fmt ")" Fmt:write
}

struct Function {
    start: Token
    name: Token
    export: Maybe<Token>
    signature: Signature
    body: Words
}
fn Function-format(fmt: .Formatter, self: .Function) {
    $fmt "(Function " Fmt:write
    $fmt &self.start Token-format
    $fmt " " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    &self.export match {
        case None -> { }
        case Some -> {
            $fmt flip Token-format
            $fmt " " Fmt:write
        }
    }
    $fmt &self.signature Signature-format
    $fmt " " Fmt:write
    $fmt \Word-format &self.body.words Array:format-multi-line<Word>
    $fmt ")" Fmt:write
}

struct Struct {
    start: Token
    name: Token
    generic-parameters: Array<Token>
    fields: Array<NamedType>
    end: Token
}
fn Struct-format(fmt: .Formatter, self: .Struct) {
    $fmt "(Struct " Fmt:write
    $fmt &self.start Token-format
    $fmt " " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.generic-parameters Array:format<Token>
    $fmt " " Fmt:write
    $fmt \NamedType-format &self.fields Array:format-multi-line<NamedType>
    $fmt ")" Fmt:write
}

struct VariantCase {
    token: Token
    name: Token
    type: Maybe<Type>
}
fn VariantCase-format(fmt: .Formatter, self: .VariantCase) {
    $fmt "(VariantCase " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt \Type-format &self.type Maybe:format<Type>
    $fmt ")" Fmt:write
}

struct Variant {
    start: Token
    name: Token
    generic-parameters: Array<Token>
    cases: Array<VariantCase>
    end: Token
}
fn Variant-format(fmt: .Formatter, self: .Variant) {
    $fmt "(Variant " Fmt:write
    $fmt &self.start Token-format
    $fmt " " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.generic-parameters Array:format<Token>
    $fmt " " Fmt:write
    $fmt \VariantCase-format &self.cases Array:format-multi-line<VariantCase>
    $fmt ")" Fmt:write
}

struct Extern {
    token: Token
    extrn-module: Token
    extrn-name: Token
    name: Token
    signature: Signature
}
fn Extern-format(fmt: .Formatter, self: .Extern) {
    $fmt "(Extern " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.extrn-module Token-format
    $fmt " " Fmt:write
    $fmt &self.extrn-name Token-format
    $fmt " " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.signature Signature-format
    $fmt ")" Fmt:write
}

struct Global {
    token: Token
    name: Token
    type: Type
}
fn Global-format(fmt: .Formatter, self: .Global) {
    $fmt "(Global " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

variant TopItem {
    case Import -> Import
    case Extern -> Extern
    case Function -> Function
    case Struct -> Struct
    case Variant -> Variant
    case Global -> Global
}
fn TopItem-format(fmt: .Formatter, self: .TopItem) {
    $fmt $self match {
        case Import -> { Import-format }
        case Extern -> { Extern-format }
        case Function -> { Function-format }
        case Struct -> { Struct-format }
        case Variant -> { Variant-format }
        case Global -> { Global-format }
    }
}

struct Parser {
    arena: .Arena
    tokens: Array<Token>
    cursor: i32
    generic-parameters: Array<Token>
}
fn eof(parser: .Parser) -> bool {
    $parser.cursor $parser.tokens.len ge
}
fn peek-immediate(parser: .Parser) -> Maybe<.Token> {
    $parser.cursor $parser.tokens.len = if {
        make Maybe<.Token>.None
    } else {
        &parser.tokens $parser.cursor Array:get<Token> make Maybe<.Token>.Some
    }
}
fn peek(parser: .Parser) -> Maybe<.Token> {
    $parser.cursor @i
    loop {
        $parser.tokens.len $i = if { make Maybe<.Token>.None break }
        &parser.tokens $i Array:get<Token> @token
        $i 1 + #i
        $token Token-ty match {
            case TOKEN_SPACE -> {}
            case _ -> { drop $token make Maybe<.Token>.Some break }
        }
    }
}
fn advance-immediate(parser: .Parser) -> Maybe<.Token> {
    $parser.cursor $parser.tokens.len = if {
        make Maybe<.Token>.None
    } else {
        &parser.tokens $parser.cursor Array:get<Token> make Maybe<.Token>.Some
        $parser.cursor 1 + #parser.cursor
    }
}
fn advance(parser: .Parser) -> Maybe<.Token> {
    loop {
        $parser.tokens.len $parser.cursor = if { make Maybe<.Token>.None break }
        &parser.tokens $parser.cursor Array:get<Token> @token
        $parser.cursor 1 + #parser.cursor
        $token Token-ty match {
            case TOKEN_SPACE -> {}
            case _ -> { drop $token make Maybe<.Token>.Some break }
        }
    }
}
fn abort<T>(parser: .Parser, message-ptr: .i8, message-len: i32) -> Result<T, ParseError> {
    $parser.tokens.len 0 = if {
        0 0 / drop // parsing an empty file always should always succeed
    }
    &parser.tokens $parser.cursor 0 = if { 0 } else { $parser.cursor 1 - } Array:get<Token> @token
    $token Token-location $parser.arena $message-ptr $message-len Array:init<_> make ParseError
    make Result<T, ParseError>.Error
}

struct ParseError {
    line: i32
    column: i32
    message: Array<i8>
}
fn ParseError-print(fd: i32, self: ParseError, file-path-ptr: .i8, file-path: i32) -> i32 { block {
    $fd $file-path-ptr $file-path IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd ":" IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.line IO:print Core:dup<i32> 0 /= if { break } drop
    $fd ":" IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.column IO:print Core:dup<i32> 0 /= if { break } drop
    $fd " " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd &self.message Array:unpack<_> IO:write-all
} }

fn parse(arena: .Arena, tokens: Array<Token>) -> Result<Array<TopItem>, ParseError> {
    Array:new<TopItem> @items
    $arena $tokens 0 Array:new<Token> make Parser @parser
    loop {
        &parser advance match {
            case None -> { $items make Result<Array<TopItem>, ParseError>.Success break }
            case Some -> {}
        }
        &parser flip top-item match {
            case Success -> { @top-item $arena &items $top-item Array:push<TopItem> }
            case Error -> { make Result<Array<TopItem>, ParseError>.Error break }
        }
    }
}

fn top-item(parser: .Parser, token: .Token) -> Result<TopItem, ParseError> { block (-> Result<TopItem, ParseError>) {
    $token Token-ty match {
        case TOKEN_IMPORT -> {
            $parser advance match {
                case None -> { $parser "expected a file path" abort<TopItem> break }
                case Some -> {}
            } @path
            $path Token-ty match {
                case TOKEN_STRING -> {}
                case _ -> { drop $parser "expected a file path" abort<TopItem> break }
            }

            $parser advance match {
                case None -> { $parser "expected `as`" abort<TopItem> break }
                case Some -> {}
            } @aes
            $aes Token-ty match {
                case TOKEN_AS -> { }
                case _ -> { drop $parser "expected `as`" abort<TopItem> break }
            }
            $parser advance match {
                case None -> { $parser "expected an identifier" abort<TopItem> break }
                case Some -> {}
            } @ident
            $ident Token-ty match {
                case TOKEN_IDENT -> { $ident }
                case _ -> { drop $parser "expected an identifier" abort<TopItem> break }
            } @qualifier

            $parser peek match {
                case None -> { 1 1 = }
                case Some -> { Token-ty make TokenTy.TOKEN_LEFT_PAREN /= }
            } if {
                make Import {
                    $token ~ @start
                    $path ~ @path
                    $qualifier ~ @qualifier
                    Array:new<Token> @items
                }
                make TopItem.Import
                make Result<TopItem, ParseError>.Success break
            }
            Array:new<Token> @items
            $parser advance drop // drop the `(`
            loop {
                $parser advance match {
                    case None -> { $parser "expected `)` or an identifier" abort<Array<Token>> break }
                    case Some -> {}
                } @item
                $item Token-ty match {
                    case TOKEN_RIGHT_PAREN -> {
                        $items make Result<Array<Token>, ParseError>.Success break
                    }
                    case TOKEN_IDENT -> {
                        $parser.arena &items $item ~ Array:push<Token>
                        $parser peek match {
                            case None -> { $parser "expected `)` or `,`" abort<Array<Token>> break }
                            case Some -> { }
                        } @comma
                        $comma Token-ty match {
                            case TOKEN_COMMA -> { $parser advance drop }
                            case TOKEN_RIGHT_PAREN -> {
                                $parser advance drop
                                $items make Result<Array<Token>, ParseError>.Success break
                            }
                            case _ -> {
                                drop $parser "expected `)` or `,`" abort<Array<Token>> break
                            }
                        }
                    }
                    case _ -> {
                        drop $parser "expected `)` or an identifier" abort<Array<Token>> break
                    }
                }
            } match {
                case Success -> {
                    @items
                    make Import {
                        $token ~ @start
                        $path ~ @path
                        $qualifier ~ @qualifier
                        $items @items
                    }
                    make TopItem.Import
                    make Result<TopItem, ParseError>.Success break
                }
                case Error -> { make Result<TopItem, ParseError>.Error break }
            }
        }
        case TOKEN_FN -> {
            $parser make TokenTy.TOKEN_IDENT expect-token match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @name
            $parser advance match {
                case None -> { $parser "expected `(`, `<` or a string" abort<TopItem> break }
                case Some -> {}
            } @paren-or-export
            $paren-or-export Token-ty match {
                case TOKEN_STRING -> {
                    $parser advance match {
                        case None -> { $parser "expected `(` or `<`" abort<TopItem> break }
                        case Some -> {}
                    } @paren
                    $paren Token-ty match {
                        case TOKEN_LEFT_PAREN -> {}
                        case TOKEN_LEFT_TRIANGLE -> {}
                        case _ -> { drop $parser "expected `(`" abort<TopItem> break }
                    }
                    $paren-or-export ~ make Maybe<Token>.Some $paren
                }
                case TOKEN_LEFT_PAREN -> { make Maybe<Token>.None $paren-or-export }
                case TOKEN_LEFT_TRIANGLE -> { make Maybe<Token>.None $paren-or-export }
                case _ -> { drop $parser "expected `(` or a string" abort<TopItem> break }
            } @paren @export
            $parser $paren signature match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @signature
            $signature.generic-parameters #parser.generic-parameters

            $parser advance match {
                case None -> { $parser "expected `{`" abort<TopItem> break }
                case Some -> {}
            } @brace
            $parser $brace words match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @body
            Array:new<Token> #parser.generic-parameters
            $token ~ $name ~ $export $signature $body make Function make TopItem.Function make Result<TopItem, ParseError>.Success break
        }
        case TOKEN_STRUCT -> {
            $parser make TokenTy.TOKEN_IDENT expect-token match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @name
            $parser advance match {
                case None -> { $parser "expected `<` or `{`" abort<TopItem> break }
                case Some -> {}
            } @left-triangle-or-brace
            $left-triangle-or-brace Token-ty match {
                case TOKEN_LEFT_TRIANGLE -> {
                    $parser $left-triangle-or-brace generic-parameters match {
                        case Error -> { make Result<TopItem, ParseError>.Error break }
                        case Success -> {}
                    }
                    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
                        case Error -> { make Result<TopItem, ParseError>.Error break }
                        case Success -> { drop }
                    }
                }
                case TOKEN_LEFT_BRACE -> { Array:new<Token> }
                case _ -> { drop $parser "expected `<` or `{`" abort<TopItem> break }
            } @generic-parameters
            $generic-parameters #parser.generic-parameters
            Array:new<NamedType> @fields
            loop (-> Result<TopItem, ParseError>) {
                $parser peek match {
                    case None -> { $parser "expected `}`" abort<TopItem> break }
                    case Some -> {}
                } @end
                $end Token-ty match {
                    case TOKEN_RIGHT_BRACE -> {
                        $parser advance assert-some<.Token> drop
                        $token ~ $name ~ $generic-parameters $fields $end ~ make Struct
                        make TopItem.Struct
                        make Result<TopItem, ParseError>.Success break
                    }
                    case _ -> { drop }
                }
                $parser.arena &fields
                $parser make TokenTy.TOKEN_IDENT expect-token match {
                    case Error -> { make Result<TopItem, ParseError>.Error break }
                    case Success -> {}
                } ~
                $parser make TokenTy.TOKEN_COLON expect-token match {
                    case Error -> { make Result<TopItem, ParseError>.Error break }
                    case Success -> { drop }
                }
                $parser advance match {
                    case None -> { $parser "expected a type" abort<TopItem> break }
                    case Some -> {}
                } $parser flip type match {
                    case Error -> { make Result<TopItem, ParseError>.Error break }
                    case Success -> {}
                }
                make NamedType Array:push<NamedType>
                $parser peek match {
                    case None -> { $parser "expected `}`" abort<TopItem> break }
                    case Some -> {}
                } @end
                $end Token-ty match {
                    case TOKEN_RIGHT_BRACE -> {
                        $parser advance assert-some<.Token> drop
                        $token ~ $name ~ $generic-parameters $fields $end ~ make Struct
                        make TopItem.Struct
                        make Result<TopItem, ParseError>.Success break
                    }
                    case _ -> { drop }
                }
            }
            Array:new<Token> #parser.generic-parameters
        }
        case TOKEN_VARIANT -> {
            $parser make TokenTy.TOKEN_IDENT expect-token match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @name
            $parser advance match {
                case None -> { $parser "expected `<` or `{`" abort<TopItem> break }
                case Some -> {}
            } @left-triangle-or-brace
            $left-triangle-or-brace Token-ty match {
                case TOKEN_LEFT_TRIANGLE -> {
                    $parser $left-triangle-or-brace generic-parameters match {
                        case Error -> { make Result<TopItem, ParseError>.Error break }
                        case Success -> {}
                    }
                    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
                        case Error -> { make Result<TopItem, ParseError>.Error break }
                        case Success -> { drop }
                    }
                }
                case TOKEN_LEFT_BRACE -> { Array:new<Token> }
                case _ -> { drop $parser "expected `<` or `{`" abort<TopItem> break }
            } @generic-parameters
            $generic-parameters #parser.generic-parameters
            Array:new<VariantCase> @cases
            loop (-> Result<TopItem, ParseError>) {
                $parser.arena &cases
                $parser advance match {
                    case None -> { $parser "expected `case` or `}`" abort<TopItem> break }
                    case Some -> {}
                } Core:dup<.Token> Token-ty match {
                    case TOKEN_RIGHT_BRACE -> {
                        @end
                        $token ~ $name ~ $generic-parameters $cases $end ~ make Variant
                        make TopItem.Variant
                        make Result<TopItem, ParseError>.Success break
                    }
                    case TOKEN_CASE -> {}
                    case _ -> { $parser "expected `case`" abort<TopItem> break }
                } ~
                $parser make TokenTy.TOKEN_IDENT expect-token match {
                    case Error -> { make Result<TopItem, ParseError>.Error break }
                    case Success -> {}
                } ~
                $parser peek match {
                    case None -> { $parser "`}`" abort<TopItem> break }
                    case Some -> {}
                } @arrow
                $arrow Token-ty match {
                    case TOKEN_ARROW -> {
                        $parser advance assert-some<.Token> drop
                        $parser advance match {
                            case None -> { $parser "expected type" abort<TopItem> break }
                            case Some -> {}
                        }
                        $parser flip type match {
                            case Error -> { make Result<TopItem, ParseError>.Error break }
                            case Success -> { make Maybe<Type>.Some }
                        }
                    }
                    case _ -> { drop make Maybe<Type>.None }
                }
                make VariantCase Array:push<VariantCase>
                $parser peek match {
                    case None -> { $parser "expected `}`" abort<TopItem> break }
                    case Some -> {}
                } @end
                $end Token-ty match {
                    case TOKEN_RIGHT_BRACE -> {
                        $parser advance assert-some<.Token> drop
                        $token ~ $name ~ $generic-parameters $cases $end ~ make Variant
                        make TopItem.Variant
                        make Result<TopItem, ParseError>.Success break
                    }
                    case _ -> { drop }
                }
            }
            Array:new<Token> #parser.generic-parameters
        }
        case TOKEN_EXTERN -> {
            $parser make TokenTy.TOKEN_STRING expect-token match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @extrn-module

            $parser make TokenTy.TOKEN_STRING expect-token match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @extrn-name

            $parser make TokenTy.TOKEN_FN expect-token match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> { drop }
            }

            $parser make TokenTy.TOKEN_IDENT expect-token match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @name
            $parser advance match {
                case None -> { $parser "expected `(` or `<`" abort<TopItem> break }
                case Some -> {}
            } @paren
            $parser $paren signature match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @signature
            $token ~ $extrn-module ~ $extrn-name ~ $name ~ $signature make Extern
            make TopItem.Extern
            make Result<TopItem, ParseError>.Success break
        }
        case TOKEN_GLOBAL -> {
            $parser make TokenTy.TOKEN_IDENT expect-token match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @name
            $parser make TokenTy.TOKEN_COLON expect-token match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> { drop }
            }
            $parser advance match {
                case None -> { $parser "expected a type" abort<TopItem> break }
                case Some -> {}
            } $parser flip type match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @type
            $token ~
            $name ~
            $type
            make Global
            make TopItem.Global
            make Result<TopItem, ParseError>.Success break
        }
        case _ -> { drop $parser "expected `extern`, `fn`, `struct`, `variant` or `global`" abort<TopItem> }
    }
} }

fn words(parser: .Parser, token: .Token) -> Result<Words, ParseError> { block {
    Array:new<Word> @words
    loop {
        $parser advance match {
            case None -> { $parser "expected `}` or a word" abort<Words> break }
            case Some -> {}
        } @token
        $token Token-ty match {
            case TOKEN_RIGHT_BRACE -> {
                $words $token ~ make Words make Result<Words, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser $token word match {
            case Error -> { make Result<Words, ParseError>.Error break }
            case Success -> {}
        } @word
        $parser.arena &words $word Array:push<Word>
    }
} }
fn word(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    $token Token-ty match {
        case TOKEN_IDENT -> { $parser $token call match { case Error -> { make Result<Word, ParseError>.Error } case Success -> { make Word.Call make Result<Word, ParseError>.Success } } break }
        case TOKEN_STRING -> { $parser $token string break }
        case TOKEN_AT -> { $parser $token init-locl break }
        case TOKEN_AMPERSAND -> { $parser $token ref-or-ref-locl break }
        case TOKEN_DOLLAR -> { $parser $token get-locl break }
        case TOKEN_HASH -> { $parser $token set-locl break }
        case TOKEN_NUMBER -> { $token ~ make Word.Number }
        case TOKEN_IF -> { $parser $token iff break }
        case TOKEN_BLOCK -> { $parser $token blok break }
        case TOKEN_TILDE -> { $token ~ make Word.Load }
        case TOKEN_BANG -> { $parser $token cast break }
        case TOKEN_BREAK -> { $token ~ make Word.Break }
        case TOKEN_LOOP -> { $parser $token lop break }
        case TOKEN_MAKE -> { $parser $token mayk break }
        case TOKEN_BACKSLASH -> { $parser $token fun-ref break }
        case TOKEN_MATCH -> { $parser $token matsh break }
        case TOKEN_DOT -> { $parser $token get-field break }
        case TOKEN_SIZEOF -> { $parser $token sizof break }
        case TOKEN_ARROW -> { $token ~ make Word.IndirectCall }
        case TOKEN_DOUBLE_ARROW -> { $parser $token stor break }
        case TOKEN_LEFT_BRACKET -> { $parser $token tuple break }
        case TOKEN_COLON -> { $parser $token stack-annotation break }
        case _ -> {
            drop
            $parser "expected a word" abort<Word> break
        }
    } make Result<Word, ParseError>.Success
} }

fn string(parser: .Parser, token: .Token) -> Result<Word, ParseError> {
    $token ~
    $parser.arena $token Token-string-content
    make StringWord
    make Word.String
    make Result<Word, ParseError>.Success
}

fn stack-annotation(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    $parser make TokenTy.TOKEN_LEFT_PAREN expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> { drop }
    }
    Array:new<Type> @types
    loop (-> Result<Word, ParseError>) {
        $parser advance match {
            case None -> { $parser "expected `)`" abort<Word> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_RIGHT_PAREN -> {
                $token ~ $types make StackAnnotation
                make Word.StackAnnotation
                make Result<Word, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser.arena &types
        $parser $next type match {
            case Error -> { make Result<Word, ParseError>.Error break }
            case Success -> {}
        } Array:push<Type>
        $parser advance match {
            case None -> { $parser "expected `)`" abort<Word> break }
            case Some -> {}
        } Token-ty match {
            case TOKEN_RIGHT_PAREN -> {
                $token ~ $types make StackAnnotation
                make Word.StackAnnotation
                make Result<Word, ParseError>.Success break
            }
            case TOKEN_COMMA -> {}
            case _ -> { drop $parser "expected `,` or `)`" abort<Word> break }
        }
    }
} }

fn tuple(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block (-> Result<Word, ParseError>) {
    $parser make TokenTy.TOKEN_COMMA expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> { drop }
    }
    $parser advance match {
        case None -> { $parser "expected `,` or `]`" abort<Word> break }
        case Some -> {}
    } @number-or-close
    $number-or-close Token-ty make TokenTy.TOKEN_RIGHT_BRACKET = if {
        $token ~ make Word.UnpackTuple make Result<Word, ParseError>.Success break
    }
    $number-or-close Token-ty make TokenTy.TOKEN_NUMBER = if {
        $token ~ $number-or-close ~ make MakeTuple make Word.MakeTuple
        $parser make TokenTy.TOKEN_RIGHT_BRACKET expect-token match {
            case Error -> { make Result<Word, ParseError>.Error break }
            case Success -> { drop }
        }
        make Result<Word, ParseError>.Success break
    }
    $parser "expected `]`" abort<Word>
} }

fn sizof(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block (-> Result<Word, ParseError>) {
    $parser make TokenTy.TOKEN_LEFT_PAREN expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> { drop }
    }
    $parser advance match {
        case None -> { $parser "expected a type" abort<Word> break }
        case Some -> {}
    } $parser flip type match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $parser make TokenTy.TOKEN_RIGHT_PAREN expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> { drop }
    }
    $token ~ flip make Sizeof make Word.Sizeof make Result<Word, ParseError>.Success
} }

fn matsh(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    $parser advance match {
        case None -> { $parser "expected `{`" abort<Word> break }
        case Some -> {}
    } Token-ty match {
        case TOKEN_LEFT_BRACE -> {}
        case _ -> { drop $parser "expected `{`" abort<Word> break }
    }
    Array:new<MatchCase> @cases
    make Maybe<MatchCase>.None @default
    loop {
        $parser advance match {
            case None -> { $parser "expected `}`" abort<Word> break }
            case Some -> {}
        } @cays
        $cays Token-ty match {
            case TOKEN_RIGHT_BRACE -> {
                $token ~ $cases $default $cays ~ make Match make Word.Match make Result<Word, ParseError>.Success break
            }
            case TOKEN_CASE -> {}
            case _ -> { drop $parser "expected `}`" abort<Word> break }
        }
        $parser advance match {
            case None -> {
                $parser "expected variant name" abort<Word> break }
            case Some -> {}
        } @case-name
        $case-name Token-ty match {
            case TOKEN_IDENT -> { 0 1 = }
            case TOKEN_UNDERSCORE -> {
                &default match {
                    case None -> {}
                    case Some -> { drop $parser "cannot have two default cases" abort<Word> break }
                }
                1 1 =
            }
            case _ -> {
                2 $case-name Token-print
                0 0 / drop
                drop $parser "expected variant name" abort<Word> break }
        } @is-default
        $parser make TokenTy.TOKEN_ARROW expect-token match {
            case Error -> { make Result<Word, ParseError>.Error break }
            case Success -> { drop }
        }
        $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
            case Error -> { make Result<Word, ParseError>.Error break }
            case Success -> { }
        }
        $parser flip words match {
            case Error -> { make Result<Word, ParseError>.Error break }
            case Success -> {}
        } @body
        $cays ~ $case-name ~ $body make MatchCase @cays
        $is-default if {
            $cays make Maybe<MatchCase>.Some #default
        } else {
            $parser.arena &cases $cays Array:push<MatchCase>
        }
    }
} }

fn mayk(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block (-> Result<Word, ParseError>) {
    $token ~
    $parser advance match {
        case None -> { $parser "expected a type" abort<Word> break }
        case Some -> {}
    } $parser flip custom-type match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> { match {
            case Custom -> {}
            case _ -> {
                drop
                $parser "can only `make` struct types" abort<Word> break
            }
        } }
    }
    $parser peek match {
        case None -> { make MakeStruct make Word.MakeStruct make Result<Word, ParseError>.Success break }
        case Some -> {}
    } Token-ty match {
        case TOKEN_DOT -> {
            $parser advance assert-some<.Token> drop
        }
        case TOKEN_LEFT_BRACE -> {
            $parser advance assert-some<.Token> @brace
            $parser $brace words match {
                case Error -> { make Result<Word, ParseError>.Error break }
                case Success -> {
                    make MakeStructNamed make Word.MakeStructNamed make Result<Word, ParseError>.Success break
                }
            }
        }
        case _ -> { drop make MakeStruct make Word.MakeStruct make Result<Word, ParseError>.Success break }
    }
    $parser make TokenTy.TOKEN_IDENT expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } ~
    make MakeVariant make Word.MakeVariant make Result<Word, ParseError>.Success
} }

fn cast(parser: .Parser, token: .Token) -> Result<Word, ParseError> {
    $parser advance match {
        case None -> { $parser "expected a type" abort<Word> }
        case Some -> {
            $parser flip type match {
                case Error -> { make Result<Word, ParseError>.Error }
                case Success -> { $token ~ flip make Cast make Word.Cast make Result<Word, ParseError>.Success }
            }
        }
    }
}

fn expect-token(parser: .Parser, ty: TokenTy) -> Result<.Token, ParseError> {
    $parser advance match {
        case None -> {
            $parser.arena Arena:temp @arena @save
            $arena "expected `" Array:init<_> @message
            $arena &message $ty TokenTy-name Array:append-raw<_>
            $arena &message "`" Array:append-raw<_>
            $parser &message Array:unpack<_> abort<.Token>
            $arena $save Arena:restore
        }
        case Some -> {
            Core:dup<.Token> Token-ty $ty /= if {
                Token-ty @actual
                $parser.arena Arena:temp @arena @save
                $arena "expected `" Array:init<_> @message
                $arena &message $ty TokenTy-name Array:append-raw<_>
                $arena &message "` got: " Array:append-raw<_>
                $arena &message "`" Array:append-raw<_>
                $arena &message $actual TokenTy-name Array:append-raw<_>
                $arena &message "`" Array:append-raw<_>
                $parser &message Array:unpack<_> abort<.Token>
                $arena $save Arena:restore
            } else {
                make Result<.Token, ParseError>.Success
            }
        }
    }
}

fn iff(parser: .Parser, start: .Token) -> Result<Word, ParseError> { block {
    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @brace
    $parser $brace words match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @if-words
    $parser peek match {
        case None -> { $start ~ $if-words make Maybe<Words>.None make If make Word.If make Result<Word, ParseError>.Success break }
        case Some -> {}
    } Token-ty match {
        case TOKEN_ELSE -> { $parser advance assert-some<.Token> drop }
        case _ -> { drop $start ~ $if-words make Maybe<Words>.None make If make Word.If make Result<Word, ParseError>.Success break }
    }
    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @brace
    $parser $brace words match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @else-words
    $start ~
    $if-words
    $else-words make Maybe<Words>.Some
    make If
    make Word.If
    make Result<Word, ParseError>.Success
} }

fn lop(parser: .Parser, start: .Token) -> Result<Word, ParseError> { block {
    $parser peek match {
        case None -> { $parser "expected `{`" abort<Word> break }
        case Some -> {}
    } Token-ty match {
        case TOKEN_LEFT_BRACE -> { make Maybe<BlockAnnotation>.None }
        case TOKEN_LEFT_PAREN -> {
            $parser blok-annotation match {
                case Error -> { make Result<Word, ParseError>.Error break }
                case Success -> {}
            }
        }
        case _ -> { drop $parser "expected `{`" abort<Word> break }
    } @annotation
    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } $parser flip words match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @words
    $start ~ $annotation $words make Loop make Word.Loop make Result<Word, ParseError>.Success
} }

fn blok-annotation(parser: .Parser) -> Result<Maybe<BlockAnnotation>, ParseError> { block {
    Array:new<Type> @parameters
    Array:new<Type> @returns
    $parser peek match {
        case None -> {
            make Maybe<BlockAnnotation>.None
            make Result<Maybe<BlockAnnotation>, ParseError>.Success break
        }
        case Some -> {}
    } Token-ty match {
        case TOKEN_LEFT_BRACE -> {
            make Maybe<BlockAnnotation>.None
            make Result<Maybe<BlockAnnotation>, ParseError>.Success break
        }
        case TOKEN_LEFT_PAREN -> { $parser advance assert-some<.Token> drop }
        case _ -> { drop $parser "expected `(`" abort<Maybe<BlockAnnotation>> break }
    }
    loop {
        $parser peek match {
            case None -> { $parser "expected `->`" abort<Array<Type>> break }
            case Some -> {}
        } Token-ty match {
            case TOKEN_ARROW -> {
                $parser advance assert-some<.Token> drop
                $parameters make Result<Array<Type>, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser $parser advance assert-some<.Token> type match {
            case Error -> { make Result<Array<Type>, ParseError>.Error break }
            case Success -> {}
        } @parameter
        $parser.arena &parameters $parameter Array:push<Type>
        $parser advance match {
            case None -> { $parser "expected `,` or `->`" abort<Array<Type>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_ARROW -> { $parameters make Result<Array<Type>, ParseError>.Success break }
            case TOKEN_COMMA -> {}
            case _ -> { drop $parser "expected `,` or `->`" abort<Array<Type>> break }
        }
    } match {
        case Error -> { make Result<Maybe<BlockAnnotation>, ParseError>.Error break }
        case Success -> {}
    } @parameters

    loop {
        $parser peek match {
            case None -> { $parser "expected `)`" abort<Array<Type>> break }
            case Some -> {}
        } Token-ty match {
            case TOKEN_RIGHT_PAREN -> { 
                $parser advance drop // skip `)`
                $returns make Result<Array<Type>, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser $parser advance assert-some<.Token> type match {
            case Error -> { make Result<Array<Type>, ParseError>.Error break }
            case Success -> {}
        } @return
        $parser.arena &returns $return Array:push<Type>
        $parser advance match {
            case None -> { $parser "expected `,` or `)`" abort<Array<Type>> break }
            case Some -> {}
        } Token-ty match {
            case TOKEN_RIGHT_PAREN -> { $returns make Result<Array<Type>, ParseError>.Success break }
            case TOKEN_COMMA -> {}
            case _ -> { drop $parser "expected `,` or `)`" abort<Array<Type>> break }
        }
    } match {
        case Error -> { make Result<Maybe<BlockAnnotation>, ParseError>.Error break }
        case Success -> {}
    } @returns
    $parameters $returns make BlockAnnotation make Maybe<BlockAnnotation>.Some make Result<Maybe<BlockAnnotation>, ParseError>.Success
} }

fn blok(parser: .Parser, start: .Token) -> Result<Word, ParseError> { block {
    $parser peek match {
        case None -> { $parser "expected `{`" abort<Word> break }
        case Some -> {}
    } Token-ty match {
        case TOKEN_LEFT_BRACE -> { make Maybe<BlockAnnotation>.None }
        case TOKEN_LEFT_PAREN -> {
            $parser blok-annotation match {
                case Error -> { make Result<Word, ParseError>.Error break }
                case Success -> {}
            }
        }
        case _ -> { drop $parser "expected `{`" abort<Word> break }
    } @annotation
    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @brace
    $parser $brace words match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @words
    $start ~ $annotation $words make Block make Word.Block make Result<Word, ParseError>.Success
} }

fn fun-ref(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    $parser advance match {
        case None -> { $parser "expected a function name" abort<Word> break }
        case Some -> {}
    } @function
    $parser $function call match {
        case Error -> { make Result<Word, ParseError>.Error }
        case Success -> { $token ~ flip make FunRef make Word.FunRef make Result<Word, ParseError>.Success }
    }
} }

fn call(parser: .Parser, token: .Token) -> Result<Call, ParseError> { block {
    $parser peek match {
        case None -> { $token ~ Array:new<Type> make LocalCall make Call.Local make Result<Call, ParseError>.Success break }
        case Some -> {}
    } @colon
    $colon Token-ty match {
        case TOKEN_COLON -> { $parser advance assert-some<.Token> drop }
        case TOKEN_LEFT_TRIANGLE -> {
            $parser advance assert-some<.Token> drop
            $parser generic-arguments match {
                case Error -> { make Result<Call, ParseError>.Error break }
                case Success -> {
                    $token ~ flip make LocalCall make Call.Local make Result<Call, ParseError>.Success break
                }
            }
        }
        case _ -> { drop $token ~ Array:new<Type> make LocalCall make Call.Local make Result<Call, ParseError>.Success break }
    }
    $parser advance match {
        case Some -> {}
        case None -> { $parser "expected an identifier" abort<Call> break }
    } @name
    $name Token-ty match {
        case TOKEN_IDENT -> {}
        case _ -> { drop $parser "expected an identifier" abort<Call> break }
    }
    $parser peek match {
        case None -> { Array:new<Type> }
        case Some -> {
            Token-ty match {
                case TOKEN_LEFT_TRIANGLE -> {
                    $parser advance assert-some<.Token> drop
                    $parser generic-arguments match {
                        case Error -> { make Result<Call, ParseError>.Error break }
                        case Success -> {}
                    }
                }
                case _ -> { drop Array:new<Type> }
            }
        }
    } @generic-arguments
    $token ~ $name ~ $generic-arguments make ForeignCall make Call.Foreign make Result<Call, ParseError>.Success
} }

fn generic-arguments(parser: .Parser) -> Result<Array<Type>, ParseError> {
    Array:new<Type> @generic-args
    loop {
        $parser advance match {
            case None -> { $parser "expected `>` or a type" abort<Array<Type>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_RIGHT_TRIANGLE -> {
                $generic-args make Result<Array<Type>, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser $next type match {
            case Error -> { make Result<Array<Type>, ParseError>.Error break }
            case Success -> {}
        } @type
        $parser.arena &generic-args $type Array:push<Type>
        $parser peek match {
            case Some -> { Token-ty match {
                case TOKEN_COMMA -> { $parser advance drop }
                case TOKEN_RIGHT_TRIANGLE -> {}
                case _ -> { drop $parser "expected `,` or `>`" abort<Array<Type>> break }
            } }
            case None -> {}
        }
    }
}

fn optional-generic-arguments(parser: .Parser) -> Result<Array<Type>, ParseError> { block {
    $parser peek match {
        case None -> { Array:new<Type> }
        case Some -> { Token-ty match {
            case TOKEN_LEFT_TRIANGLE -> {
                $parser advance assert-some<.Token> drop
                $parser generic-arguments match {
                    case Error -> { make Result<Array<Type>, ParseError>.Error break }
                    case Success -> {}
                }
            }
            case _ -> { drop Array:new<Type> }
        } }
    }
    make Result<Array<Type>, ParseError>.Success
} }

fn fields(parser: .Parser) -> Result<Array<Token>, ParseError> {
    Array:new<Token> @fields
    loop {
        $parser peek-immediate match {
            case None -> { $fields make Result<Array<Token>, ParseError>.Success break }
            case Some -> {}
        } @dot
        $dot Token-ty match {
            case TOKEN_DOT -> { $parser advance-immediate assert-some<.Token> drop }
            case TOKEN_SPACE -> { $fields make Result<Array<Token>, ParseError>.Success break }
            case _ -> { drop $parser "expected `.`" abort<Array<Token>> break }
        }
        $parser advance-immediate match {
            case None -> { $parser "expected an identifier" abort<Array<Token>> break }
            case Some -> {}
        } ~ @field
        &field Token-ty match {
            case TOKEN_IDENT -> {}
            case _ -> { drop $parser "expected an identifier" abort<Array<Token>> break }
        }
        $parser.arena &fields $field Array:push<Token>
    }
}

fn ident(parser: .Parser) -> Result<Token, ParseError> { block {
    $parser advance match {
        case None -> { $parser "expected an identifier" abort<Token> break }
        case Some -> {}
    } @ident
    $ident Token-ty match {
        case TOKEN_IDENT -> {}
        case _ -> { drop $parser "expected an identifier" abort<Token> break }
    }
    $ident ~ make Result<Token, ParseError>.Success
} }

fn get-field(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    Array:new<Token> @fields
    loop {
        $parser advance-immediate match {
            case None -> { $parser "expected an identifier" abort<Word> break }
            case Some -> {}
        } @field
        $field Token-ty match {
            case TOKEN_IDENT -> {}
            case _ -> { drop $parser "expected an identifier" abort<Word> break }
        }
        $parser.arena &fields $field ~ Array:push<Token>
        $parser peek-immediate match {
            case None -> {
                $token ~ $fields make GetField make Word.GetField make Result<Word, ParseError>.Success break
            }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_DOT -> { $parser advance-immediate assert-some<.Token> drop }
            case _ -> {
                drop
                $token ~ $fields make GetField make Word.GetField make Result<Word, ParseError>.Success break
            }
        }
    }
} }

fn ref-or-ref-locl(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    $parser peek-immediate match {
        case None -> {}
        case Some -> {
            Token-ty match {
                case TOKEN_IDENT -> { $parser $token ref-locl break }
                case _ -> { drop }
            }
        }
    }
    $token ~ make Word.Ref make Result<Word, ParseError>.Success
} }

fn ref-locl(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block (-> Result<Word, ParseError>) {
    $token ~
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @ident
    $parser fields match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $ident flip make RefLocal
    make Word.RefLocal make Result<Word, ParseError>.Success
} }

fn get-locl(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block (-> Result<Word, ParseError>) {
    $token ~
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @ident
    $parser fields match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $ident flip make GetLocal
    make Word.GetLocal make Result<Word, ParseError>.Success
} }

fn set-locl(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block (-> Result<Word, ParseError>) {
    $token ~
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @ident
    $parser fields match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $ident flip make SetLocal
    make Word.SetLocal make Result<Word, ParseError>.Success
} }

fn init-locl(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } $token ~ flip make InitLocal make Word.InitLocal make Result<Word, ParseError>.Success
} }

fn stor(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block (-> Result<Word, ParseError>) {
    $token ~
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $parser fields match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    make Store make Word.Store make Result<Word, ParseError>.Success
} }

fn generic-parameters(parser: .Parser, token: .Token) -> Result<Array<Token>, ParseError> { block {
    Array:new<Token> @generic-params
    loop {
        $parser advance match {
            case None -> { $parser "expected `>` or an identifier" abort<Array<Token>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_RIGHT_TRIANGLE -> {
                $generic-params make Result<Array<Token>, ParseError>.Success break
            }
            case TOKEN_IDENT -> {}
            case _ -> { drop $parser "expected `>` or an identifier" abort<Array<Token>> break }
        }
        $parser.arena &generic-params $next ~ Array:push<Token>
        $parser peek match {
            case Some -> { Token-ty match {
                case TOKEN_COMMA -> { $parser advance drop }
                case TOKEN_RIGHT_TRIANGLE -> {}
                case _ -> { drop $parser "expected `,` or `>`" abort<Array<Token>> break }
            } }
            case None -> {}
        }
    }
} }

fn signature(parser: .Parser, token: .Token) -> Result<Signature, ParseError> { block (-> Result<Signature, ParseError>) {
    $token Token-ty match {
        case TOKEN_LEFT_TRIANGLE -> {
            $parser $token generic-parameters match {
                case Error -> { make Result<Signature, ParseError>.Error break }
                case Success -> {}
            }
            $parser advance match {
                case None -> { $parser "expected `(`" abort<Signature> break }
                case Some -> {}
            } Token-ty match {
                case TOKEN_LEFT_PAREN -> {}
                case _ -> { drop $parser "expected `(`" abort<Signature> break }
            }
        }
        case _ -> { drop Array:new<Token> }
    } @generic-params
    $generic-params #parser.generic-parameters

    Array:new<NamedType> @params
    loop {
        $parser advance match {
            case None -> { $parser "expected `)` or an identifier" abort<Array<NamedType>> break }
            case Some -> {}
        } @paren-or-ident
        $paren-or-ident Token-ty match {
            case TOKEN_RIGHT_PAREN -> {
                $params make Result<Array<NamedType>, ParseError>.Success break
            }
            case TOKEN_IDENT -> { $paren-or-ident }
            case _ -> { drop $parser "expected `)` or an identifer" abort<Array<NamedType>> break }
        } @ident
        $parser make TokenTy.TOKEN_COLON expect-token match {
            case Error -> { make Result<Array<NamedType>, ParseError>.Error break }
            case Success -> { drop }
        }
        $parser advance match {
            case None -> { $parser "expected a type" abort<Array<NamedType>> break }
            case Some -> {}
        } $parser flip type match {
            case Error -> { make Result<Array<NamedType>, ParseError>.Error break }
            case Success -> {}
        } @type
        $parser.arena &params $ident ~ $type make NamedType Array:push<NamedType>
        $parser peek match {
            case Some -> { Token-ty match {
                case TOKEN_COMMA -> { $parser advance drop }
                case TOKEN_RIGHT_PAREN -> {}
                case _ -> { drop $parser "expected `,` or `)`" abort<Array<NamedType>> break }
            } }
            case None -> {}
        }
    } match {
        case Error -> { make Result<Signature, ParseError>.Error break }
        case Success -> {}
    } @params

    $parser peek match {
        case None -> { $generic-params $params Array:new<Type> make Signature make Result<Signature, ParseError>.Success break }
        case Some -> {}
    } @arrow
    $arrow Token-ty match {
        case TOKEN_ARROW -> { $parser advance assert-some<.Token> drop }
        case _ -> { drop $generic-params $params Array:new<Type> make Signature make Result<Signature, ParseError>.Success break }
    }
    Array:new<Type> @returns
    loop {
        $parser peek match {
            case None -> { $parser "expected a type or `{`" abort<Array<Type>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_LEFT_BRACE -> {
                $returns make Result<Array<Type>, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser advance assert-some<.Token> drop
        $parser $next type match {
            case Error -> { make Result<Array<Type>, ParseError>.Error break }
            case Success -> {}
        } @type
        $parser.arena &returns $type Array:push<Type>

        $parser peek match {
            case None -> {
                $returns make Result<Array<Type>, ParseError>.Success break
            }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_COMMA -> { $parser advance drop }
            case _ -> {
                drop
                $returns make Result<Array<Type>, ParseError>.Success break
            }
        }
    } match {
        case Error -> { make Result<Signature, ParseError>.Error break }
        case Success -> {}
    } @returns
    $generic-params $params $returns make Signature make Result<Signature, ParseError>.Success
} }

fn custom-type(parser: .Parser, token: .Token) -> Result<Type, ParseError> {
    block (-> Result<Type, ParseError>) {
        $parser peek match {
            case None -> { $token ~ Array:new<Type> make LocalCustomType make CustomType.Local make Type.Custom }
            case Some -> {
                Token-ty match {
                    case TOKEN_COLON -> {
                        $token ~
                        $parser advance assert-some<.Token> drop // skip `:`
                        $parser make TokenTy.TOKEN_IDENT expect-token match {
                            case Error -> { make Result<Type, ParseError>.Error break }
                            case Success -> {}
                        } ~
                        $parser optional-generic-arguments match {
                            case Error -> { make Result<Type, ParseError>.Error break }
                            case Success -> {}
                        }
                        make ForeignCustomType make CustomType.Foreign make Type.Custom
                    }
                    case _ -> {
                        drop
                        &parser.generic-parameters \Token-eq-by-lexeme $token Array:find<Token, .Token> if {
                            $token ~ flip make GenericType make Type.Generic make Result<Type, ParseError>.Success break
                        } else { drop }
                        $token ~
                        $parser optional-generic-arguments match {
                            case Error -> { make Result<Type, ParseError>.Error break }
                            case Success -> {}
                        }
                        make LocalCustomType make CustomType.Local make Type.Custom
                    }
                }
            }
        }
        make Result<Type, ParseError>.Success
    }
}

fn fun-type(parser: .Parser, token: .Token) -> Result<FunType, ParseError> { block {
    Array:new<Type> @parameters
    loop {
        $parser advance match {
            case None -> { $parser "expected `->`" abort<Array<Type>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_ARROW -> { $parameters make Result<Array<Type>, ParseError>.Success break }
            case _ -> { drop }
        }
        $parser $next type match {
            case Error -> { make Result<Array<Type>, ParseError>.Error break }
            case Success -> {}
        } @type
        $parser.arena &parameters $type Array:push<Type>
        $parser advance match {
            case None -> { $parser "expected `->`" abort<Array<Type>> break }
            case Some -> {}
        } Token-ty match {
            case TOKEN_ARROW -> { $parameters make Result<Array<Type>, ParseError>.Success break }
            case TOKEN_COMMA -> {}
            case _ -> { drop $parser "expected `,` or `->`" abort<Array<Type>> break }
        }
    } match {
        case Error -> { make Result<FunType, ParseError>.Error break }
        case Success -> {}
    } @parameter

    Array:new<Type> @returns
    loop {
        $parser advance match {
            case None -> { $parser "expected `)`" abort<Array<Type>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_RIGHT_PAREN -> { $returns make Result<Array<Type>, ParseError>.Success break }
            case _ -> { drop }
        }
        $parser $next type match {
            case Error -> { make Result<Array<Type>, ParseError>.Error break }
            case Success -> {}
        } @type
        $parser.arena &returns $type Array:push<Type>
        $parser advance match {
            case None -> { $parser "expected `)`" abort<Array<Type>> break }
            case Some -> {}
        } Token-ty match {
            case TOKEN_RIGHT_PAREN -> { $returns make Result<Array<Type>, ParseError>.Success break }
            case TOKEN_COMMA -> {}
            case _ -> { drop $parser "expected `,` or `)`" abort<Array<Type>> break }
        }
    } match {
        case Error -> { make Result<FunType, ParseError>.Error break }
        case Success -> {}
    } @returns
    $token ~ $parameters $returns make FunType make Result<FunType, ParseError>.Success
} }

fn tuple-type(parser: .Parser, token: .Token) -> Result<TupleType, ParseError> { block {
    Array:new<Type> @items
    loop (-> Result<TupleType, ParseError>) {
        $parser advance match {
            case None -> { $parser "expected a type or `]`" abort<TupleType> break }
            case Some -> {}
        } @next
        $next Token-ty make TokenTy.TOKEN_RIGHT_BRACKET = if {
            $token ~ Array:new<Type> make TupleType
            make Result<TupleType, ParseError>.Success break
        }
        $parser.arena &items $parser $next type match {
            case Error -> { make Result<TupleType, ParseError>.Error break }
            case Success -> {}
        } Array:push<Type>
        $parser advance match {
            case None -> { $parser "expected `]` or `,`" abort<TupleType> break }
            case Some -> {}
        } @comma-or-closing
        $comma-or-closing Token-ty make TokenTy.TOKEN_RIGHT_BRACKET = if {
            $token ~ $items make TupleType
            make Result<TupleType, ParseError>.Success break
        }
        $comma-or-closing Token-ty make TokenTy.TOKEN_COMMA /= if {
            $parser "expected `,` in tuple type" abort<TupleType> break
        }
    }
} }

fn type(parser: .Parser, token: .Token) -> Result<Type, ParseError> { block (-> Result<Type, ParseError>) {
    $token Token-ty match {
        case TOKEN_BOOL -> { $token ~ make Type.Bool }
        case TOKEN_I8 -> { $token ~ make Type.I8 }
        case TOKEN_I32 -> { $token ~ make Type.I32 }
        case TOKEN_I64 -> { $token ~ make Type.I64 }
        case TOKEN_DOT -> {
            $parser advance match {
                case None -> { $parser "expected a type" abort<Type> break }
                case Some -> { $parser flip type match {
                    case Success -> { $token ~ flip $parser.arena flip Arena:push<Type> make PtrType make Type.Ptr }
                    case _ -> { break }
                } }
            }
        }
        case TOKEN_IDENT -> {
            $parser $token custom-type match {
                case Error -> { make Result<Type, ParseError>.Error break }
                case Success -> {}
            }
        }
        case TOKEN_LEFT_PAREN -> {
            $parser $token fun-type match {
                case Error -> { make Result<Type, ParseError>.Error break }
                case Success -> { make Type.Fun }
            }
        }
        case TOKEN_LEFT_BRACKET -> {
            $parser $token tuple-type match {
                case Error -> { make Result<Type, ParseError>.Error break }
                case Success -> { make Type.Tuple }
            }
        }
        case TOKEN_UNDERSCORE -> { $token ~ make Type.Hole }
        case _ -> { drop $parser "expected a type" abort<Type> break }
    } make Result<Type, ParseError>.Success
} }

