import "../../std/core.watim" as Core
import "../../std/maybe.watim" as Maybe (Maybe, is-some)
import "../../std/arena.watim" as Arena (Arena)
import "../../std/map.watim" as Map (Map)
import "../../std/fmt.watim" as Fmt (Formatter, ByteSlice-format)
import "../../std/array.watim" as Array (Array)
import "../../std/list.watim" as List (List)
import "../../std/util.watim" as Util (i32-format, bool-format)

import "../lexer.watim" as Lexer (Token, Token-lexeme, Token-format)
import "../type.watim" as ResolvedType (CustomTypeHandle)
import "../env.watim" as Env (LocalId, LocalId-eq)
import "../resolver/resolver.watim" as Resolver (VarId)
import "../monomizer.watim" as Monomized (
    Monomized, Module, ExternOrInstances,
    Extern, Function, FunctionHandle, Signature, Local, Global,
    Type, Key, Key-type, NamedTypeId, TypeId, TypeId-format,
    CustomType, CustomType-name, FunType,
    Variant, VariantCase, Struct,
    Word, StructWord, Intrinsic, FieldAccess, MatchCase,
    I32-id, I64-id, type-size, field-offset, can-live-in-reg,
)

import "./ctx.watim" as Ctx (
    Ctx, lookup-type, lookup-globl, lookup-function,
    globl-lives-in-memory, local-lives-in-memory, var-lives-in-memory,
    lookup-custom-type,
    generate-pack-i32s, generate-unpack-i32s,
    generate-flip-i32-i32, generate-flip-i32-i64,
    generate-flip-i64-i32, generate-flip-i64-i64,
    generate-dup-i64,
)
import "./common.watim" as Common (
    generate-local-ident, generate-type, generate-var-ident,
    generate-parameters-unnamed, generate-returns,
    generate-type-pretty, generate-store,
)
import "./intrinsic.watim" as IntrinsicGen (generate-intrinsic)

fn generate-words(ctx: .Ctx, module: i32, locals: .Map<LocalId, Local>, words: .Array<Word>) {
    0 @i
    loop {
        $i $words.len = if { break }
        $ctx $module $locals $words $i Array:get<Word> generate-word
        $i 1 + #i
    }
}

fn generate-word(ctx: .Ctx, module: i32, locals: .Map<LocalId, Local>, word: .Word) {
    $ctx.fmt Fmt:write-indent
    $word match {
        case Number -> {
            $ctx.fmt "i32.const " Fmt:write
            $ctx.fmt flip Token-lexeme Fmt:write
        }
        case String -> {
            @word
            $ctx.fmt "i32.const " Fmt:write
            $ctx.fmt
            &ctx.module-data-offsets $module Array:get<i32> ~ $word.offset +
            i32-format
            $ctx.fmt " i32.const " Fmt:write
            $ctx.fmt $word.len i32-format
        }
        case Drop -> {
            drop $ctx.fmt "drop" Fmt:write
        }
        case Intrinsic -> {
            .intrinsic $ctx flip generate-intrinsic
        }
        case GetLocal -> {
            @word
            &ctx.program.sizes $word.result-type can-live-in-reg @result-can-live-in-reg

            $ctx.program $word.result-type lookup-type @result-type

            $result-can-live-in-reg not if {
                // set up the address to store the result in
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset i32-format
                $ctx.fmt " i32.add call $intrinsic:dupi32 " Fmt:write
            }
            &word.var match {
                case Global -> {
                    @global-id
                    $ctx.fmt "global.get $" Fmt:write
                    $ctx.program $global-id lookup-globl @globl
                    $ctx.fmt &globl.name Token-lexeme Fmt:write
                    $ctx.fmt ":" Fmt:write
                    $ctx.fmt $global-id.module.index i32-format
                    $ctx $globl globl-lives-in-memory
                }
                case Local -> {
                    @local-id
                    $ctx.fmt "local.get " Fmt:write
                    $locals $local-id Map:get<LocalId, Local> Maybe:assert-some<.Local> @local
                    $ctx.fmt $local $local-id generate-local-ident
                    $ctx $local local-lives-in-memory
                }
            } @var-lives-in-memory
            // at this point, either the value itself or a pointer to it is on the stack

            0 !.Arena Arena:temp @temp @temp-save
            0 1 = @just-ref
            $temp $ctx &word.fields $just-ref $var-lives-in-memory determine-loads @loads

            &ctx.program.sizes $word.result-type type-size @result-size
            $ctx &loads generate-loads
            &loads List:is-empty<Load> if {
                $result-can-live-in-reg if {
                    $var-lives-in-memory if {
                        $ctx.fmt " " Fmt:write
                        $ctx $word.result-type generate-type
                        $ctx.fmt ".load" Fmt:write
                    }
                } else {
                    $ctx.fmt " i32.const " Fmt:write
                    $ctx.fmt $result-size i32-format
                    $ctx.fmt " memory.copy" Fmt:write
                }
            }
            $temp $temp-save Arena:restore
        }
        case InitLocal -> {
            @word
            List:empty<Load> @loads

            $ctx $locals &word.local Map:get<LocalId, Local> Maybe:assert-some<.Local>
            local-lives-in-memory @var-lives-in-memory

            $ctx $locals $word.local make VarId.Local $word.type $var-lives-in-memory &loads generate-set
        }
        case SetLocal -> {
            @word
            0 !.Arena Arena:temp @temp @temp-save
            $ctx $locals &word.var var-lives-in-memory @var-lives-in-memory

            $var-lives-in-memory
            $ctx &word.fields fields-go-through-ptr
            or @target-lives-in-memory

            $temp $ctx &word.fields $target-lives-in-memory $var-lives-in-memory determine-loads @loads
            $ctx $locals $word.var $word.target-type $target-lives-in-memory &loads generate-set
            $temp $temp-save Arena:restore
        }
        case RefLocal -> {
            @word
            0 !.Arena Arena:temp @temp @temp-save
            $temp $ctx &word.fields 1 1 = 0 1 = determine-loads @loads
            $ctx.fmt &word.var match {
                case Local -> { drop "local.get " }
                case Global -> { drop "global.get " }
            } Fmt:write
            $ctx $locals &word.var generate-var-ident
            $ctx &loads generate-loads
            $temp $temp-save Arena:restore
        }
        case Call -> {
            @word
            $ctx.fmt "call $" Fmt:write
            $ctx.fmt $word.function.module.index i32-format
            $ctx.fmt ":" Fmt:write
            $ctx.fmt $ctx.program &word.function lookup-function match {
                case Extern -> { @ext &ext.name &ext.signature }
                case Function -> { @fun &fun.name &fun.signature }
            } @signature Token-lexeme Fmt:write
            $word.function.instance 0 /= if {
                $ctx.fmt ":" Fmt:write
                $ctx.fmt $word.function.instance i32-format
            }
            $ctx $word.copy-space-offset &signature.returns generate-return-receivers
        }
        case If -> {
            @word
            $ctx.fmt "(if" Fmt:write
            $ctx &word.parameters generate-parameters-unnamed
            $ctx &word.returns match {
                case None -> { drop }
                case Some -> { generate-returns }
            }
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "(then\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx $module $locals &word.true-words generate-words
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")\n" Fmt:write
            $word.false-words.len 0 /= if {
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "(else\n" Fmt:write
                $ctx.fmt Fmt:indent
                $ctx $module $locals &word.false-words generate-words
                $ctx.fmt Fmt:dedent
                $ctx.fmt Fmt:write-indent
                $ctx.fmt ")\n" Fmt:write
            }
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")" Fmt:write
            &word.returns match {
                case None -> {
                    $ctx.fmt "\n" Fmt:write
                    $ctx.fmt Fmt:write-indent
                    $ctx.fmt "unreachable" Fmt:write
                }
                case Some -> { drop }
            }
        }
        case Break -> { drop $ctx.fmt "br $block" Fmt:write }
        case Block -> {
            @word
            $ctx.fmt "(block $block" Fmt:write
            $ctx &word.parameters generate-parameters-unnamed
            $ctx &word.returns generate-returns
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx $module $locals &word.words generate-words
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")" Fmt:write
        }
        case Loop -> {
            @word
            $ctx.fmt "(block $block " Fmt:write
            $ctx &word.parameters generate-parameters-unnamed
            $ctx &word.returns match { case Some -> { generate-returns } case None -> { drop } }
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "(loop $loop " Fmt:write
            $ctx &word.parameters generate-parameters-unnamed
            $ctx &word.returns match { case Some -> { generate-returns } case None -> { drop } }
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx $module $locals &word.words generate-words
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "br $loop\n" Fmt:write
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")\n" Fmt:write
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")" Fmt:write
            &word.returns match {
                case Some -> { drop }
                case None -> {
                    $ctx.fmt "\n" Fmt:write
                    $ctx.fmt Fmt:write-indent
                    $ctx.fmt "unreachable" Fmt:write
                }
            }
        }
        case Load -> {
            @word
            &ctx.program.sizes $word.type can-live-in-reg if {
                $ctx $word.type generate-type
                $ctx.fmt ".load" Fmt:write
            } else {
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset i32-format
                $ctx.fmt " i32.add call $intrinsic:dupi32 call $intrinsic:rotate-left i32.const " Fmt:write
                $ctx.fmt &ctx.program.sizes $word.type type-size i32-format
                $ctx.fmt " memory.copy" Fmt:write
            }
        }
        case Struct -> { $ctx flip generate-struc-word }
        case StructNamed -> { block {
            @word
            $ctx.program $word.type lookup-type match {
                case Custom -> {}
                case _ -> { drop Core:unreachable<.CustomTypeHandle> }
            } @custom-type-handle
            $ctx.program $custom-type-handle lookup-custom-type match {
                case Variant -> { drop Core:unreachable<.Struct> }
                case Struct -> {}
            } @struc
            &ctx.program.sizes $word.type type-size @type-size
            $type-size 0 = if {
                0 @i
                loop {
                    $i $struc.fields.len = if { break }
                    $ctx.fmt "drop " Fmt:write
                    $i 1 + #i
                }
                $ctx.fmt "i32.const 0 ;; make " Fmt:write
                $ctx $word.type generate-type-pretty
                break
            }
            $ctx.fmt ";; make " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx $module $locals &word.words generate-words
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add " Fmt:write
            block {
                $type-size 4 le if {
                    $ctx.fmt "i32.load " Fmt:write
                }
                $type-size 8 le if {
                    $ctx.fmt "i64.load " Fmt:write
                }
            }
            $ctx.fmt ";; make " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt " end" Fmt:write
        } }
        case FieldInit -> {
            @word
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add " Fmt:write
            &ctx.program.sizes $word.type type-size @type-size
            $type-size 4 le $type-size 8 gt or if {
                $ctx generate-flip-i32-i32
            } else {
                $ctx generate-flip-i64-i32
            }
            $ctx.fmt " " Fmt:write
            $ctx $word.type generate-store
        }
        case Variant -> { block {
            @word
            $ctx.program $word.type lookup-type match {
                case Custom -> {}
                case _ -> { drop Core:unreachable<.CustomTypeHandle> }
            } @custom-type-handle
            $ctx.program $custom-type-handle lookup-custom-type match {
                case Variant -> {}
                case Struct -> { drop Core:unreachable<.Variant> }
            } @varint
            &varint.cases $word.tag Array:get<VariantCase> @cays
            &ctx.program.sizes $word.type type-size @varint-size

            $varint-size 4 le if {
                $varint-size 4 /= if {
                    // The tag is (at least for now) always 4 bytes,
                    // so there can be no smaller variant.
                    0 0 / drop
                }
                $cays.type match {
                    case Some -> { drop $ctx.fmt "drop " Fmt:write }
                    case None -> {}
                }
                $ctx.fmt "i32.const " Fmt:write
                $ctx.fmt $word.tag i32-format
                $ctx.fmt " ;; store tag " Fmt:write
                $ctx.fmt &varint.name Token-lexeme Fmt:write
                $ctx.fmt "." Fmt:write
                $ctx.fmt &cays.name Token-lexeme Fmt:write
                break
            }

            $varint-size 8 le if {
                $cays.type match {
                    case None -> {
                        $ctx.fmt "i64.const " Fmt:write
                        $ctx.fmt $word.tag i32-format
                        $ctx.fmt " ;; make " Fmt:write
                    }
                    case Some -> {
                        drop
                        $ctx.fmt "i64.extend_i32_u i64.const 32 i64.shl ;; store value\n" Fmt:write
                        $ctx.fmt Fmt:write-indent
                        $ctx.fmt "i64.const " Fmt:write
                        $ctx.fmt $word.tag i32-format
                        $ctx.fmt " ;; store tag\n" Fmt:write
                        $ctx.fmt Fmt:write-indent
                        $ctx.fmt "i64.or ;; make " Fmt:write
                    }
                }
                $ctx.fmt &varint.name Token-lexeme Fmt:write
                $ctx.fmt "." Fmt:write
                $ctx.fmt &cays.name Token-lexeme Fmt:write
                break
            }

            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add i32.const " Fmt:write
            $ctx.fmt $word.tag i32-format
            $ctx.fmt " i32.store ;; store tag\n" Fmt:write
            $cays.type match {
                case Some -> {
                    @case-type
                    &ctx.program.sizes $case-type type-size @case-type-size

                    $ctx.fmt Fmt:write-indent
                    $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                    $ctx.fmt $word.copy-space-offset 4 + i32-format
                    $ctx.fmt " i32.add " Fmt:write
                    $case-type-size 4 gt $case-type-size 8 le and if {
                        $ctx generate-flip-i64-i32
                    } else {
                        $ctx generate-flip-i32-i32
                    }
                    $ctx.fmt " " Fmt:write
                    $ctx $case-type generate-store
                    $ctx.fmt " ;; store value\n" Fmt:write
                }
                case None -> {}
            }
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add ;; make " Fmt:write
            $ctx.fmt &varint.name Token-lexeme Fmt:write
            $ctx.fmt "." Fmt:write
            $ctx.fmt &cays.name Token-lexeme Fmt:write
        } }
        case Match -> {
            @word
            $ctx.program $word.type lookup-type match {
                case Custom -> {}
                case _ -> { drop Core:unreachable<.CustomTypeHandle> }
            } @custom-type-handle
            $ctx.program $custom-type-handle lookup-custom-type match {
                case Variant -> {}
                case Struct -> { drop Core:unreachable<.Variant> }
            } @varint
            &ctx.program.sizes $word.type type-size @variant-size
            $ctx.fmt ";; match on " Fmt:write
            $ctx.fmt &varint.name Token-lexeme Fmt:write
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:write-indent
            0 @i
            &ctx.program.sizes $word.type can-live-in-reg @variant-can-live-in-reg
            loop {
                $i $word.cases.len = if {
                    &word.default match {
                        case None -> {
                            $ctx.fmt "unreachable" Fmt:write
                        }
                        case Some -> {
                            $ctx flip $module flip $locals flip generate-words
                        }
                    }
                    break
                }
                &word.cases $i Array:get<MatchCase> @cays
                block {
                    $variant-size 8 gt $word.by-ref or if {
                        $ctx.fmt "call $intrinsic:dupi32 i32.load " Fmt:write
                        break
                    }
                    $variant-size 4 gt if {
                        $ctx generate-dup-i64
                        $ctx.fmt " i32.wrap_i64 " Fmt:write
                        break
                    }
                    $ctx.fmt "call $intrinsic:dupi32 " Fmt:write
                }
                $ctx.fmt "i32.const " Fmt:write
                $ctx.fmt $cays.tag i32-format
                $ctx.fmt " i32.eq (if" Fmt:write
                $ctx &word.parameters generate-parameters-unnamed

                $variant-size 8 le $variant-size 4 gt and $word.by-ref not and @variant-inhabits-i64
                $ctx.fmt $variant-inhabits-i64 if {
                    " (param i64)"
                } else {
                    " (param i32)"
                } Fmt:write

                $ctx &word.returns generate-returns
                $ctx.fmt "\n" Fmt:write
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "(then\n" Fmt:write
                $ctx.fmt Fmt:indent
                $cays.type match {
                    case None -> {
                        $ctx.fmt Fmt:write-indent
                        $ctx.fmt "drop\n" Fmt:write
                    }
                    case Some -> {
                        @case-type
                        &ctx.program.sizes $case-type type-size @case-type-size
                        $case-type-size 0 /= if {
                            $ctx.fmt Fmt:write-indent
                            $word.by-ref $variant-size 8 gt or if {
                                $ctx.fmt "i32.const 4 i32.add" Fmt:write
                                $word.by-ref not $case-type-size 8 le and if {
                                    $ctx.fmt " " Fmt:write
                                    $ctx $case-type generate-type
                                    $ctx.fmt ".load" Fmt:write
                                }
                            } else {
                                $ctx.fmt "i64.const 32 i64.shr_u i32.wrap_i64" Fmt:write
                            }
                            $ctx.fmt "\n" Fmt:write
                        } else {
                            $variant-inhabits-i64 if {
                                $ctx.fmt Fmt:write-indent
                                $ctx.fmt "i32.wrap_i64\n" Fmt:write
                            }
                        }
                    }
                }
                $ctx $module $locals &cays.words generate-words
                $ctx.fmt Fmt:dedent
                $ctx.fmt Fmt:write-indent
                $ctx.fmt ")\n" Fmt:write
                $ctx.fmt Fmt:write-indent
                $i 1 + $word.cases.len = &word.default is-some<Array<Word>> and if {
                    $ctx.fmt "(else\n" Fmt:write
                    $ctx.fmt Fmt:indent
                } else {
                    $ctx.fmt "(else " Fmt:write
                }
                $i 1 + #i
            }
            loop {
                $i 0 = if { break }
                $i $word.cases.len = &word.default is-some<Array<Word>> and if {
                    $ctx.fmt Fmt:dedent
                    $ctx.fmt Fmt:write-indent
                }
                $ctx.fmt "))" Fmt:write
                $i 1 - #i
            }
        }
        case Flip -> {
            @flip
            &ctx.program.sizes $flip.lower type-size @lower-size
            &ctx.program.sizes $flip.upper type-size @upper-size
            $lower-size 4 le $lower-size 8 gt or @lower-is-i32
            $upper-size 4 le $upper-size 8 gt or @upper-is-i32
            block {
                $lower-is-i32     $upper-is-i32     and if { $ctx generate-flip-i32-i32 break }
                $lower-is-i32     $upper-is-i32 not and if { $ctx generate-flip-i32-i64 break }
                $lower-is-i32 not $upper-is-i32     and if { $ctx generate-flip-i64-i32 break }
                $lower-is-i32 not $upper-is-i32 not and if { $ctx generate-flip-i64-i64 break }
                0 0 / drop
            }
        }
        case Cast -> {
            @word
            block {
                &ctx.program.sizes $word.src type-size @src-size
                &ctx.program.sizes $word.dst type-size @dst-size
                $src-size $dst-size = if {
                    $ctx.fmt ";; cast to " Fmt:write
                    $ctx $word.dst generate-type-pretty
                    break
                }
                $src-size 4 le $dst-size 4 gt and 8 $dst-size le and if {
                    $ctx.fmt "i64.extend_i32_s ;; cast to " Fmt:write
                    $ctx $word.dst generate-type-pretty
                    break
                }
                $src-size 4 gt $src-size 8 le and $dst-size 4 le and if {
                    $ctx.fmt "i32.wrap_i64 ;; cast to " Fmt:write
                    $ctx $word.dst generate-type-pretty
                    break
                }
                $src-size 4 le $dst-size 1 = and if {
                    $ctx.fmt "i32.const 0xFF i32.and ;; cast to " Fmt:write
                    $ctx $word.dst generate-type-pretty
                    break
                }
                $src-size 4 le $dst-size 4 le and $dst-size $src-size ge and if {
                    $ctx.fmt ";; cast to " Fmt:write
                    $ctx $word.dst generate-type-pretty
                    break
                }

                $ctx.program $word.dst lookup-type match {
                    case I64 -> {
                        &ctx.program.sizes $word.src can-live-in-reg if {
                            $ctx.fmt "i64.extend_i32_s" Fmt:write
                            break
                        }
                    }
                    case _ -> { drop }
                }

                $ctx.fmt "UNSUPPORTED Cast from " Fmt:write
                $ctx $word.src generate-type-pretty
                $ctx.fmt " to " Fmt:write
                $ctx $word.dst generate-type-pretty
            }
        }
        case Sizeof -> {
            &ctx.program.sizes flip ~ type-size
            $ctx.fmt "i32.const " Fmt:write
            $ctx.fmt flip i32-format
        }
        case IndirectCall -> {
            @word
            $ctx.program $word.type lookup-type match {
                case Fun -> {}
                case _ -> { drop Core:unreachable<.FunType> }
            } @fun-type
            $ctx.fmt "(call_indirect" Fmt:write
            $ctx &fun-type.parameters generate-parameters-unnamed
            $ctx &fun-type.returns generate-returns
            $ctx.fmt ")" Fmt:write
            $ctx $word.copy-space-offset &fun-type.returns generate-return-receivers
        }
        case GetField -> {
            @word
            0 !.Arena Arena:temp @temp @temp-save
            $temp $ctx &word.fields $word.on-ptr 0 1 = determine-loads @loads
            &loads List:is-empty<Load> if {
                $ctx.fmt ";; GetField was no-op" Fmt:write
            } else {
                &ctx.program.sizes $word.type can-live-in-reg @target-type-can-live-in-reg
                $word.on-ptr not $target-type-can-live-in-reg not and if {
                    $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                    $ctx.fmt $word.copy-space-offset i32-format
                    $ctx.fmt " i32.add call $intrinsic:dupi32 " Fmt:write
                }
                $ctx &loads generate-loads
            }
            $temp $temp-save Arena:restore
        }
        case Uninit -> { block {
            @word
            &ctx.program.sizes $word.type type-size @type-size
            $type-size 4 le if {
                $ctx.fmt "i32.const 0" Fmt:write
                break
            }

            $type-size 8 le if {
                $ctx.fmt "i64.const 0" Fmt:write
                break
            }
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add" Fmt:write
        } }
        case FunRef -> {
            $ctx.fmt "i32.const " Fmt:write
            .table-index ~ $ctx.fmt flip 1 + i32-format
        }
        case StoreLocal -> {
            @word
            $ctx.fmt &word.var match {
                case Local -> { drop "local.get " }
                case Global -> { drop "global.get " }
            } Fmt:write
            $ctx $locals &word.var generate-var-ident
            0 !.Arena Arena:temp @temp @temp-save
            $temp $ctx &word.fields 1 0 = 0 1 = determine-loads @loads
            $ctx &loads generate-loads
            $ctx.fmt " call $intrinsic:flip " Fmt:write
            $ctx $word.type generate-store
            $temp $temp-save Arena:restore
        }
        case MakeTuple -> { block {
            @word
            $ctx.program $word.type lookup-type match {
                case Tuple -> {}
                case _ -> { drop Core:unreachable<.Array<TypeId>> }
            } @items
            &ctx.program.sizes $word.type type-size @tuple-size
            $tuple-size 8 le if {
                $tuple-size 0 = if {
                    0 @i
                    loop {
                        $i $items.len = if { break }
                        $ctx.fmt "drop " Fmt:write
                        $i 1 + #i
                    }
                    $ctx.fmt "i32.const 0 " Fmt:write
                }
                $tuple-size 4 gt if {
                    $items.len 2 /= if {
                        // alternative is TODO
                        0 0 / drop
                    }
                    &ctx.program.sizes $items 0 Array:get<TypeId> ~ type-size 4 =
                    &ctx.program.sizes $items 0 Array:get<TypeId> ~ type-size 4 =
                    and not if {
                        // alternative is TODO
                        0 0 / drop
                    }
                    $ctx generate-pack-i32s
                }
                $ctx.fmt ";; make " Fmt:write
                $ctx $word.type generate-type-pretty
                break
            }
            $ctx.fmt ";; make " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt "\n" Fmt:write
            $tuple-size @item-offset
            $ctx.fmt Fmt:indent
            $items.len @i
            loop {
                $i 0 = if { break }
                $i 1 - #i
                $items $i Array:get<TypeId> ~ @item
                &ctx.program.sizes $item type-size @item-size
                $item-offset $item-size - #item-offset
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset $item-offset + i32-format
                $ctx.fmt " i32.add " Fmt:write
                $item-size 4 gt $item-size 8 le and if {
                    $ctx generate-flip-i64-i32
                } else {
                    $ctx generate-flip-i32-i32
                }
                $ctx.fmt " " Fmt:write
                $ctx $item generate-store
                $ctx.fmt "\n" Fmt:write
            }
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add ;; make " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt " end" Fmt:write
        } }
        case UnpackTuple -> { block {
            @word
            $ctx.program $word.type lookup-type match {
                case Tuple -> {}
                case _ -> { drop Core:unreachable<.Array<TypeId>> }
            } @items
            $items.len 2 = if {
                &ctx.program.sizes $items 0 Array:get<TypeId> ~ type-size 4 =
                &ctx.program.sizes $items 1 Array:get<TypeId> ~ type-size 4 =
                and if {
                    $ctx generate-unpack-i32s
                    $ctx.fmt ";; unpack " Fmt:write
                    $ctx $word.type generate-type-pretty
                    break
                }
            }
            $ctx.fmt ";; unpack " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $word.copy-space-offset @copy-space-offset
            0 @offset
            0 @i
            loop {
                $i $items.len = if { break }
                $items $i Array:get<TypeId> ~ @item
                $i 1 + #i
                &ctx.program.sizes $item type-size @item-size
                $ctx.fmt Fmt:write-indent
                $item-size 0 = if {
                    $ctx.fmt "i32.const " Fmt:write
                } else {
                    $i $items.len /= if {
                        $ctx.fmt "call $intrinsic:dupi32 " Fmt:write
                    }
                    $ctx.fmt "i32.const " Fmt:write
                    $ctx.fmt $offset i32-format
                    $ctx.fmt " i32.add " Fmt:write

                    &ctx.program.sizes $item can-live-in-reg if {
                        $ctx.fmt "i32.load" Fmt:write
                    } else {
                        $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                        $ctx.fmt $copy-space-offset i32-format
                        $ctx.fmt " i32.add call $intrinsic:dupi32 call $intrinsic:rotate-left i32.const " Fmt:write
                        $ctx.fmt $item-size i32-format
                        $ctx.fmt " memory.copy" Fmt:write
                        $copy-space-offset $item-size + #copy-space-offset
                    }
                    $i $items.len /= if {
                        $ctx.fmt " call $intrinsic:flip\n" Fmt:write
                    }
                }
                $offset $item-size + #offset
            }
            $ctx.fmt Fmt:dedent
        } }
    }
    $ctx.fmt "\n" Fmt:write
}

fn generate-struc-word(ctx: .Ctx, word: .StructWord) { block {
    $ctx.program $word.type lookup-type match {
        case Custom -> {}
        case _ -> { drop Core:unreachable<.CustomTypeHandle> }
    } @custom-type-handle
    $ctx.program $custom-type-handle lookup-custom-type match {
        case Variant -> { drop Core:unreachable<.Struct> }
        case Struct -> {}
    } @struc

    &ctx.program.sizes $word.type type-size @type-size

    $type-size 8 le if {
        $type-size 0 = if {
            0 @i
            loop {
                $i $struc.fields.len = if { break }
                $ctx.fmt "drop " Fmt:write
                $i 1 + #i
            }
            $ctx.fmt "i32.const 0 ;; make " Fmt:write
            $ctx $word.type generate-type-pretty
            break
        }
        $type-size 4 le if {
            $struc.fields.len @i
            $type-size @offset
            loop {
                $i 0 = if { break }
                &ctx.program.sizes &struc.fields $i 1 - Array:get<NamedTypeId> .type ~ type-size @field-size
                $offset $field-size - #offset

                $offset 0 /= if {
                    $i $struc.fields.len /= if {
                        $ctx.fmt "call $intrinsic:flip " Fmt:write
                    }
                    $ctx.fmt "i32.const " Fmt:write
                    $ctx.fmt $offset 8 * i32-format
                    $ctx.fmt " i32.shl " Fmt:write
                }


                $i $struc.fields.len /= if {
                    $ctx.fmt "i32.or " Fmt:write
                }
                $i 1 - #i
            }
            $ctx.fmt ";; make " Fmt:write
            $ctx $word.type generate-type-pretty
            break
        }
        $type-size 8 le if {
            $struc.fields.len @i
            $type-size @offset
            loop {
                $i 0 = if { break }
                &ctx.program.sizes &struc.fields $i 1 - Array:get<NamedTypeId> .type ~ type-size @field-size
                $offset $field-size - #offset

                $i $struc.fields.len /= if {
                    $ctx generate-flip-i32-i64
                    $ctx.fmt " " Fmt:write
                }
                $ctx.fmt "i64.extend_i32_u " Fmt:write
                $offset 0 /= if {
                    $ctx.fmt "i64.const " Fmt:write
                    $ctx.fmt $offset 8 * i32-format
                    $ctx.fmt " i64.shl " Fmt:write
                }

                $i $struc.fields.len /= if {
                    $ctx.fmt "i64.or " Fmt:write
                }
                $i 1 - #i
            }
            $ctx.fmt ";; make " Fmt:write
            $ctx $word.type generate-type-pretty
            break
        }
    }

    $ctx.fmt ";; make " Fmt:write
    $ctx $word.type generate-type-pretty
    $ctx.fmt "\n" Fmt:write
    $ctx.fmt Fmt:indent
    $struc.fields.len @i
    loop {
        $i 0 = if { break }
        $i 1 - @field-index
        &struc.fields $field-index Array:get<NamedTypeId> @field
        &ctx.program.sizes $field.type type-size @field-size
        &ctx.program.sizes $struc $field-index field-offset @field-offset
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
        $ctx.fmt $word.copy-space-offset $field-offset + i32-format
        $ctx.fmt " i32.add " Fmt:write
        $field-size 4 gt $field-size 8 le and if {
            $ctx generate-flip-i64-i32
        } else {
            $ctx generate-flip-i32-i32
        }
        $ctx.fmt " " Fmt:write
        $ctx $field.type generate-store
        $ctx.fmt "\n" Fmt:write
        $i 1 - #i
    }
    $ctx.fmt Fmt:dedent
    $ctx.fmt Fmt:write-indent
    $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
    $ctx.fmt $word.copy-space-offset i32-format
    $ctx.fmt " i32.add ;; make " Fmt:write
    $ctx $word.type generate-type-pretty
    $ctx.fmt " end" Fmt:write
} }

fn generate-return-receivers(ctx: .Ctx, offset: i32, returns: .Array<TypeId>) {
    0 @i
    loop {
        $i $returns.len = if {
            // all returns can live in reg
            0 1 = break
        }
        &ctx.program.sizes $returns $i Array:get<TypeId> ~ can-live-in-reg not if {
            $ctx.program $returns $i Array:get<TypeId> ~ lookup-type match {
                // TODO: this special case for I64s can be removed, once i64 structs are supported
                case I64 -> {}
                case _ -> {
                    drop
                    1 1 = break
                }
            }
        }
        $i 1 + #i
    } if {
        // not all returns can live in reg
        $ctx.fmt "\n" Fmt:write
        0 @i
        loop {
            $i $returns.len = if { break }
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "local.set $s" Fmt:write
            $ctx.fmt $i i32-format
            $ctx.fmt ":a\n" Fmt:write
            $i 1 + #i
        }
        $returns.len @i
        loop {
            $i 0 = if { break }
            $returns $returns.len $i - Array:get<TypeId> ~ @ret
            $ctx.fmt Fmt:write-indent
            &ctx.program.sizes $ret can-live-in-reg if {
                $ctx.fmt "local.get $s" Fmt:write
                $ctx.fmt $i 1 - i32-format
                $ctx.fmt ":a" Fmt:write
            } else {
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $offset i32-format
                $ctx.fmt " i32.add call $intrinsic:dupi32 local.get $s" Fmt:write
                $ctx.fmt $i 1 - i32-format
                $ctx.fmt ":a i32.const " Fmt:write
                &ctx.program.sizes $ret type-size @ret-size
                $ctx.fmt $ret-size i32-format
                $ctx.fmt " memory.copy" Fmt:write
                $offset $ret-size + #offset
            }
            $i 1 - #i
            $i 0 = if { break }
            $ctx.fmt "\n" Fmt:write
        }
    }
}

fn fields-go-through-ptr(ctx: .Ctx, fields: .Array<FieldAccess>) -> bool {
    0 @i
    loop {
        $i $fields.len = if {
            // No field access went through a pointer,
            0 1 = break
        }
        $ctx.program $fields $i Array:get<FieldAccess> .source-type ~ lookup-type match {
            case Ptr -> {
                drop
                // At least one field access goes through a pointer,
                1 1 = break
            }
            case _ -> { drop }
        }
        $i 1 + #i
    }
}

variant BitShift {
    case I32InI64 -> i32
    case I8InI32 -> i32
    case I8InI64 -> i32
}

variant Load {
    case Offset -> i32
    case OffsetLoad -> [TypeId, i32]
    case BitShift -> BitShift
}
fn Load-is-bitshift(load: .Load) -> bool {
    1 $load match {
        case BitShift -> { drop 1 }
        case _ -> { drop 0 }
    } =
}
fn Load-format(fmt: .Formatter, self: .Load) {
    $self match {
        case Offset -> {
            $fmt "(Offset " Fmt:write
            $fmt flip ~ i32-format
            $fmt ")" Fmt:write
        }
        case OffsetLoad -> {
            ~ [,] @offset @type
            $fmt "(OffsetLoad " Fmt:write
            $fmt &type TypeId-format
            $fmt " " Fmt:write
            $fmt $offset i32-format
            $fmt ")" Fmt:write
        }
        case BitShift -> {
            $fmt flip match {
                case I32InI64 -> { $fmt "(I32InI64 " Fmt:write ~ i32-format $fmt ")" }
                case I8InI32 -> { $fmt "(I8InI32 " Fmt:write ~ i32-format $fmt ")" }
                case I8InI64 -> { $fmt "(I8InI64 " Fmt:write ~ i32-format $fmt ")" }
            } Fmt:write
        }
    }
}

fn merge-loads(arena: .Arena, loads: List<Load>) -> List<Load> { block {
    $loads match {
        case Empty -> { $loads break }
        case Cons -> {
            @cons
            $cons.elem
            $cons.next match {
                case Empty -> { drop $loads break }
                case Cons -> { @cons $cons.elem $cons.next }
            }
        }
    } @rest @second @first
    $first match {
        case OffsetLoad -> {
            [,] @first-offset @type
            $second match {
                case BitShift -> {
                    match {
                        case I32InI64 -> {}
                        case I8InI32 -> {}
                        case I8InI64 -> {}
                    } @extra-offset
                    I32-id $first-offset $extra-offset + [,2] make Load.OffsetLoad
                    $rest List:cons<Load>
                }
                case _ -> { drop $loads }
            }
        }
        case Offset -> {
            @first
            $second match {
                case Offset -> {
                    @second
                    $first $second + make Load.Offset
                    $rest List:cons<Load>
                }
                case OffsetLoad -> {
                    [,] @second-offset @type
                    $type $first $second-offset + [,2] make Load.OffsetLoad
                    $rest List:cons<Load>
                }
                case _ -> { drop $loads }
            }
        }
        case BitShift -> { drop $loads }
    }
} }

fn determine-loads(arena: .Arena, ctx: .Ctx, fields: .Array<FieldAccess>, just-ref: bool, base-in-mem: bool) -> List<Load> { block {
    $fields.len 0 = if { List:empty<Load> break }

    $fields 0 Array:get<FieldAccess> @field
    $fields Array:tail<FieldAccess> @tail

    &ctx.program.sizes $field.source-type type-size @source-type-size
    $ctx.program $field.source-type lookup-type match {
        case Custom -> {
            $ctx.program flip lookup-custom-type match {
                case Struct -> {
                    @struc
                    &ctx.program.sizes $struc $field.field-index field-offset @offset

                    block {
                        $base-in-mem $source-type-size 8 gt or if {
                            $fields.len 1 gt $just-ref or if {
                                $offset 0 = if {
                                    $arena $ctx &tail $just-ref 1 1 = determine-loads break
                                }
                                $offset make Load.Offset
                            } else {
                                $field.target-type $offset [,2] make Load.OffsetLoad
                            } @load
                            1 1 = #base-in-mem
                            $arena $ctx &tail $just-ref $base-in-mem determine-loads @rest
                            $arena $load &rest List:cons<Load> merge-loads break
                        }
                        &ctx.program.sizes $field.target-type type-size @target-type-size
                        $source-type-size 4 gt if {
                            block {
                                $target-type-size 1 = if {
                                    $offset make BitShift.I8InI64 break
                                }
                                $target-type-size 4 = if {
                                    $offset make BitShift.I32InI64 break
                                }
                                Core:unreachable<BitShift>
                            } make Load.BitShift @load
                            $arena $ctx &tail $just-ref $base-in-mem determine-loads @rest
                            $arena $load &rest List:cons<Load> merge-loads break
                        }

                        $source-type-size $target-type-size /= if {
                            $target-type-size 1 = if {
                                $arena $ctx &tail $just-ref $base-in-mem determine-loads @rest
                                $arena $offset
                                make BitShift.I8InI32 make Load.BitShift
                                &rest List:cons<Load> merge-loads break
                            }
                            0 0 / drop // TODO
                        }

                        1 $source-type-size 4 = $offset 0 = and !i32 / drop // assert source-type-size == 4
                        $arena $ctx &tail $just-ref $base-in-mem determine-loads break
                    }
                }
                case _ -> {
                    // A field access on a variant doesn't make any sense.
                    // The resolver should have taken care of this case.
                    drop Core:unreachable<List<Load>>
                }
            }
        }
        case Ptr -> {
            ~ $ctx.program flip lookup-type match {
                case Custom -> { $ctx.program flip lookup-custom-type match {
                    case Struct -> {}
                    case _ -> {
                        // A field access on a variant doesn't make any sense.
                        // The resolver should have taken care of this case.
                        drop Core:unreachable<.Struct>
                    }
                } }
                case _ -> {
                    // A field access only makes sense on structs, or ptr to structs.
                    // The resolver should have taken care of this case.
                    drop Core:unreachable<.Struct>
                }
            } @struc
            &ctx.program.sizes $struc $field.field-index field-offset @offset

            &ctx.program.sizes $field.target-type type-size @target-type-size

            $just-ref $fields.len 1 = and
            $target-type-size 8 gt $fields.len 1 /= and
            or if {
                $offset 0 = if {
                    $arena $ctx &tail $just-ref $base-in-mem determine-loads
                } else {
                    $offset make Load.Offset @load
                    $arena $ctx &tail $just-ref $base-in-mem determine-loads @rest
                    $arena $load &rest List:cons<Load> merge-loads
                }
            } else {
                $field.target-type $offset [,2] make Load.OffsetLoad @load
                $arena $ctx &tail $just-ref $base-in-mem determine-loads @rest
                $arena $load &rest List:cons<Load> merge-loads
            }
        }
        case _ -> {
            // A field access only makes sense on structs, or ptr to structs.
            // The resolver should have taken care of this case.
            drop Core:unreachable<List<Load>>
        }
    }
} }

fn are-all-bitshifts(loads: .List<Load>) -> bool {
    \Load-is-bitshift $loads List:all<Load>
}

fn generate-set(
    ctx: .Ctx,
    locals: .Map<LocalId, Local>,
    var-id: VarId,
    target-type: TypeId,
    target-lives-in-memory: bool,
    loads: .List<Load>
) { block {
    &var-id match {
        case Local -> {
            $locals flip Map:get<LocalId, Local> Maybe:assert-some<.Local> @local
            $ctx $local local-lives-in-memory
            $local.type
        }
        case Global -> {
            $ctx.program flip lookup-globl @globl
            $ctx $globl globl-lives-in-memory
            $globl.type
        }
    } @var-type @var-lives-in-memory

    $loads List:is-empty<Load> $target-lives-in-memory not and if {
        $ctx.fmt &var-id match {
            case Local -> { drop "local.set " }
            case Global -> { drop "global.set " }
        } Fmt:write
        $ctx $locals &var-id generate-var-ident
        break
    }

    $ctx.fmt &var-id match {
        case Local -> { drop "local.get " }
        case Global -> { drop "global.get " }
    } Fmt:write
    $ctx $locals &var-id generate-var-ident

    &ctx.program.sizes $target-type type-size @target-type-size

    $loads List:is-empty<Load> if {
        $ctx.fmt " " Fmt:write
        $target-type-size 4 gt $target-type-size 8 le and if {
            $ctx generate-flip-i64-i32
        } else {
            $ctx generate-flip-i32-i32
        }
        $ctx.fmt " " Fmt:write
        $ctx $target-type generate-store
        break
    }

    $loads List:last<Load> Maybe:assert-some<.Load> @last-load
    $last-load match {
        case BitShift -> { drop 1 1 = }
        case _ -> { drop 0 1 = }
    } @last-load-is-bitshift

    $target-lives-in-memory not $last-load-is-bitshift and if {
        $loads @l
        loop {
            $l match {
                case Empty -> { break }
                case Cons -> {}
            } @cons
            $cons.next are-all-bitshifts if { break }
            $ctx &cons.elem generate-load
            $cons.next #l
        }
        uninit<[i64, i64]> @buf &buf !.i8 @buf
        $ctx.fmt $last-load match {
            case BitShift -> { match {
                case I32InI64 -> {
                    ~ @offset
                    $ctx.fmt " i64.const 0x" Fmt:write
                    4294967295 !i64 $offset 8 * rotl not @mask
                    $ctx.fmt $buf !.i32 $buf $mask Core:i64-to-str-hex Fmt:write
                    " i64.and "
                }
                case I8InI32 -> {
                    // offset 0 -> i32.const 0xFFFFFF00 i32.and
                    // offset 1 -> i32.const 0xFFFF00FF i32.and
                    // offset 2 -> i32.const 0xFF00FFFF i32.and
                    // offset 3 -> i32.const 0x00FFFFFF i32.and
                    ~ @offset
                    $ctx.fmt " i32.const 0x" Fmt:write
                    $ctx.fmt $buf !.i32 $buf 255 $offset 8 * rotl not Core:i32-to-str-hex Fmt:write
                    " i32.and "
                }
                case I8InI64 -> {
                    ~ @offset
                    $ctx.fmt " i64.const 0x" Fmt:write
                    $ctx.fmt $buf !.i32 $buf 255 !i64 $offset 8 * rotl not Core:i64-to-str-hex Fmt:write
                    " i64.and "
                }
            } }
            case _ -> { !.i32 0 0 / }
        } Fmt:write
        $ctx generate-flip-i32-i64
        $ctx.fmt " i64.extend_i32_u " Fmt:write
        $last-load match {
            case BitShift -> { match {
                case I32InI64 -> {
                    ~ @offset $offset 0 /= if {
                        $ctx.fmt "i64.const " Fmt:write
                        $ctx.fmt $offset 8 * i32-format
                        $ctx.fmt " i64.shl " Fmt:write
                    }
                    $ctx.fmt "i64.or " Fmt:write
                }
                case I8InI32 -> {
                    ~ @offset $offset 0 /= if {
                        $ctx.fmt "i32.const " Fmt:write
                        $ctx.fmt $offset 8 * i32-format
                        $ctx.fmt " i32.shl " Fmt:write
                    }
                    $ctx.fmt "i32.or " Fmt:write
                }
                case I8InI64 -> {
                    ~ @offset $offset 0 /= if {
                        $ctx.fmt "i64.const " Fmt:write
                        $ctx.fmt $offset 8 * i32-format
                        $ctx.fmt " i64.shl " Fmt:write
                    }
                    $ctx.fmt "i64.or " Fmt:write
                }
            } }
            case _ -> { drop 0 0 / drop }
        }
        $target-lives-in-memory if {
            $ctx.fmt &var-id match {
                case Local -> { drop "local.get " }
                case Global -> { drop "global.get " }
            } Fmt:write
            $ctx $locals &var-id generate-var-ident
            $ctx generate-flip-i64-i32
            // Because the value is being packed into an i64, the modified i64
            // needs to be stored back, not the target-type.
            $ctx I64-id generate-store
            $ctx.fmt "\n" Fmt:write
            break
        } else {
            $ctx.fmt &var-id match {
                case Local -> { drop "local.set " }
                case Global -> { drop "global.set " }
            } Fmt:write
            $ctx $locals &var-id generate-var-ident
            break
        }
    }
    $ctx $loads generate-loads
    $ctx.fmt " " Fmt:write
    $target-type-size 4 gt $target-type-size 8 le and if {
        $ctx generate-flip-i64-i32
    } else {
        $ctx generate-flip-i32-i32
    }
    $ctx.fmt " " Fmt:write
    $ctx $target-type generate-store
} }

fn generate-loads(ctx: .Ctx, loads: .List<Load>) {
    loop {
        $loads match {
            case Empty -> { break }
            case Cons -> {
                @cons
                $ctx.fmt " " Fmt:write
                $ctx &cons.elem generate-load
                $cons.next #loads
            }
        }
    }
}

fn generate-load(ctx: .Ctx, load: .Load) {
    $load match {
        case BitShift -> {
            $ctx.fmt flip match {
                case I32InI64 -> {
                    ~ @offset
                    $offset 0 /= if {
                        $ctx.fmt "i64.const " Fmt:write
                        $ctx.fmt $offset 8 * i32-format
                        $ctx.fmt " i64.shr_u " Fmt:write
                    }
                    "i32.wrap_i64"
                }
                case I8InI32 -> {
                    ~ @offset
                    $offset 0 /= if {
                        $ctx.fmt "i32.const " Fmt:write
                        $ctx.fmt $offset 8 * i32-format
                        $ctx.fmt " i32.shr_u " Fmt:write
                    }
                    "i32.const 0xFF i32.and"
                }
                case I8InI64 -> {
                    ~ @offset
                    $offset 0 /= if {
                        $ctx.fmt "i64.const " Fmt:write
                        $ctx.fmt $offset 8 * i32-format
                        $ctx.fmt " i64.shr_u " Fmt:write
                    }
                    "i32.wrap_i64 i32.const 0xFF i32.and"
                }
            } Fmt:write
        }
        case Offset -> {
            $ctx.fmt "i32.const " Fmt:write
            $ctx.fmt flip ~ i32-format
            $ctx.fmt " i32.add" Fmt:write
        }
        case OffsetLoad -> {
            ~ [,] @offset @type
            &ctx.program.sizes $type type-size @size
            block {
                $size 8 le if {
                    $ctx.fmt block {
                        $size 1 = if { "i32.load8_u" break }
                        $size 4 le if { "i32.load" break }
                        "i64.load"
                    } Fmt:write
                    $offset 0 /= if {
                        $ctx.fmt " offset=" Fmt:write
                        $ctx.fmt $offset i32-format
                    }
                    break
                }
                $offset 0 = if {
                    $ctx.fmt "i32.const " Fmt:write
                    $ctx.fmt $size i32-format
                    $ctx.fmt " memory.copy" Fmt:write
                    break
                }
                $ctx.fmt "i32.const " Fmt:write
                $ctx.fmt $offset i32-format
                $ctx.fmt " i32.add i32.const " Fmt:write
                $ctx.fmt $size i32-format
                $ctx.fmt " memory.copy" Fmt:write
            }
        }
    }
}

