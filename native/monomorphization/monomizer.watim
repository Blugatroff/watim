import "../../std/core.watim" as Core
import "../../std/maybe.watim" as Maybe (Maybe(None, Some), assert-none, assert-some)
import "../../std/result.watim" as Result (Result)
import "../../std/result.watim" as Result (Result)
import "../../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../../std/arena.watim" as Arena (Arena)
import "../../std/array.watim" as Array (Array)
import "../../std/map.watim" as Map (Map)
import "../../std/fmt.watim" as Fmt (Formatter)
import "../../std/fmt-utils.watim" as Fmt (ByteSlice-format)
import "../../std/util.watim" as Util (i32-format, bool-format, i32-format-ref)
import "../../std/io.watim" as IO

import "../logging.watim" as Logging
import "../lexer.watim" as Lexer (Token, Token-format)
import "../resolving/type.watim" as Checked (
    ModuleId, ModuleId-format,
    CustomTypeHandle, CustomTypeHandle-eq, CustomTypeHandle-format
)
import "../resolving/words.watim" as Resolved (
    ScopeId, ScopeId-format, root-scope,
    LocalId, LocalId-format, LocalId-eq,
    VarId, VarId-format, StringWord, StringWord-format,
)
import "../resolving/top-items.watim" as Resolved (LocalName, LocalName-format)
import "../inference/ast.watim" as Checked

import "./type.watim" as Type (
    Type(Ptr, Bool, I8, I32, I64, Tuple, Fun, Custom), Type-format, Type-eq,
    TypeId, TypeId-eq, TypeId-format, TypeIds-eq, TypeIds-format,
    NamedTypeId, NamedTypeId-eq, NamedTypeId-format,
    FunType, CustomType, Struct, Variant, CustomType-format, VariantCase,
    CustomType-eq,
)

struct Global {
    name: Token
    type: TypeId
    reffed: bool
}
fn Global-format(fmt: .Formatter, self: .Global) {
    $fmt "(Global " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.reffed bool-format
    $fmt ")" Fmt:write
}


// =============================================================================
//  Monomorphized Extern and Function
// =============================================================================

struct Extern {
    name: Token
    extrn-module: ByteSlice
    extrn-name: ByteSlice
    signature: Signature
}
fn Extern-format(fmt: .Formatter, self: .Extern) {
    $fmt "(Extern\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "extrn-module=" Fmt:write
    $fmt &self.extrn-module ByteSlice-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "extrn-name=" Fmt:write
    $fmt &self.extrn-name ByteSlice-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "signature=" Fmt:write
    $fmt &self.signature Signature-format
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

struct Local {
    name: LocalName
    type: TypeId
    reffed: bool
    is-parameter: bool
}
fn Local-format(fmt: .Formatter, self: .Local) {
    $fmt "(Local " Fmt:write
    $fmt &self.name LocalName-format
    $fmt " " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.reffed bool-format
    $fmt " " Fmt:write
    $fmt $self.is-parameter bool-format
    $fmt ")" Fmt:write
}

struct Function {
    name: Token
    export: Maybe<Token>
    signature: Signature
    locals: Map<LocalId, Local>
    local-copy-space: i32
    max-stack-returns: i32
    body: Scope
    generic-arguments: Array<TypeId> // just for debug annotations
}
fn Function-format(fmt: .Formatter, self: .Function) {
    $fmt "(Function\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "export=" Fmt:write
    $fmt \Token-format &self.export Maybe:format<Token>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "signature=" Fmt:write
    $fmt &self.signature Signature-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "generic-arguments=" Fmt:write
    $fmt \TypeId-format &self.generic-arguments Array:format<TypeId>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "locals=" Fmt:write
    $fmt \LocalId-format \Local-format &self.locals Map:format-multi-line<LocalId, Local>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "local-copy-space=" Fmt:write
    $fmt $self.local-copy-space i32-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "max-stack-returns=" Fmt:write
    $fmt $self.max-stack-returns i32-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "body=" Fmt:write
    $fmt &self.body Scope-format
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}
fn Function-ref-format(fmt: .Formatter, self: ..Function) {
    $fmt $self ~ Function-format
}

struct Signature {
    parameters: Array<NamedTypeId>
    returns: Array<TypeId>
}
fn Signature-format(fmt: .Formatter, self: .Signature) {
    $fmt "(Signature " Fmt:write
    $fmt \NamedTypeId-format &self.parameters Array:format-multi-line<NamedTypeId>
    $fmt " " Fmt:write
    $fmt \TypeId-format &self.returns Array:format-multi-line<TypeId>
    $fmt ")" Fmt:write
}

struct FunctionHandle {
    module: ModuleId
    index: i32
    instance: i32
}
fn FunctionHandle-format(fmt: .Formatter, self: .FunctionHandle) {
    $fmt "(FunctionHandle " Fmt:write
    $fmt $self.module.index i32-format
    $fmt " " Fmt:write
    $fmt $self.index i32-format
    $fmt " " Fmt:write
    $fmt $self.instance i32-format
    $fmt ")" Fmt:write
}
fn FunctionHandle-eq(self: .FunctionHandle, other: .FunctionHandle) -> bool {
    $self.module.index $other.module.index =
    $self.index $other.index = and
    $self.instance $other.instance = and
}

// =============================================================================
//  Output of Monomorphization pass
// =============================================================================

struct Monomized {
    types: Array<Maybe<Key>>
    modules: Map<ByteSlice, Module>
    sizes: Array<i32>
    function-table: Array<FunctionHandle>
}
fn Monomized-format(fmt: .Formatter, self: .Monomized) {
    $fmt "(Monomized\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "types=" Fmt:write
    $fmt \MaybeKey-format &self.types Array:format-multi-line<Maybe<Key>>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "sizes=" Fmt:write
    $fmt \i32-format-ref &self.sizes Array:format<i32>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "modules=" Fmt:write
    $fmt \ByteSlice-format \Module-format &self.modules Map:format-multi-line<ByteSlice, Module>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "function-table=" Fmt:write
    $fmt \FunctionHandle-format &self.function-table Array:format<FunctionHandle>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

variant ExternOrInstances {
    case Extern -> Extern
    case Instances -> Array<.Function>
}
fn ExternOrInstances-format(fmt: .Formatter, self: .ExternOrInstances) {
    $fmt $self match {
        case Extern -> { Extern-format }
        case Instances -> { \Function-ref-format flip Array:format-multi-line<.Function> }
    }
}

struct Module {
    custom-types: Array<CustomType>
    globals: Array<Global>
    static-data: ByteSlice
    functions: Array<ExternOrInstances>
}
fn Module-format(fmt: .Formatter, self: .Module) {
    $fmt "(Module\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "custom-types=" Fmt:write
    $fmt \CustomType-format &self.custom-types Array:format-multi-line<CustomType>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "globals=" Fmt:write
    $fmt \Global-format &self.globals Array:format-multi-line<Global>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "functions=" Fmt:write
    $fmt \ExternOrInstances-format &self.functions Array:format-multi-line<ExternOrInstances>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}


// =============================================================================
//  Context for monomorphization
// =============================================================================

variant ExternOrInstancesMap {
    case Instances -> Map<Array<TypeId>, .Maybe<Function>>
    case Extern -> Extern
}

struct Ctx {
    arena: .Arena
    module-id: ModuleId
    modules: .Array<Checked:Module>
    types: .Array<Maybe<Key>>
    function-table: .Array<FunctionHandle>
    custom-types: Array<CustomType>
    functions: .Array<Array<ExternOrInstancesMap>>
}
fn insert-extrn(ctx: .Ctx, handle: Resolved:FunctionHandle, extrn: Extern) {
    loop {
        $ctx.functions.len $handle.module.index gt if { break }
        $ctx.arena $ctx.functions
        Array:new<ExternOrInstancesMap>
        Array:push<Array<ExternOrInstancesMap>>
    }
    $ctx.functions $handle.module.index Array:get<Array<ExternOrInstancesMap>> @module-functions
    loop {
        $module-functions.len $handle.index gt if { break }
        $ctx.arena $module-functions
        \TypeIds-eq Map:new<Array<TypeId>, .Maybe<Function>>
        make ExternOrInstancesMap.Instances
        Array:push<ExternOrInstancesMap>
    }
    $module-functions $handle.index
    $extrn make ExternOrInstancesMap.Extern
    Array:set<ExternOrInstancesMap> drop
}
fn pre-insert-function(ctx: .Ctx, handle: Resolved:FunctionHandle, generic-arguments: Array<TypeId>) -> .Maybe<Function>, i32 {
    $ctx.arena make Maybe<Function>.None Arena:push<Maybe<Function>> @slot
    loop {
        $ctx.functions.len $handle.module.index gt if { break }
        $ctx.arena $ctx.functions
        Array:new<ExternOrInstancesMap>
        Array:push<Array<ExternOrInstancesMap>>
    }
    $ctx.functions $handle.module.index Array:get<Array<ExternOrInstancesMap>> @module-functions

    loop {
        $module-functions.len $handle.index gt if { break }
        $ctx.arena $module-functions
        \TypeIds-eq Map:new<Array<TypeId>, .Maybe<Function>>
        make ExternOrInstancesMap.Instances
        Array:push<ExternOrInstancesMap>
    }
    $module-functions $handle.index Array:get<ExternOrInstancesMap> match {
        case ExternOrInstancesMap.Instances -> {}
        case ExternOrInstancesMap.Extern -> { drop Core:unreachable<.Map<Array<TypeId>, .Maybe<Function>>> }
    } @instances

    $instances.values.len
    $ctx.arena $instances $generic-arguments $slot Map:insert<Array<TypeId>, .Maybe<Function>> drop
    $slot flip
}
fn lookup-function(ctx: .Ctx, handle: Resolved:FunctionHandle, generic-arguments: .Array<TypeId>) -> Maybe<i32> { block {
    $ctx.functions.len $handle.module.index le if { make Maybe<i32>.None break }
    $ctx.functions $handle.module.index Array:get<Array<ExternOrInstancesMap>> @module-functions

    $module-functions.len $handle.index le if { make Maybe<i32>.None break }
    $module-functions $handle.index Array:get<ExternOrInstancesMap> match {
        case ExternOrInstancesMap.Extern -> { drop Core:unreachable<.Map<Array<TypeId>, .Maybe<Function>>> }
        case ExternOrInstancesMap.Instances -> {}
    } @instances

    $instances $generic-arguments Map:get-index<Array<TypeId>, .Maybe<Function>>
} }
fn lookup-checked-function(ctx: .Ctx, handle: Resolved:FunctionHandle) -> .Checked:FunctionOrExtern {
    $ctx.modules $handle.module.index Array:get<Checked:Module>
    .functions $handle.index Array:get<Checked:FunctionOrExtern>
}
fn insert-into-function-table(ctx: .Ctx, handle: FunctionHandle) -> i32 {
    $ctx.function-table \FunctionHandle-eq  &handle Array:find<FunctionHandle, .FunctionHandle> 
    if {} else {
        drop
        $ctx.function-table.len
        $ctx.arena $ctx.function-table $handle Array:push<FunctionHandle>
    }
}
fn lookup-type(ctx: .Ctx, type: TypeId) -> .Type {
    $ctx.types $type.index Array:get<Maybe<Key>> match {
        case None -> { Core:unreachable<.Type> }
        case Some -> { Key-type }
    }
}

struct PrimitiveTypes { a: Maybe<Key> b: Maybe<Key> c: Maybe<Key> d: Maybe<Key> }
global PRIMITIVE_TYPES: PrimitiveTypes

fn primitive-types() -> Array<Maybe<Key>> {
    uninit<PrimitiveTypes> @zeroed
    &zeroed !.i8 0 !i8 sizeof(PrimitiveTypes) mem-fill
    &PRIMITIVE_TYPES !.i8 &zeroed !.i8 sizeof(PrimitiveTypes) Core:bytes-eq if {
        make Type.Bool make Key.Other make Maybe<Key>.Some #PRIMITIVE_TYPES.a
        make Type.I8   make Key.Other make Maybe<Key>.Some #PRIMITIVE_TYPES.b
        make Type.I32  make Key.Other make Maybe<Key>.Some #PRIMITIVE_TYPES.c
        make Type.I64  make Key.Other make Maybe<Key>.Some #PRIMITIVE_TYPES.d
    }
    &PRIMITIVE_TYPES.a sizeof(PrimitiveTypes) sizeof(Maybe<Key>) / Array:init-no-copy<Maybe<Key>>
}

fn Bool-id() -> TypeId { 0 make TypeId }
fn I8-id () -> TypeId { 1 make TypeId }
fn I32-id () -> TypeId { 2 make TypeId }
fn I64-id () -> TypeId { 3 make TypeId }

fn local-lives-in-memory(sizes: .Array<i32>, local: .Local) -> bool {
    $sizes $local.type can-live-in-reg not
    $local.reffed or
}
fn globl-lives-in-memory(sizes: .Array<i32>, globl: .Global) -> bool {
    $sizes $globl.type can-live-in-reg not
    $globl.reffed or
}

// =============================================================================
//  Type monomorphization procedures
// =============================================================================

struct CustomTypeKey {
    handle: CustomTypeHandle
    generic-arguments: Array<TypeId>
    type: Maybe<Type>
}
fn CustomTypeKey-eq(a: .CustomTypeKey, b: .CustomTypeKey) -> bool {
    &a.handle &b.handle Checked:CustomTypeHandle-eq
    \TypeId-eq &a.generic-arguments &b.generic-arguments Array:eq<TypeId> and
}
fn CustomTypeKey-format(fmt: .Formatter, self: .CustomTypeKey) {
    $fmt "(CustomTypeKey " Fmt:write
    &self.type match {
        case Some -> { $fmt flip Type-format }
        case None -> {
            $fmt &self.handle Checked:CustomTypeHandle-format
            $fmt " " Fmt:write
            $fmt \TypeId-format &self.generic-arguments Array:format<TypeId>
        }
    }
    $fmt ")" Fmt:write
}
variant Key {
    case CustomType -> CustomTypeKey
    case Other -> Type
}
fn Key-type(self: .Key) -> .Type {
    $self match {
        case CustomType -> { .type Maybe:ref<Type> Maybe:assert-some<.Type> }
        case Other -> {}
    }
}

fn Key-eq(a: .Key, b: .Key) -> bool {
    $a match {
        case CustomType -> { $b match {
            case CustomType -> { CustomTypeKey-eq }
            case Other -> { drop drop 0 1 = }
        } }
        case Other -> { $b match {
            case Other -> { Type-eq }
            case CustomType -> { drop drop 0 1 = }
        } }
    }
}
fn Key-format(fmt: .Formatter, self: .Key) {
    $fmt $self match {
        case CustomType -> { CustomTypeKey-format }
        case Other -> { Type-format }
    }
}
fn MaybeKey-format(fmt: .Formatter, self: .Maybe<Key>) {
    $fmt \Key-format $self Maybe:format<Key>
}
fn monomize-type(ctx: .Ctx, type: .Checked:Type, generic-arguments: .Array<TypeId>) -> TypeId { block {
    $type match {
        case Checked:Type.Bool -> { Bool-id break }
        case Checked:Type.I8 -> { I8-id break }
        case Checked:Type.I32 -> { I32-id break }
        case Checked:Type.I64 -> { I64-id break }
        case Checked:Type.Generic -> { .index ~ $generic-arguments flip Array:get<TypeId> ~ break }
        case Checked:Type.Hole -> { drop 0 0 / drop }
        case _ -> { drop }
    }

    $ctx.types.len make TypeId @type-id
    $ctx.arena $ctx.types make Maybe<Key>.None Array:push<Maybe<Key>>

    $type match {
        case Checked:Type.Ptr -> {
            $ctx flip ~ $generic-arguments monomize-type make Type.Ptr make Key.Other
        }
        case Checked:Type.Tuple -> {
            $ctx flip .items $generic-arguments monomize-types make Type.Tuple make Key.Other
        }
        case Checked:Type.Fun -> {
            @fun-type
            $ctx &fun-type.parameters $generic-arguments monomize-types
            $ctx &fun-type.returns    $generic-arguments monomize-types
            make FunType make Type.Fun make Key.Other
        }
        case Checked:Type.Custom -> {
            @custom-type
            $custom-type.type-definition
            $ctx &custom-type.generic-arguments $generic-arguments monomize-types
            make Maybe<Type>.None
            make CustomTypeKey make Key.CustomType
        }
        case _ -> { $ctx flip $generic-arguments monomize-type break }
    } @key
    $ctx.types \cmp-perhaps-empty-type-slot &key Array:find<Maybe<Key>, .Key> if {
        $ctx.types.len $type-id.index 1 + = if {
            $ctx.types Array:pop<Maybe<Key>> assert-none<Key>
        }
        make TypeId
    } else {
        drop
        $ctx.types $type-id.index $key make Maybe<Key>.Some Array:set<Maybe<Key>> drop
        &key match {
            case CustomType -> {
                @key
                $type match {
                    case Checked:Type.Custom -> {
                        $ctx flip &key.generic-arguments monomize-custom-type
                        make Type.Custom make Maybe<Type>.Some @type

                        $ctx.types $type-id.index Array:get<Maybe<Key>> Maybe:ref<Key> Maybe:assert-some<.Key> match {
                            case CustomType -> { .type $type store }
                            case _ -> { drop 0 0 / drop }
                        }
                    }
                    case _ -> { drop 0 0 / drop }
                }
            }
            case _ -> { drop }
        }
        $type-id
    }
} }

fn monomize-fun-type(ctx: .Ctx, fun-type: .Checked:FunType, generic-arguments: .Array<TypeId>) -> TypeId {
    $fun-type ~ make Checked:Type.Fun @type
    $ctx &type $generic-arguments monomize-type
}

fn cmp-perhaps-empty-type-slot(slot: .Maybe<Key>, type: .Key) -> bool {
    $slot match {
        case None -> { 0 1 = }
        case Some -> { $type Key-eq }
    }
}

fn monomize-types(ctx: .Ctx, types: .Array<Checked:Type>, generic-arguments: .Array<TypeId>) -> Array<TypeId> { block {
    $ctx.arena $types.len Array:new-with-capacity<TypeId> @monomized
    loop {
        $monomized.len $types.len = if { $monomized break }
        &monomized
        $ctx $types $monomized.len Array:get<Checked:Type> $generic-arguments monomize-type
        Array:push-assert-no-alloc<TypeId>
    }
} }

fn monomize-custom-type'(ctx: .Ctx, custom-type: .Checked:CustomTypeType, generic-arguments: .Array<TypeId>) -> TypeId {
    $custom-type ~ make Checked:Type.Custom @type
    $ctx &type $generic-arguments monomize-type
}
fn monomize-custom-type(
    ctx: .Ctx,
    custom-type: .Checked:CustomTypeType,
    generic-arguments: .Array<TypeId>
) -> CustomTypeHandle {
    $ctx.modules $custom-type.type-definition.module.index Array:get<Checked:Module> .type-definitions
    $custom-type.type-definition.index Array:get<Resolved:TypeDefinition> @resolved-custom-type

    $resolved-custom-type match {
        case Resolved:TypeDefinition.Struct -> {
            @resolved-struct
            $resolved-struct.name
            $ctx &resolved-struct.fields $generic-arguments monomize-named-types @fields
            $fields
            0 !.[] $ctx.arena $fields.len Array:new-with-capacity<i32>
            make Struct make CustomType.Struct $ctx flip add-monomized-custom-type
        }
        case Resolved:TypeDefinition.Variant -> {
            @resolved-variant
            $resolved-variant.name
            $ctx.arena $resolved-variant.cases.len Array:new-with-capacity<VariantCase> @monomized-cases
            loop {
                $monomized-cases.len $resolved-variant.cases.len = if { $monomized-cases break }
                &monomized-cases
                &resolved-variant.cases $monomized-cases.len Array:get<Resolved:VariantCase> @resolved-case
                $resolved-case.name
                &resolved-case.type match {
                    case None -> { make Maybe<TypeId>.None }
                    case Some -> {
                        $ctx flip $generic-arguments monomize-type make Maybe<TypeId>.Some
                    }
                }
                make VariantCase
                Array:push-assert-no-alloc<VariantCase>
            }
            make Variant make CustomType.Variant $ctx flip add-monomized-custom-type
        }
    }
}

fn add-monomized-custom-type(ctx: .Ctx, type: CustomType) -> CustomTypeHandle {
    &ctx.custom-types \CustomType-eq &type Array:find<CustomType, .CustomType> if {
        $ctx.module-id flip make CustomTypeHandle
    } else {
        drop
        $ctx.module-id $ctx.custom-types.len make CustomTypeHandle
        $ctx.arena &ctx.custom-types $type Array:push<CustomType>
    }
}

fn monomize-named-types(ctx: .Ctx, types: .Array<Checked:NamedType>, generic-arguments: .Array<TypeId>) -> Array<NamedTypeId> {
    $ctx.arena $types.len Array:new-with-capacity<NamedTypeId> @monomized
    loop {
        $monomized.len $types.len = if { $monomized break }
        &monomized
        $ctx $types $monomized.len Array:get<Checked:NamedType> $generic-arguments monomize-named-type
        Array:push-assert-no-alloc<NamedTypeId>
    }
}

fn monomize-named-type(ctx: .Ctx, type: .Checked:NamedType, generic-arguments: .Array<TypeId>) -> NamedTypeId {
    $type.name
    $ctx &type.type $generic-arguments monomize-type
    make NamedTypeId
}


// =============================================================================
//  Top level monomorphization procedures
// =============================================================================

fn monomize(arena: .Arena, modules: .Map<ByteSlice, Checked:Module>) -> Monomized {
    \ByteSlice:eq-by-ref Map:new<ByteSlice, Module> @monomized-modules
    Array:new<Array<ExternOrInstancesMap>> @functions
    primitive-types @types
    Array:new<FunctionHandle> @function-table
    0 @i
    loop {
        $i $modules.values.len = if { break }
        &modules.values $i Array:get<Checked:Module> @module
        make Ctx {
            $arena @arena
            $i make ModuleId @module-id
            &modules.values @modules
            &types @types
            &function-table @function-table
            Array:new<CustomType> @custom-types
            &functions @functions
            make Maybe<CustomTypeHandle>.None @struc-env
            make Maybe<.Map<LocalId, Local>>.None @locals
        } @ctx


        $arena &monomized-modules
        &modules.keys $i Array:get<ByteSlice> ~
        make Module {
            &ctx &module.functions monomize-functions
            &ctx &module.globals monomize-globals @globals
            $ctx.custom-types @custom-types
            $arena $module.static-data ByteSlice:copy @static-data
            Array:new<ExternOrInstances> @functions
        }
        Map:insert<ByteSlice, Module> drop
        $i 1 + #i
    }
    0 @i
    loop {
        $i $monomized-modules.values.len = if { break }
        &monomized-modules.values $i Array:get<Module> .functions @module-functions

        $i $functions.len lt if {
            &monomized-modules.values $i Array:get<Module> .functions @module-functions
            &functions $i Array:get<Array<ExternOrInstancesMap>> @functions

            0 @j
            loop {
                $functions.len $j = if { break }

                loop {
                    $module-functions.len $j gt if { break }
                    $arena $module-functions
                    Array:new<.Function> make ExternOrInstances.Instances
                    Array:push<ExternOrInstances>
                }

                $functions $j Array:get<ExternOrInstancesMap> match {
                    case ExternOrInstancesMap.Instances -> {
                        .values @instances

                        $module-functions $j Array:get<ExternOrInstances> match {
                            case Instances -> {}
                            case Extern -> { drop Core:unreachable<.Array<.Function>> }
                        } @target

                        0 @k
                        loop {
                            $instances.len $k = if { break }

                            $arena $target
                            $instances $k Array:get<.Maybe<Function>> ~ Maybe:ref<Function> Maybe:assert-some<.Function>
                            Array:push<.Function>
                            $k 1 + #k
                        }
                    }
                    case ExternOrInstancesMap.Extern -> {
                        $module-functions flip $j flip
                        ~ make ExternOrInstances.Extern
                        Array:set<ExternOrInstances> drop
                    }
                }
                $j 1 + #j
            }
        }
        $i 1 + #i
    }
    $types $monomized-modules
    Logging:enabled if {
        2 "Calculating type sizes\n" IO:write-all IO:check
    }
    $arena &monomized-modules &types compute-sizes @sizes
    &monomized-modules &sizes &types measure-copy-space
    $sizes $function-table make Monomized
}

fn monomize-globals(ctx: .Ctx, globals: .Array<Resolved:Global>) -> Array<Global> {
    $ctx.arena $globals.len Array:new-with-capacity<Global> @monomized
    0 @i
    loop {
        $i $globals.len = if { $monomized break }
        $globals $i Array:get<Resolved:Global> @globl
        &monomized $ctx $globl monomize-globl Array:push-assert-no-alloc<Global>
        $i 1 + #i
    }
}

fn monomize-globl(ctx: .Ctx, globl: .Resolved:Global) -> Global {
    Array:new<TypeId> @generic-arguments
    $globl.name $ctx &globl.type &generic-arguments monomize-type $globl.reffed make Global
}

fn monomize-extrn(ctx: .Ctx, extrn: .Resolved:Extern) -> Extern {
    Array:new<TypeId> @generic-arguments
    make Extern {
        $extrn.name @name
        $extrn.extrn-module @extrn-module
        $extrn.extrn-name @extrn-name
        $ctx &extrn.signature &generic-arguments monomize-signature @signature
    }
}

struct WordCtx {
    ctx: .Ctx
    locals: .Map<LocalId, Local>
    struc-env: Maybe<CustomTypeHandle>
}

fn monomize-function(ctx: .Ctx, function: .Checked:Function, generic-arguments: .Array<TypeId>) -> Function {
    $ctx &function.locals $generic-arguments monomize-locals @locals

    $ctx &locals make Maybe<CustomTypeHandle>.None make WordCtx @ctx

    $function.name $function.export
    $ctx.ctx &function.signature $generic-arguments monomize-signature
    $locals
    0 not
    0 not
    &ctx &function.body $generic-arguments monomize-scope
    $generic-arguments ~
    make Function
}

fn mark-var-reffed(ctx: .WordCtx, var: .VarId) {
    $var match {
        case VarId.Local -> {
            $ctx.locals flip Map:get<_, _> Maybe:assert-some<_>
            .reffed 1 1 = store
        }
        case VarId.Global -> {
            @global-id
            $ctx.ctx.modules $global-id.module.index Array:get<_>
            .globals $global-id.index Array:get<_>
            .reffed 1 1 = store
        }
    }
}

fn monomize-locals(ctx: .Ctx, locals: .Map<LocalId, Checked:Local>, generic-arguments: .Array<TypeId>) -> Map<LocalId, Local> {
    $ctx.arena \LocalId-eq $locals.values.len Map:new-with-capacity<LocalId, Local> @monomized
    0 @i
    loop {
        $i $locals.values.len = if { $monomized break }

        &monomized.keys
        &locals.keys $i Array:get<LocalId> ~
        Array:push-assert-no-alloc<LocalId>

        &monomized.values
        $ctx &locals.values $i Array:get<Checked:Local> $generic-arguments monomize-local
        Array:push-assert-no-alloc<Local>

        $i 1 + #i
    }
}

fn monomize-local(ctx: .Ctx, local: .Checked:Local, generic-arguments: .Array<TypeId>) -> Local {
    make Local {
        $local.name @name
        $ctx &local.type $generic-arguments monomize-type @type
        0 1 = @reffed
        $local.is-parameter @is-parameter
    }
}

fn monomize-functions(ctx: .Ctx, functions: .Array<Checked:FunctionOrExtern>) {
    0 @i
    loop {
        $i $functions.len = if { break }
        $functions $i Array:get<Checked:FunctionOrExtern>
        $ctx.module-id $i make Resolved:FunctionHandle @handle
        match {
            case Checked:FunctionOrExtern.Extern -> {
                $ctx flip monomize-extrn
                $ctx flip $handle flip insert-extrn
            }
            case Checked:FunctionOrExtern.Function -> {
                @function
                &function.export Maybe:is-some<Token> if {
                    Array:new<TypeId> @generic-arguments
                    $ctx $handle $generic-arguments pre-insert-function drop @slot
                    $ctx $function &generic-arguments monomize-function make Maybe<Function>.Some =>slot
                }
            }
        }
        $i 1 + #i
    }
}

fn monomize-signature(ctx: .Ctx, extrn: .Resolved:Signature, generic-arguments: .Array<TypeId>) -> Signature {
    make Signature {
        $ctx &extrn.parameters $generic-arguments monomize-named-types @parameters
        $ctx &extrn.returns    $generic-arguments monomize-types       @returns
    }
}


// =============================================================================
//  Compute size of all types after monomorphization.
// =============================================================================

fn compute-sizes(arena: .Arena, modules: .Map<ByteSlice, Module>, types: .Array<Maybe<Key>>) -> Array<i32> {
    $arena $types.len Arena:alloc-many<i32> $types.len Array:init-no-copy<i32> @sizes
    $sizes.ptr !.i8 255 !i8 $types.len sizeof(i32) * mem-fill
    0 @i
    loop {
        $i $types.len = if { $sizes break }
        $modules &sizes $types $i compute-size
        $i 1 + #i
    }
}

fn compute-size(modules: .Map<ByteSlice, Module>, sizes: .Array<i32>, types: .Array<Maybe<Key>>, index: i32) {
    $sizes $index Array:get<i32> ~ 0 not = if {
        $types $index Array:get<Maybe<Key>> match {
            case None -> { 0 not 1 - }
            case Some -> {
                Key-type match {
                    case Ptr -> { drop 4 }
                    case Bool -> { 4 }
                    case I8 -> { 1 }
                    case I32 -> { 4 }
                    case I64 -> { 8 }
                    case Custom -> {
                        @handle
                        $modules $sizes $types
                        &modules.values $handle.module.index Array:get<Module> .custom-types
                        $handle.index Array:get<CustomType> compute-custom-type-size
                    }
                    case Tuple -> {
                        @items 0 @size 0 @i
                        loop {
                            $i $items.len = if { $size break }
                            $modules $sizes $types $items $i Array:get<TypeId> ~ compute-typeid-size $size + #size
                            $i 1 + #i
                        }
                    }
                    case Fun -> { drop 4 }
                }
            }
        } @size
        $sizes $index $size Array:set<i32> drop
    }
}

fn compute-typeid-size(modules: .Map<ByteSlice, Module>, sizes: .Array<i32>, types: .Array<Maybe<Key>>, type: TypeId) -> i32 {
    $sizes $type.index Array:get<i32> ~ @size
    $size 0 not = if {
        $modules $sizes $types $type.index compute-size
        $modules $sizes $types $type compute-typeid-size
    } else {
        $size
    }
}

fn compute-custom-type-size(modules: .Map<ByteSlice, Module>, sizes: .Array<i32>, types: .Array<Maybe<Key>>, type: .CustomType) -> i32 {
    $modules $sizes $types $type match {
        case CustomType.Struct -> { compute-struc-size }
        case CustomType.Variant -> { compute-varint-size }
    }
}

fn compute-struc-size(modules: .Map<ByteSlice, Module>, sizes: .Array<i32>, types: .Array<Maybe<Key>>, struc: .Struct) -> i32 {
    0 @size
    0 @i
    0 @largest-field
    loop {
        $i $struc.fields.len = if { $size $largest-field Core:align-to break }
        $modules $sizes $types
        &struc.fields $i Array:get<NamedTypeId> .type ~ compute-typeid-size @field-size
        $largest-field $field-size Core:max #largest-field
        $size $field-size + #size

        $i 1 + $struc.fields.len lt if {
            $modules $sizes $types &struc.fields $i 1 + Array:get<NamedTypeId>.type ~ compute-typeid-size @next-field-size

            $size $next-field-size 4 Core:min Core:align-to #size
        }
        $i 1 + #i
    }
}

fn compute-varint-size(modules: .Map<ByteSlice, Module>, sizes: .Array<i32>, types: .Array<Maybe<Key>>, varint: .Variant) -> i32 {
    0 @size
    0 @i
    loop {
        $i $varint.cases.len = if { $size 4 + break }
        &varint.cases $i Array:get<VariantCase> .type match {
            case None -> { 0 }
            case Some -> { ~ $modules flip $sizes flip $types flip compute-typeid-size }
        } $size Core:max #size
        $i 1 + #i
    }
}


// =============================================================================
//  Monomorphized Words
// =============================================================================

struct GetLocal {
    name: Token
    var: VarId
    fields: Array<FieldAccess>
    result-type: TypeId
    copy-space-offset: i32
}
fn GetLocal-format(fmt: .Formatter, self: .GetLocal) {
    $fmt "(GetLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt &self.result-type TypeId-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt " " Fmt:write
    $fmt $self.copy-space-offset i32-format
    $fmt ")" Fmt:write
}

struct SetLocal {
    name: Token
    var: VarId
    fields: Array<FieldAccess>
    target-type: TypeId
}
fn SetLocal-format(fmt: .Formatter, self: .SetLocal) {
    $fmt "(SetLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt " " Fmt:write
    $fmt &self.target-type TypeId-format
    $fmt ")" Fmt:write
}

struct RefLocal {
    name: Token
    var: VarId
    fields: Array<FieldAccess>
}
fn RefLocal-format(fmt: .Formatter, self: .RefLocal) {
    $fmt "(RefLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt ")" Fmt:write
}

struct StoreLocal {
    name: Token
    var: VarId
    type: TypeId
    fields: Array<FieldAccess>
}
fn StoreLocal-format(fmt: .Formatter, self: .StoreLocal) {
    $fmt "(StoreLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt ")" Fmt:write
}

struct InitLocal {
    name: Token
    type: TypeId
    local: LocalId
}
fn InitLocal-format(fmt: .Formatter, self: .InitLocal) {
    $fmt "(InitLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt &self.local LocalId-format
    $fmt ")" Fmt:write
}

struct GetField {
    token: Token
    fields: Array<FieldAccess>
    type: TypeId
    on-ptr: bool
    copy-space-offset: i32
}
fn GetField-format(fmt: .Formatter, self: .GetField) {
    $fmt "(GetField " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format<FieldAccess>
    $fmt " " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.on-ptr bool-format
    $fmt " " Fmt:write
    $fmt $self.copy-space-offset i32-format
    $fmt ")" Fmt:write
}

struct FieldAccess {
    name: Token
    source-type: TypeId
    target-type: TypeId
    field-index: i32
}
fn FieldAccess-format(fmt: .Formatter, self: .FieldAccess) {
    $fmt "(FieldAccess " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.source-type TypeId-format
    $fmt " " Fmt:write
    $fmt &self.target-type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.field-index i32-format
    $fmt ")" Fmt:write
}

struct Cast {
    token: Token
    src: TypeId
    dst: TypeId
}
fn Cast-format(fmt: .Formatter, self: .Cast) {
    $fmt "(Cast " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.src TypeId-format
    $fmt " " Fmt:write
    $fmt &self.dst TypeId-format
    $fmt ")" Fmt:write
}

struct Call {
    name: Token
    function: FunctionHandle
    copy-space-offset: i32
}
fn Call-format(fmt: .Formatter, self: .Call) {
    $fmt "(Call " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.function FunctionHandle-format
    $fmt " " Fmt:write
    $fmt $self.copy-space-offset i32-format
    $fmt ")" Fmt:write
}

variant Intrinsic {
    case Gt -> TypeId
    case Lt -> TypeId
    case Add -> TypeId
    case Sub -> TypeId
    case Mul -> TypeId
    case Div -> TypeId
    case Mod -> TypeId
    case Eq -> TypeId
    case NotEq -> TypeId
    case MemGrow
    case MemCopy
    case MemFill
    case Shl -> TypeId
    case Shr -> TypeId
    case Rotl -> TypeId
    case Rotr -> TypeId
    case And -> TypeId
    case Or -> TypeId
    case Ge -> TypeId
    case Le -> TypeId
    case Not -> TypeId
    case Store -> TypeId
    case Drop -> TypeId
    case SetStackSize
}
fn Intrinsic-format(fmt: .Formatter, self: .Intrinsic) {
    $self match {
        case Gt -> { $fmt "(Gt " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Lt -> { $fmt "(Lt " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Add -> { $fmt "(Add " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Sub -> { $fmt "(Sub " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Mul -> { $fmt "(Mul " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Div -> { $fmt "(Div " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Mod -> { $fmt "(Mod " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Eq -> { $fmt "(Eq " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case NotEq -> { $fmt "(NotEq " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case MemGrow -> { $fmt "MemGrow" Fmt:write }
        case MemCopy -> { $fmt "MemCopy" Fmt:write }
        case MemFill -> { $fmt "MemFill" Fmt:write }
        case Shl -> { $fmt "(Shl " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Shr -> { $fmt "(Shr " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Rotl -> { $fmt "(Rotl " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Rotr -> { $fmt "(Rotr " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case And -> { $fmt "(And " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Or -> { $fmt "(Or " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Ge -> { $fmt "(Ge " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Le -> { $fmt "(Le " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Not -> { $fmt "(Not " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Store -> { $fmt "(Store " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Drop -> { $fmt "(Drop " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case SetStackSize -> { $fmt "SetStackSize" Fmt:write }
    }
}

struct IntrinsicWord {
    token: Token
    intrinsic: Intrinsic
}
fn IntrinsicWord-format(fmt: .Formatter, self: .IntrinsicWord) {
    $fmt "(Intrinsic " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.intrinsic Intrinsic-format
    $fmt ")" Fmt:write
}

struct If {
    token: Token
    parameters: Array<TypeId>
    returns: Maybe<Array<TypeId>>
    true-branch: Scope
    false-branch: Scope
}
fn If-format(fmt: .Formatter, self: .If) {
    $fmt "(If\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt &self.parameters TypeIds-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt \TypeIds-format &self.returns Maybe:format<Array<TypeId>>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "true-branch=" Fmt:write
    $fmt &self.true-branch Scope-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "false-branch=" Fmt:write
    $fmt &self.false-branch Scope-format
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct Loop {
    token: Token
    parameters: Array<TypeId>
    returns: Maybe<Array<TypeId>>
    body: Scope
}
fn Loop-format(fmt: .Formatter, self: .Loop) {
    $fmt "(Loop\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt &self.parameters TypeIds-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt \TypeIds-format &self.returns Maybe:format<Array<TypeId>>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "body=" Fmt:write
    $fmt &self.body Scope-format
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct Block {
    token: Token
    parameters: Array<TypeId>
    returns: Array<TypeId>
    body: Scope
}
fn Block-format(fmt: .Formatter, self: .Block) {
    $fmt "(Block\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt &self.parameters TypeIds-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt &self.returns TypeIds-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "body=" Fmt:write
    $fmt &self.body Scope-format
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct MatchCase {
    type: Maybe<TypeId>
    tag: i32
    body: Scope
}
fn MatchCase-format(fmt: .Formatter, self: .MatchCase) {
    $fmt "(MatchCase " Fmt:write
    $fmt \TypeId-format &self.type Maybe:format<TypeId>
    $fmt " " Fmt:write
    $fmt $self.tag i32-format
    $fmt " " Fmt:write
    $fmt &self.body Scope-format
    $fmt ")" Fmt:write
}
struct Match {
    type: TypeId
    by-ref: bool
    cases: Array<MatchCase>
    default: Maybe<Scope>
    parameters: Array<TypeId>
    returns: Maybe<Array<TypeId>>
}
fn Match-format(fmt: .Formatter, self: .Match) {
    $fmt "(Match\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "type=" Fmt:write
    $fmt &self.type TypeId-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "by-ref=" Fmt:write
    $fmt $self.by-ref bool-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "cases=" Fmt:write
    $fmt \MatchCase-format &self.cases Array:format-multi-line<MatchCase>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "default=" Fmt:write
    $fmt \Scope-format &self.default Maybe:format<Scope>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt &self.parameters TypeIds-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt \TypeIds-format &self.returns Maybe:format<Array<TypeId>>
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct StructWord {
    type: TypeId
    copy-space-offset: i32
}
fn StructWord-format(fmt: .Formatter, self: .StructWord) {
    $fmt "(StructWord " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.copy-space-offset i32-format
    $fmt ")" Fmt:write
}

struct StructWordNamed {
    type: TypeId
    body: Scope
    copy-space-offset: i32
}
fn StructWordNamed-format(fmt: .Formatter, self: .StructWordNamed) {
    $fmt "(StructWordNamed " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.copy-space-offset i32-format
    $fmt " " Fmt:write
    $fmt &self.body Scope-format
    $fmt ")" Fmt:write
}


struct VariantWord {
    tag: i32
    type: TypeId
    copy-space-offset: i32
}
fn VariantWord-format(fmt: .Formatter, self: .VariantWord) {
    $fmt "(VariantWord " Fmt:write
    $fmt $self.tag i32-format
    $fmt " " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.copy-space-offset i32-format
    $fmt ")" Fmt:write
}

struct FunRef {
    call: Call
    table-index: i32
}
fn FunRef-format(fmt: .Formatter, self: .FunRef) {
    $fmt "(FunRef " Fmt:write
    $fmt &self.call Call-format
    $fmt " " Fmt:write
    $fmt $self.table-index i32-format
    $fmt ")" Fmt:write
}

struct Uninit {
    type: TypeId
    copy-space-offset: i32
}
fn Uninit-format(fmt: .Formatter, self: .Uninit) {
    $fmt "(Uninit " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.copy-space-offset i32-format
    $fmt ")" Fmt:write
}

struct Load {
    type: TypeId
    copy-space-offset: i32
}
fn Load-format(fmt: .Formatter, self: .Load) {
    $fmt "(Load " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.copy-space-offset i32-format
    $fmt ")" Fmt:write
}

struct FieldInit {
    struc: CustomTypeHandle
    type: TypeId
    field-index: i32
    copy-space-offset: i32
}
fn FieldInit-format(fmt: .Formatter, self: .FieldInit) {
    $fmt "(FieldInit " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.field-index i32-format
    $fmt " " Fmt:write
    $fmt $self.copy-space-offset i32-format
    $fmt ")" Fmt:write
}

struct IndirectCall {
    type: TypeId
    copy-space-offset: i32
}
fn IndirectCall-format(fmt: .Formatter, self: .IndirectCall) {
    $fmt "(IndirectCall " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.copy-space-offset i32-format
    $fmt ")" Fmt:write
}

struct MakeTuple {
    type: TypeId
    copy-space-offset: i32
}
fn MakeTuple-format(fmt: .Formatter, self: .MakeTuple) {
    $fmt "(MakeTuple " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.copy-space-offset i32-format
    $fmt ")" Fmt:write
}

struct UnpackTuple {
    type: TypeId
    copy-space-offset: i32
}
fn UnpackTuple-format(fmt: .Formatter, self: .UnpackTuple) {
    $fmt "(UnpackTuple " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.copy-space-offset i32-format
    $fmt ")" Fmt:write
}

struct Flip {
    token: Token
    lower: TypeId
    upper: TypeId
}
fn Flip-format(fmt: .Formatter, self: .Flip) {
    $fmt "(Flip " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.lower TypeId-format
    $fmt " " Fmt:write
    $fmt &self.upper TypeId-format
    $fmt ")" Fmt:write
}

variant Word {
    case Number -> Token
    case String -> StringWord
    case GetLocal -> GetLocal
    case InitLocal -> InitLocal
    case SetLocal -> SetLocal
    case RefLocal -> RefLocal
    case StoreLocal -> StoreLocal
    case Cast -> Cast
    case Call -> Call
    case Intrinsic -> IntrinsicWord
    case If -> If
    case Loop -> Loop
    case Flip -> Flip
    case Break -> Token
    case Block -> Block
    case Sizeof -> TypeId
    case Uninit -> Uninit
    case FieldInit -> FieldInit
    case Load -> Load
    case MakeTuple -> MakeTuple
    case UnpackTuple -> UnpackTuple
    case IndirectCall -> IndirectCall
    case GetField -> GetField
    case FunRef -> FunRef
    case Match -> Match
    case MatchVoid -> Token
    case Struct -> StructWord
    case StructNamed -> StructWordNamed
    case Variant -> VariantWord
}
fn Word-format(fmt: .Formatter, self: .Word) { block {
    $fmt $self match {
        case Word.Number -> { $fmt "(Number " Fmt:write Token-format $fmt ")" }
        case Word.String -> { StringWord-format break }
        case Word.GetLocal -> { GetLocal-format break }
        case Word.InitLocal -> { InitLocal-format break }
        case Word.SetLocal -> { SetLocal-format break }
        case Word.RefLocal -> { RefLocal-format break }
        case Word.StoreLocal -> { StoreLocal-format break }
        case Word.Cast -> { Cast-format break }
        case Word.Call -> { Call-format break }
        case Word.Intrinsic -> { IntrinsicWord-format break }
        case Word.Flip -> { Flip-format break }
        case Word.Break -> { $fmt "(Break " Fmt:write Token-format $fmt ")" }
        case Word.If -> { If-format break }
        case Word.Loop -> { Loop-format break }
        case Word.Block -> { Block-format break }
        case Word.Sizeof -> { $fmt "(Sizeof " Fmt:write TypeId-format $fmt ")" }
        case Word.Uninit -> { Uninit-format break }
        case Word.FieldInit -> { FieldInit-format break }
        case Word.Load -> { Load-format break }
        case Word.MakeTuple -> { MakeTuple-format break }
        case Word.UnpackTuple -> { UnpackTuple-format break }
        case Word.IndirectCall -> { IndirectCall-format break }
        case Word.GetField -> { GetField-format break }
        case Word.FunRef -> { FunRef-format break }
        case Word.Match -> { Match-format break }
        case Word.MatchVoid -> { $fmt "(MatchVoid " Fmt:write Token-format $fmt ")" }
        case Word.Struct -> { StructWord-format break }
        case Word.StructNamed -> { StructWordNamed-format break }
        case Word.Variant -> { VariantWord-format break }
    } Fmt:write
} }
struct Scope {
    id: ScopeId
    words: Array<Word>
}
fn Scope-format(fmt: .Formatter, self: .Scope) {
    $fmt "(Scope " Fmt:write
    $fmt &self.id ScopeId-format
    $fmt " " Fmt:write
    $fmt &self.words Words-format
    $fmt ")" Fmt:write
}
fn Words-format(fmt: .Formatter, self: .Array<Word>) {
    $fmt \Word-format $self Array:format-multi-line<Word>
}


// =============================================================================
//  Word monomorphization procedures
// =============================================================================

fn monomize-cast(ctx: .Ctx, word: .Checked:Cast, generic-arguments: .Array<TypeId>) -> Word {
    $word.token
    $ctx &word.src $generic-arguments monomize-type
    $ctx &word.dst $generic-arguments monomize-type
    make Cast make Word.Cast
}

fn monomize-get-locl(ctx: .Ctx, word: .Checked:GetLocal, generic-arguments: .Array<TypeId>) -> Word {
    make GetLocal {
        $word.name @name
        $word.var @var
        $ctx &word.var-type $generic-arguments monomize-type @var-type
        $ctx &word.fields $generic-arguments monomize-field-accesses @fields
        $ctx &word.result-taip $generic-arguments monomize-type @result-type
        0 not @copy-space-offset
    }
    make Word.GetLocal
}
fn monomize-set-locl(ctx: .Ctx, word: .Checked:SetLocal, generic-arguments: .Array<TypeId>) -> Word {
    make SetLocal {
        $word.name @name
        $word.var @var
        $ctx &word.fields $generic-arguments monomize-field-accesses @fields
        $ctx &word.target-type $generic-arguments monomize-type @target-type
    }
    make Word.SetLocal
}

fn monomize-field-accesses(ctx: .Ctx, fields: .Array<Checked:FieldAccess>, generic-arguments: .Array<TypeId>) -> Array<FieldAccess> {
    $ctx.arena $fields.len Array:new-with-capacity<FieldAccess> @monomized
    loop {
        $monomized.len $fields.len = if { $monomized break }
        &monomized
        $ctx
        $fields $monomized.len Array:get<Checked:FieldAccess>
        $generic-arguments monomize-field-access
        Array:push-assert-no-alloc<FieldAccess>
    }
}
fn monomize-field-access(ctx: .Ctx, field: .Checked:FieldAccess, generic-arguments: .Array<TypeId>) -> FieldAccess {
    make FieldAccess {
        $field.name @name
        $ctx &field.source-type $generic-arguments monomize-type @source-type
        $ctx &field.target-type $generic-arguments monomize-type @target-type
        $field.field-index @field-index
    }
}

fn monomize-call(ctx: .Ctx, call: .Checked:Call, generic-arguments: .Array<TypeId>) -> Call { block {
    $ctx &call.generic-arguments $generic-arguments monomize-types @generic-arguments-of-this-call
    $ctx $call.function lookup-checked-function match {
        case Checked:FunctionOrExtern.Extern -> {
            drop
            make Call {
                $call.name @name
                $call.function.module $call.function.index 0
                make FunctionHandle @function
                0 @instance-id
                0 not @copy-space-offset
            }
        }
        case Checked:FunctionOrExtern.Function -> {
            $ctx $call.function &generic-arguments-of-this-call lookup-function match {
                case Some -> { flip drop }
                case None -> {
                    $ctx $call.function $generic-arguments-of-this-call pre-insert-function @instance @slot
                    $ctx flip &generic-arguments-of-this-call monomize-function make Maybe<Function>.Some =>slot
                    $instance
                }
            } @instance
            make Call {
                $call.name @name
                $call.function.module $call.function.index $instance
                make FunctionHandle @function
                0 not @copy-space-offset
            }
        }
    }
} }

fn monomize-intrinsic(ctx: .Ctx, word: .Checked:IntrinsicWord, generic-arguments: .Array<TypeId>) -> Word { block (-> Word) {
    $word.token
    $ctx &word.intrinsic match {
        case Checked:Intrinsic.Gt -> { $generic-arguments monomize-type make Intrinsic.Gt }
        case Checked:Intrinsic.Lt -> { $generic-arguments monomize-type make Intrinsic.Lt }
        case Checked:Intrinsic.Add -> { $generic-arguments monomize-type make Intrinsic.Add }
        case Checked:Intrinsic.Sub -> { $generic-arguments monomize-type make Intrinsic.Sub }
        case Checked:Intrinsic.Mul -> { $generic-arguments monomize-type make Intrinsic.Mul }
        case Checked:Intrinsic.Div -> { $generic-arguments monomize-type make Intrinsic.Div }
        case Checked:Intrinsic.Mod -> { $generic-arguments monomize-type make Intrinsic.Mod }
        case Checked:Intrinsic.Eq -> { $generic-arguments monomize-type make Intrinsic.Eq }
        case Checked:Intrinsic.NotEq -> { $generic-arguments monomize-type make Intrinsic.NotEq }
        case Checked:Intrinsic.MemGrow -> { drop make Intrinsic.MemGrow }
        case Checked:Intrinsic.MemCopy -> { drop make Intrinsic.MemCopy }
        case Checked:Intrinsic.MemFill -> { drop make Intrinsic.MemFill }
        case Checked:Intrinsic.Shl -> { $generic-arguments monomize-type make Intrinsic.Shl }
        case Checked:Intrinsic.Shr -> { $generic-arguments monomize-type make Intrinsic.Shr }
        case Checked:Intrinsic.Rotl -> { $generic-arguments monomize-type make Intrinsic.Rotl }
        case Checked:Intrinsic.Rotr -> { $generic-arguments monomize-type make Intrinsic.Rotr }
        case Checked:Intrinsic.And -> { $generic-arguments monomize-type make Intrinsic.And }
        case Checked:Intrinsic.Or -> { $generic-arguments monomize-type make Intrinsic.Or }
        case Checked:Intrinsic.Ge -> { $generic-arguments monomize-type make Intrinsic.Ge }
        case Checked:Intrinsic.Le -> { $generic-arguments monomize-type make Intrinsic.Le }
        case Checked:Intrinsic.Not -> { $generic-arguments monomize-type make Intrinsic.Not }
        case Checked:Intrinsic.Store -> { $generic-arguments monomize-type make Intrinsic.Store }
        case Checked:Intrinsic.Drop -> { $generic-arguments monomize-type make Intrinsic.Drop }
        case Checked:Intrinsic.SetStackSize -> { drop make Intrinsic.SetStackSize }
        case Checked:Intrinsic.Uninit -> {
            $generic-arguments monomize-type 0 not make Uninit make Word.Uninit break
        }
        case Checked:Intrinsic.Flip -> {
            $ctx flip $word.token flip $generic-arguments monomize-flip break
        }
    } make IntrinsicWord make Word.Intrinsic
} }

fn monomize-init-locl(ctx: .Ctx, word: .Checked:InitLocal, generic-arguments: .Array<TypeId>) -> Word {
    $word.name
    $ctx &word.type $generic-arguments monomize-type
    $word.local
    make InitLocal make Word.InitLocal
}

fn fields-go-through-ptr(ctx: .Ctx, fields: .Array<FieldAccess>) -> bool {
    0 @i
    loop {
        $i $fields.len = if {
            // No field access went through a pointer,
            0 1 = break
        }
        $ctx $fields $i Array:get<FieldAccess> .source-type ~ lookup-type match {
            case Ptr -> {
                drop
                // At least one field access goes through a pointer,
                1 1 = break
            }
            case _ -> { drop }
        }
        $i 1 + #i
    }
}

fn monomize-ref-locl(ctx: .WordCtx, word: .Checked:RefLocal, generic-arguments: .Array<TypeId>) -> Word {
    $ctx.ctx &word.fields $generic-arguments monomize-field-accesses @fields
    $ctx.ctx &fields fields-go-through-ptr not if {
        $ctx &word.var mark-var-reffed
    }
    $word.name $word.var $fields make RefLocal make Word.RefLocal
}

fn monomize-store-locl(ctx: .Ctx, word: .Checked:StoreLocal, generic-arguments: .Array<TypeId>) -> Word {
    $word.name
    $word.var
    $ctx &word.type $generic-arguments monomize-type
    $ctx &word.fields $generic-arguments monomize-field-accesses
    make StoreLocal make Word.StoreLocal
}

fn monomize-iff(ctx: .WordCtx, word: .Checked:If, generic-arguments: .Array<TypeId>) -> Word {
    $word.token
    $ctx.ctx &word.parameters $generic-arguments monomize-types
    &word.returns match {
        case None -> { make Maybe<Array<TypeId>>.None }
        case Some -> { $ctx.ctx flip $generic-arguments monomize-types make Maybe<Array<TypeId>>.Some }
    }
    $ctx &word.true-branch  $generic-arguments monomize-scope
    $ctx &word.false-branch $generic-arguments monomize-scope
    make If make Word.If
}

fn monomize-lop(ctx: .WordCtx, word: .Checked:Loop, generic-arguments: .Array<TypeId>) -> Word {
    $word.token
    $ctx.ctx &word.parameters $generic-arguments monomize-types
    &word.returns match {
        case None -> { make Maybe<Array<TypeId>>.None }
        case Some -> { $ctx.ctx flip $generic-arguments monomize-types make Maybe<Array<TypeId>>.Some }
    }
    $ctx &word.body $generic-arguments monomize-scope
    make Loop make Word.Loop
}

fn monomize-blok(ctx: .WordCtx, word: .Checked:Block, generic-arguments: .Array<TypeId>) -> Word {
    $word.token
    $ctx.ctx &word.parameters $generic-arguments monomize-types
    $ctx.ctx &word.returns $generic-arguments monomize-types
    $ctx &word.body $generic-arguments monomize-scope
    make Block make Word.Block
}

fn monomize-sizeof(ctx: .Ctx, word: .Resolved:Sizeof, generic-arguments: .Array<TypeId>) -> Word {
    $ctx &word.type $generic-arguments monomize-type make Word.Sizeof
}

fn monomize-flip(ctx: .Ctx, token: Token, word: .Checked:Flip, generic-arguments: .Array<TypeId>) -> Word {
    $token
    $ctx &word.lower $generic-arguments monomize-type
    $ctx &word.upper $generic-arguments monomize-type
    make Flip make Word.Flip
}

fn monomize-field-init(ctx: .WordCtx, word: .Checked:FieldInit, generic-arguments: .Array<TypeId>) -> Word {
    $ctx.struc-env match {
        case None -> { Core:unreachable<CustomTypeHandle> }
        case Some -> {}
    }
    $ctx.ctx &word.type $generic-arguments monomize-type
    $word.field-index
    0 not
    make FieldInit make Word.FieldInit
}

fn monomize-load(ctx: .Ctx, word: .Checked:Load, generic-arguments: .Array<TypeId>) -> Word {
    $ctx &word.type $generic-arguments monomize-type
    0 not
    make Load make Word.Load
}

fn monomize-get-field(ctx: .Ctx, word: .Checked:GetField, generic-arguments: .Array<TypeId>) -> Word {
    $word.token
    $ctx &word.fields $generic-arguments monomize-field-accesses
    $ctx &word.type $generic-arguments monomize-type
    $word.on-ptr
    0 not
    make GetField make Word.GetField
}

fn monomize-matsh-cays(ctx: .WordCtx, cays: .Checked:MatchCase, generic-arguments: .Array<TypeId>) -> MatchCase {
    &cays.type match {
        case None -> { make Maybe<TypeId>.None }
        case Some -> { $ctx.ctx flip $generic-arguments monomize-type make Maybe<TypeId>.Some }
    }
    $cays.tag $ctx &cays.body $generic-arguments monomize-scope make MatchCase
}

fn monomize-matsh-cases(ctx: .WordCtx, cases: .Array<Checked:MatchCase>, generic-arguments: .Array<TypeId>) -> Array<MatchCase> {
    $ctx.ctx.arena $cases.len Array:new-with-capacity<MatchCase> @monomized
    loop {
        $monomized.len $cases.len = if { $monomized break }
        &monomized
        $ctx $cases $monomized.len Array:get<Checked:MatchCase> $generic-arguments monomize-matsh-cays
        Array:push-assert-no-alloc<MatchCase>
    }
}

fn monomize-scope(ctx: .WordCtx, scope: .Checked:Scope, generic-arguments: .Array<TypeId>) -> Scope {
    $scope.id $ctx &scope.words $generic-arguments monomize-words make Scope
}

fn monomize-matsh(ctx: .WordCtx, word: .Checked:Match, generic-arguments: .Array<TypeId>) -> Word {
    make Match {
        $ctx &word.cases $generic-arguments monomize-matsh-cases @cases
        $word.by-ref @by-ref
        $ctx.ctx &word.varint $generic-arguments monomize-custom-type' @type
        &word.default match {
            case None -> { make Maybe<Scope>.None }
            case Some -> {
                $ctx flip $generic-arguments monomize-scope make Maybe<Scope>.Some
            }
        } @default
        $ctx.ctx &word.parameters $generic-arguments monomize-types @parameters
        &word.returns match {
            case None -> { make Maybe<Array<TypeId>>.None }
            case Some -> { $ctx.ctx flip $generic-arguments monomize-types make Maybe<Array<TypeId>>.Some }
        } @returns
    } make Word.Match
}

fn monomize-struc-word(ctx: .Ctx, word: .Checked:StructWord, generic-arguments: .Array<TypeId>) -> Word {
    $ctx &word.type $generic-arguments monomize-custom-type'
    0 not
    make StructWord
    make Word.Struct
}

fn monomize-struc-word-named(ctx: .WordCtx, word: .Checked:StructWordNamed, generic-arguments: .Array<TypeId>) -> Word {
    $ctx.ctx &word.type $generic-arguments monomize-custom-type' @type
    $ctx.struc-env @outer-struc-env
    $ctx.ctx $type lookup-type match {
        case Custom -> {}
        case _ -> { drop Core:unreachable<.CustomTypeHandle> }
    } ~ make Maybe<CustomTypeHandle>.Some #ctx.struc-env
    $type
    $ctx &word.body $generic-arguments monomize-scope
    0 not
    make StructWordNamed make Word.StructNamed
    $outer-struc-env #ctx.struc-env
}

fn monomize-varint-word(ctx: .Ctx, word: .Checked:VariantWord, generic-arguments: .Array<TypeId>) -> Word {
    $word.tag
    $ctx &word.type $generic-arguments monomize-custom-type'
    0 not
    make VariantWord make Word.Variant
}

fn monomize-fun-ref(ctx: .Ctx, word: .Checked:FunRef, generic-arguments: .Array<TypeId>) -> Word {
    $ctx &word.call $generic-arguments monomize-call @call
    $call
    $ctx $call.function insert-into-function-table
    make FunRef make Word.FunRef
}

fn monomize-word(ctx: .WordCtx, word: .Checked:Word, generic-arguments: .Array<TypeId>) -> Word {
    $word match {
        case Checked:Word.Number -> { ~ make Word.Number }
        case Checked:Word.String -> { ~ make Word.String }
        case Checked:Word.GetLocal -> { $ctx.ctx flip $generic-arguments monomize-get-locl }
        case Checked:Word.InitLocal -> { $ctx.ctx flip $generic-arguments monomize-init-locl }
        case Checked:Word.RefLocal -> { $ctx flip $generic-arguments monomize-ref-locl }
        case Checked:Word.SetLocal -> { $ctx.ctx flip $generic-arguments monomize-set-locl }
        case Checked:Word.StoreLocal -> { $ctx.ctx flip $generic-arguments monomize-store-locl }
        case Checked:Word.Cast -> { $ctx.ctx flip $generic-arguments monomize-cast }
        case Checked:Word.Call -> { $ctx.ctx flip $generic-arguments monomize-call make Word.Call }
        case Checked:Word.Intrinsic -> { $ctx.ctx flip $generic-arguments monomize-intrinsic }
        case Checked:Word.If -> { $ctx flip $generic-arguments monomize-iff }
        case Checked:Word.Loop -> { $ctx flip $generic-arguments monomize-lop }
        case Checked:Word.Block -> { $ctx flip $generic-arguments monomize-blok }
        case Checked:Word.Sizeof -> { $ctx.ctx flip $generic-arguments monomize-sizeof }
        case Checked:Word.FieldInit -> { $ctx flip $generic-arguments monomize-field-init }
        case Checked:Word.Load -> { $ctx.ctx flip $generic-arguments monomize-load }
        case Checked:Word.MakeTuple -> { .type $ctx.ctx flip $generic-arguments monomize-type 0 not make MakeTuple make Word.MakeTuple }
        case Checked:Word.UnpackTuple -> { .type $ctx.ctx flip $generic-arguments monomize-type 0 not make UnpackTuple make Word.UnpackTuple }
        case Checked:Word.IndirectCall -> { .type $ctx.ctx flip $generic-arguments monomize-fun-type 0 not make IndirectCall make Word.IndirectCall }
        case Checked:Word.Break -> { ~ make Word.Break }
        case Checked:Word.GetField -> { $ctx.ctx flip $generic-arguments monomize-get-field }
        case Checked:Word.FunRef -> { $ctx.ctx flip $generic-arguments monomize-fun-ref }
        case Checked:Word.MatchVoid -> { ~ make Word.MatchVoid }
        case Checked:Word.Match -> { $ctx flip $generic-arguments monomize-matsh }
        case Checked:Word.StructWord -> { $ctx.ctx flip $generic-arguments monomize-struc-word }
        case Checked:Word.StructWordNamed -> { $ctx flip $generic-arguments monomize-struc-word-named }
        case Checked:Word.VariantWord -> { $ctx.ctx flip $generic-arguments monomize-varint-word }
    }
}
fn monomize-words(ctx: .WordCtx, words: .Array<Checked:Word>, generic-arguments: .Array<TypeId>) -> Array<Word> {
    Array:new<Word> @monomized
    loop {
        $monomized.len $words.len = if { $monomized break }
        $ctx.ctx.arena &monomized
        $ctx $words $monomized.len Array:get<Checked:Word> $generic-arguments monomize-word
        Array:push<Word>
    }
}


// =============================================================================
//  Local copy space measuring
// =============================================================================

fn measure-copy-space(modules: .Map<ByteSlice, Module>, sizes: .Array<i32>, types: .Array<Maybe<Key>>) {
    0 @module-id
    loop {
        $module-id $modules.values.len = if { break }
        &modules.values &modules.values $module-id Array:get<Module> $sizes $types module-measure-copy-space
        $module-id 1 + #module-id
    }
}

fn module-measure-copy-space(modules: .Array<Module>, module: .Module, sizes: .Array<i32>, types: .Array<Maybe<Key>>) {
    0 @function-id
    loop {
        $function-id $module.functions.len = if { break }
        &module.functions $function-id Array:get<ExternOrInstances> match {
            case Instances -> {
                @instances
                0 @instance-id
                loop {
                    $instance-id $instances.len = if { break }
                    $instances $instance-id Array:get<.Function> ~ @function
                    $modules $function $sizes $types function-measure-copy-space
                    $instance-id 1 + #instance-id
                }
            }
            case Extern -> { drop }
        }
        $function-id 1 + #function-id
    }
}

fn function-measure-copy-space(modules: .Array<Module>, function: .Function, sizes: .Array<i32>, types: .Array<Maybe<Key>>) {
    $modules $sizes $types 0 not 0 make CopySpaceCtx @ctx
    0 #function.local-copy-space
    &function.body.words &ctx &function.local-copy-space words-measure-copy-space
    $ctx.max-stack-returns #function.max-stack-returns
}

fn words-measure-copy-space(words: .Array<Word>, ctx: .CopySpaceCtx, offset: .i32) {
    0 @i
    loop {
        $i $words.len = if { break }
        $words $i Array:get<Word> $ctx $offset word-measure-copy-space
        $i 1 + #i
    }
}

fn type-size(sizes: .Array<i32>, type: TypeId) -> i32 {
    $sizes $type.index Array:get<i32> ~
}

fn field-offset(sizes: .Array<i32>, struc: .Struct, field-index: i32) -> i32 {
    $sizes !.[] $struc.sizes-used-for-offset-cache = if {
        &struc.field-offsets $field-index Array:get<i32> ~
    } else {
        $sizes !.[] #struc.sizes-used-for-offset-cache
        &struc.field-offsets 0 Array:truncate<i32>
        0 @i
        0 @offset
        loop {
            $i $struc.fields.len = if { break }

            &struc.field-offsets $offset Array:push-assert-no-alloc<i32>

            &struc.fields $i Array:get<NamedTypeId> @field
            $sizes $field.type type-size @field-size
            $offset $field-size + #offset

            $i 1 + $struc.fields.len lt if {
                $sizes &struc.fields $i 1 + Array:get<NamedTypeId> .type ~ type-size @next-field-size
                $offset $next-field-size 4 Core:min Core:align-to #offset
            }

            $i 1 + #i
        }
        $sizes $struc $field-index field-offset
    }
}

fn can-live-in-reg(sizes: .Array<i32>, type: TypeId) -> bool {
    $sizes $type.index Array:get<i32> ~ 8 le
}

struct CopySpaceCtx {
    modules: .Array<Module>
    sizes: .Array<i32>
    types: .Array<Maybe<Key>>
    struc-offset: i32
    max-stack-returns: i32
}

fn word-measure-copy-space(word: .Word, ctx: .CopySpaceCtx, offset: .i32) { block {
    $word match {
        case Word.GetLocal -> { @word $word.result-type &word.copy-space-offset }
        case Word.Call -> {
            @word
            $ctx.modules $word.function.module.index Array:get<Module>
            .functions $word.function.index Array:get<ExternOrInstances> match {
                case Extern -> { .signature }
                case Instances -> { $word.function.instance Array:get<.Function> ~ .signature }
            } .returns @returns
            $returns $ctx.types $ctx.sizes $offset returns-measure-copy-space #word.copy-space-offset
            $word.copy-space-offset $offset ~ /= if {
                // this call does use some copy-space
                $returns.len $ctx.max-stack-returns Core:max #ctx.max-stack-returns
            }
            0 @num-stack-returns
            break
        }
        case Word.IndirectCall -> {
            @word
            $ctx.types $word.type.index Array:get<Maybe<Key>> Maybe:ref<Key> assert-some<.Key> Key-type match {
                case Fun -> {}
                case _ -> { drop Core:unreachable<.FunType> }
            } .returns @returns
            $returns $ctx.types $ctx.sizes $offset returns-measure-copy-space #word.copy-space-offset
            $word.copy-space-offset $offset ~ /= if {
                // this call does use some copy-space
                $returns.len $ctx.max-stack-returns Core:max #ctx.max-stack-returns
            }
            break
        }
        case Word.Load -> { @word $word.type &word.copy-space-offset }
        case Word.Uninit -> { @word $word.type &word.copy-space-offset }
        case Word.Struct -> { @word $word.type &word.copy-space-offset }
        case Word.StructNamed -> {
            @word
            $offset ~ #word.copy-space-offset
            $offset ~ $ctx.sizes $word.type type-size + =>offset
            $ctx.struc-offset
            $word.copy-space-offset #ctx.struc-offset
            &word.body.words $ctx $offset words-measure-copy-space
            #ctx.struc-offset
            break
        }
        case Word.Variant -> { @word $word.type &word.copy-space-offset }
        case FieldInit -> {
            @word
            $ctx.modules $word.struc.module.index Array:get<Module> .custom-types
            $word.struc.index Array:get<CustomType> match {
                case CustomType.Struct -> {}
                case CustomType.Variant -> { !.Struct 0 0 / drop }
            } @struc
            $ctx.sizes $struc $word.field-index field-offset @field-offset
            $ctx.struc-offset $field-offset + #word.copy-space-offset break
        }
        case If -> {
            @word
            &word.true-branch.words  $ctx $offset words-measure-copy-space
            &word.false-branch.words $ctx $offset words-measure-copy-space
            break
        }
        case Loop -> { .body.words $ctx $offset words-measure-copy-space break }
        case Block -> { .body.words $ctx $offset words-measure-copy-space break }
        case Match -> {
            @word
            0 @i
            loop {
                $i $word.cases.len = if { break }
                &word.cases $i Array:get<MatchCase> .body.words
                $ctx $offset words-measure-copy-space
                $i 1 + #i
            }
            &word.default match {
                case Some -> { .words $ctx $offset words-measure-copy-space }
                case None -> {}
            }
            break
        }
        case GetField -> { @word $word.type &word.copy-space-offset }
        case MakeTuple -> { @word $word.type &word.copy-space-offset }
        case UnpackTuple -> {
            @word
            $ctx.types $word.type.index Array:get<Maybe<Key>> Maybe:ref<Key> assert-some<.Key> Key-type match {
                case Tuple -> {}
                case _ -> { drop Core:unreachable<.Array<TypeId>> }
            } @items
            $items $ctx.types $ctx.sizes $offset returns-measure-copy-space #word.copy-space-offset
            break
        }
        case _ -> { drop break }
    } @offset-slot @type
    $ctx.sizes $type can-live-in-reg not if {
        $offset ~ =>offset-slot
        $offset ~ $ctx.sizes $type type-size + =>offset
    }
} }

fn returns-measure-copy-space(returns: .Array<TypeId>, types: .Array<Maybe<Key>>, sizes: .Array<i32>, offset: .i32) -> i32 {
    $offset ~
    0 @i
    loop {
        $i $returns.len = if { break }
        $returns $i Array:get<TypeId> ~ @type
        $sizes $type can-live-in-reg not if {
            $offset ~ $sizes $type type-size + =>offset
        }
        $i 1 + #i
    }
}

