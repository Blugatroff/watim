import "../std/string.watim" as S
import "../std/str.watim" as STR
import "../std/io.watim" as IO
import "../std/map.watim" as MAP
import "../std/fs.watim" as FS
import "../std/alloc.watim" as A
import "../std/format.watim" as FMT
import "../std/core.watim" as CORE

import "./ast.watim" as AST
import "./lexer.watim" as L
import "./parser.watim" as P

struct Module {
    items: .AST:TopItems
    imports: .AST:Imports
    file: S:String
    tokens: L:Tokens
    types: .AST:Types
    path: S:String
}

fn Module-load(path-ptr: .i32, path-len: i32, mem: .S:String) -> Module {
    local str: S:String
    local tokens: L:Tokens
    local items: .AST:TopItems
    local types: .AST:Types
    local path: S:String
    local code: i32

    $path-ptr $path-len S:String-new-heap #path
    &path S:String-unpack FS:read-file #code #str 
    $code 0 /= if {
        2 "Failed to read file: \"" IO:write-all IO:check
        2 $path-ptr $path-len IO:write-all IO:check
        2 "\" Error Code: " IO:write-all IO:check
        2 $code IO:print-to-fd
        2 "\n" IO:write-all IO:check
        1 CORE:exit
    }
    &str &path S:String-unpack STR:Str-new L:lex #tokens
    $mem &tokens P:parse #types #items 
    
    $items $path $str $tokens $types Module-new
}

fn Module-new(items: .AST:TopItems, path: S:String, file: S:String, tokens: L:Tokens, types: .AST:Types) -> Module {
    local self: Module
    $items #self.items
    $file #self.file
    $tokens #self.tokens
    $types #self.types
    $path #self.path
    &self &self.path Module-extract-imports
    &self Module-check-for-duplicate-functions
    // TODO check for duplicate structs and memories
    $self
}

fn Module-check-for-duplicate-functions(self: .Module) {
    local i: i32
    local len: i32
    local item: .AST:TopItem
    local j: i32
    local item2: .AST:TopItem
    local ident: .L:Token

    $self.items AST:TopItems-len #len
    loop {
        $i $len = if { break }
        
        $self.items $i AST:TopItems-get #item
        $item AST:TopItem-ty AST:TOP_ITEM_FN = if {
            0 #j
            loop {
                $j $i = if { break }
                $self.items $j AST:TopItems-get #item2
                
                $item2 AST:TopItem-ty AST:TOP_ITEM_FN = if {
                    $item AST:TopItem-function AST:Function-ident L:Token-lexeme
                    $item2 AST:TopItem-function AST:Function-ident #ident
                    $ident L:Token-lexeme
                    STR:Str-eq if {
                        2 $ident L:Token-location L:print-location
                        2 "duplicate function: " IO:write-all IO:check
                        2 $ident L:Token-lexeme ~ STR:Str-unpack IO:write-all IO:check
                        2 "\n" IO:write-all IO:check
                        1 CORE:exit
                    }
                }

                $j 1 + #j
            }
        }

        $i 1 + #i
    }
}

fn Module-extract-imports(self: .Module, module-path: .S:String) {
    local i: i32
    local item: .AST:TopItem
    local imp: .AST:Import
    local path: S:String
    local ident: S:String

    AST:Imports-new #self.imports
    loop {
        $i $self.items AST:TopItems-len = if { break }
        $self.items $i AST:TopItems-get #item
        $item AST:TopItem-ty AST:TOP_ITEM_IMPORT = if {
            $item.imp #imp
            $module-path S:String-unpack FS:path-dir S:String-new #path
            &path $imp AST:Import-path-content S:String-append
            $self.imports
            $item.imp AST:Import-ident L:Token-lexeme ~ STR:Str-unpack S:String-new 
            &path S:String-unpack FS:normalize 
            AST:Imports-insert
            $path S:String-free
        }
        $i 1 + #i
    }
}

fn Module-imports(self: .Module) -> .AST:Imports {
    $self.imports
}

fn Module-free(self: Module) {
    $self.items AST:TopItems-free
    $self.file S:String-free
    $self.tokens L:Tokens-free
    $self.types AST:Types-free
    $self.imports AST:Imports-free
    $self.path S:String-free
}

fn Module-items(self: .Module) -> .AST:TopItems {
    $self.items
}

fn Module-find-struc(self: .Module, ident-ptr: .i32, ident-len: i32) -> .AST:Struct, bool {
    local items: .AST:TopItems
    local item: .AST:TopItem
    local struc: .AST:Struct
    local i: i32
    $self Module-items #items
    loop {
        $i $items AST:TopItems-len = if { 0 !.AST:Struct 0 1 = break }
        $items $i AST:TopItems-get #item
        $item AST:TopItem-ty AST:TOP_ITEM_STRUCT = if {
            $item AST:TopItem-struc #struc
            $struc AST:Struct-ident L:Token-lexeme ~ STR:Str-unpack $ident-ptr $ident-len STR:str-eq if {
                $struc 0 0 = break
            }
        }
        $i 1 + #i
    }
}

fn Module-find-function(self: .Module, ident-ptr: .i32, ident-len: i32) -> .AST:Extern, .AST:Function, bool {
    local items: .AST:TopItems
    local item: .AST:TopItem
    local fun: .AST:Function
    local ext: .AST:Extern
    local i: i32
    $self Module-items #items
    loop {
        $i $items AST:TopItems-len = if { 0 !.AST:Extern 0 !.AST:Function 0 1 = break }
        $items $i AST:TopItems-get #item
        $item AST:TopItem-ty AST:TOP_ITEM_FN = if {
            $item AST:TopItem-function #fun
            $fun AST:Function-ident L:Token-lexeme ~ STR:Str-unpack $ident-ptr $ident-len STR:str-eq if {
                0 !.AST:Extern $fun 0 0 = break
            }
        }
        $item AST:TopItem-ty AST:TOP_ITEM_EXT = if {
            $item AST:TopItem-ext #ext
            $ext AST:Extern-ident L:Token-lexeme ~ STR:Str-unpack $ident-ptr $ident-len STR:str-eq if {
                $ext 0 !.AST:Function 0 0 = break
            }
        }
        $i 1 + #i
    }
}

fn Module-find-mem(self: .Module, ident-ptr: .i32, ident-len: i32) -> .AST:Memory, bool {
    local items: .AST:TopItems
    local item: .AST:TopItem
    local mem: .AST:Memory
    local i: i32
    $self Module-items #items
    loop {
        $i $items AST:TopItems-len = if { 0 !.AST:Memory 0 1 = break }
        $items $i AST:TopItems-get #item
        $item AST:TopItem-ty AST:TOP_ITEM_MEM = if {
            $item.mem #mem
            $mem AST:Memory-ident L:Token-lexeme ~ STR:Str-unpack $ident-ptr $ident-len STR:str-eq if {
                $mem 0 0 = break 
            }
        }
        $i 1 + #i
    }
}

fn Module-types(self: .Module) -> .AST:Types {
    $self.types
}

fn Module-path(self: .Module) -> .S:String {
    &self.path
}

struct Modules {
    inner: MAP:StringMap
}

fn Modules-new() -> Modules {
    local self: Modules
    MAP:StringMap-new #self.inner
    $self
}

fn Modules-free(self: .Modules) {
    local i: i32
    loop {
        $i &self.inner MAP:StringMap-len = if { break }
        &self.inner $i MAP:StringMap-get-value !.Module ~ Module-free
        &self.inner $i MAP:StringMap-get-value !.i32 A:free
        $i 1 + #i
    }
    $self.inner MAP:StringMap-free
}

fn Modules-insert(self: .Modules, path: S:String, module: Module) {
    local alloced-module: .Module
    sizeof(Module) A:alloc !.Module #alloced-module
    $module >>alloced-module
    &self.inner $path $alloced-module !i32 MAP:StringMap-insert if {
        !.Module #alloced-module
        2 "WARNING: overwrote module: " IO:write-all IO:check 1 &path S:String-unpack IO:write-all IO:check
        2 "\n" IO:write-all IO:check
        $alloced-module ~ Module-free
        $alloced-module !.i32 A:free
    } else {
        drop
    }
}

fn Modules-get(self: .Modules, path-ptr: .i32, path-len: i32) -> .Module, bool {
    &self.inner $path-ptr $path-len MAP:StringMap-get if {
        !.Module 0 0 =
    } else {
        !.Module 0 1 =
    }
}

fn Modules-get-key(self: .Modules, index: i32) -> .S:String {
    &self.inner $index MAP:StringMap-get-key
}

fn Modules-get-value(self: .Modules, index: i32) -> .Module {
    &self.inner $index MAP:StringMap-get-value !.Module
}

fn Modules-len(self: .Modules) -> i32 {
    &self.inner MAP:StringMap-len
}

fn Modules-find-struc(self: .Modules, path-ptr: .i32, path-len: i32, ident-ptr: .i32, ident-len: i32) -> .AST:Struct, bool {
    local i: i32
    local module: .Module
    $self $path-ptr $path-len Modules-get if {
        #module $module $ident-ptr $ident-len Module-find-struc
    } else {
        drop 0 !.AST:Struct 0 1 = 
    }
}

fn Modules-find-function(self: .Modules, path-ptr: .i32, path-len: i32, ident-ptr: .i32, ident-len: i32) -> .AST:Extern, .AST:Function, bool {
    local i: i32
    local module: .Module
    $self $path-ptr $path-len Modules-get if {
        #module $module $ident-ptr $ident-len Module-find-function
    } else {
        drop
        0 !.AST:Extern 0 !.AST:Function 0 1 = 
    }
}

fn Modules-find-index(self: .Modules, module: .Module) -> i32 {
    local i: i32
    loop {
        $i $self Modules-len = if { 
            2 "Modules-find-index: NOT FOUND" IO:write-all IO:check
            1 CORE:exit
        }
        $module $self $i Modules-get-value = if { 
            $i break 
        }
        $i 1 + #i
    }
}

fn Modules-mark-reachable(self: .Modules) {
    local module: .Module
    local items: .AST:TopItems
    local i: i32
    local j: i32
    local item: .AST:TopItem
    local function: .AST:Function
    loop {
        $i $self Modules-len = if { break }
        $self $i Modules-get-value #module

        $module Module-items #items

        0 #j
        loop {
            $items AST:TopItems-len $j = if { break }

            $items $j AST:TopItems-get #item

            $item AST:TopItem-ty AST:TOP_ITEM_FN = if {
                $item AST:TopItem-function #function
                $function.export 0 !.L:Token /= if {
                    $self $module $function mark-reachable-function
                }
            }

            $j 1 + #j
        }

        $i 1 + #i
    }
}

fn mark-reachable-function(modules: .Modules, module: .Module, function: .AST:Function) {
    $function.reachable not if {
        $function AST:Function-mark-reachable
        $modules $module $function AST:Function-body mark-reachable-words
    }
}

fn mark-reachable-words(modules: .Modules, module: .Module, words: .AST:Words) {
    local word: .AST:Word
    local i: i32

    loop {
        $words AST:Words-len $i = if { break }
        $words $i AST:Words-get #word

        $word AST:Word-ty AST:WORD_CALL = if {
            $modules $module $word mark-reachable-call
        }

        $word AST:Word-ty AST:WORD_IF = if {
            $modules $module $word AST:Word-iff mark-reachable-iff
        }

        $word AST:Word-ty AST:WORD_LOOP = if {
            $modules $module $word AST:Word-lop mark-reachable-words
        }

        $i 1 + #i
    }
}

fn mark-reachable-iff(modules: .Modules, module: .Module, iff: .AST:If) {
    $modules $module &iff.body mark-reachable-words
    $iff.has-el if {
        $modules $module &iff.el mark-reachable-words
    }
}

fn mark-reachable-call(modules: .Modules, module: .Module, caller: .AST:Word) {
    local function: .AST:Function
    local ext: .AST:Extern
    local path: .S:String

    $caller.qualifier 0 !.STR:Str = if { 
        $module $caller AST:Word-ident ~ STR:Str-unpack Module-find-function if {
            #function #ext
            $function 0 !.AST:Function /= if {
                $modules $module $function mark-reachable-function
            }
            $ext 0 !.AST:Extern /= if {
                $ext AST:Extern-mark-reachable
            }

        } else { drop drop }
    } else {
        $module Module-imports $caller.qualifier ~ STR:Str-unpack AST:Imports-get if {
            #path
            $modules $path S:String-unpack Modules-get if {
                #module

                $module $caller AST:Word-ident ~ STR:Str-unpack Module-find-function if {
                    #function #ext
                    $function 0 !.AST:Function /= if {
                        $modules $module $function mark-reachable-function
                    }
                    $ext 0 !.AST:Extern /= if {
                        $ext AST:Extern-mark-reachable
                    }
                } else { drop drop }
            } else { drop }
        } else { drop }
    }
}

