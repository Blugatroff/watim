import "./core.watim" as CORE
import "./io.watim" as IO
import "./alloc.watim" as A
import "./string.watim" as S
import "./format.watim" as FMT

fn parse(pt: .i32, len: i32) -> i32 {
    local n: i32
    local d: i32
    local original-ptr: .i32
    local original-len: i32
    $pt #original-ptr
    $len #original-len
    loop {
        $pt load8 #d
        $d 48 >= $d 58 <= and if { // 48 is ascii '0'
            $n $d 48 - + #n
        } else {
            1 "Failed to parse: '" IO:write-all IO:check
            1 $original-ptr $original-len IO:write-all IO:check
            1 "'" IO:write-all IO:check
            1 10 IO:write-byte IO:check
            1 CORE:exit
        }
        $pt 1 + #pt // advance pointer
        $len 1 - #len // reduce length
        $len 0 = if { $n break }
        $n 10 * #n
    }
}

//fn i64-format(self: i64, formatter: .FMT:Formatter) {
//    memory buf-reversed: i32 24;
//    $formatter $buf-reversed $self $buf-reversed IO:print-i64-into FMT:Formatter-write
//}
fn i32-format(self: i32, formatter: .FMT:Formatter) {
    memory buf: i32 24;
    $formatter $buf $self $buf IO:print-i32-into FMT:Formatter-write
}

//fn format-i64(n: i64) -> .S:String {
//    memory buf-reversed: i32 24;
//    $buf-reversed $n $buf-reversed IO:print-i64-into S:String-new
//}

fn format-i32(n: i32) -> .S:String {
    memory buf: i32 24;
    $buf $n $buf IO:print-i32-into S:String-new
}

