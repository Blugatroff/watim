import "./alloc.watim" as A
import "./io.watim" as IO
import "./core.watim" as CORE

struct I32Vec {
    ptr: .i32
    len: i32
    cap: i32
}

fn I32Vec-new() -> I32Vec {
    local self: I32Vec
    0 !.i32 #self.ptr
    0 #self.len
    0 #self.cap
    $self
}
fn I32Vec-len(vec: .I32Vec) -> i32 {
    $vec.len
}
fn I32Vec-get(vec: .I32Vec, index: i32) -> i32 {
    $index $vec I32Vec-len ge if { 
        2 "Index out of bounds\n" IO:write-all IO:check
        0 0 / drop
        1 CORE:exit
    }
    $vec.ptr $index 4 * + ~
}

fn I32Vec-set(self: .I32Vec, index: i32, value: i32) -> i32 {
    $index $self I32Vec-len ge if {
        2 "Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    $self $index I32Vec-get 
    $self.ptr $index 4 * + $value store
}
fn I32Vec-free(self: I32Vec) {
    $self.cap 0 gt if { $self.ptr A:free }
}
fn I32Vec-push(vec: .I32Vec, val: i32) {
    local new-buf: .i32
    local size: i32
    $vec.len 1 + $vec.cap le if {
        $vec.ptr $vec.len 4 * + $val store
        $vec.len 1 + #vec.len
    } else {
        $vec.cap 2 CORE:max 2 * #size
        $size 4 * A:alloc #new-buf
        $vec.ptr !.i32
        $new-buf !.i32
        $vec.len 4 *
        CORE:copy
        $size #vec.cap
        $vec.len 0 gt if {
            $vec.ptr !.i32 A:free
        }
        $new-buf #vec.ptr
        $vec $val I32Vec-push
    }
}
fn I32Vec-pop(self: .I32Vec) -> i32 {
    $self I32Vec-len 0 = if { 
        1 "Cannot pop from emtpy I32Vec" IO:write-all IO:check
        1 CORE:exit
    }
    $self $self I32Vec-len 1 - I32Vec-get
    $self.len 1 - #self.len
}
fn I32Vec-clone(self: .I32Vec) -> I32Vec {
    local new: I32Vec
    local i: i32
    I32Vec-new #new
    loop {
        $i $self I32Vec-len = if { break }
        &new $self $i I32Vec-get I32Vec-push
        $i 1 + #i
    }
    $new
}

