import "./core.watim" as CORE
import "./io.watim" as IO
import "./arena.watim" as A
import "./fmt.watim" as FMT
import "./byte-slice.watim" as ByteSlice
import "./byte-array.watim" as ByteArray

struct Array<T> {
    ptr: .T
    len: i32
    cap: i32
    arena: .A:Arena
}

fn new<T>() -> Array<T> {
    local self: Array<T>
    0 !.T #self.ptr
    0 #self.len
    0 #self.cap
    0 !.A:Arena #self.arena
    $self
}
fn check-same-arena<T>(self: .Array<T>, arena: .A:Arena) {
    $self.arena 0 !.A:Arena = if {
        $arena #self.arena
    } else {
        $self.arena $arena /= if {
            2 "Array: used different arenas\n" IO:write-all IO:check
            0 0 / drop
        }
    }
}
fn new-with-capacity<T>(arena: .A:Arena, elems: i32) -> Array<T> {
    local self: Array<T>
    $arena #self.arena
    $elems #self.cap
    $arena $self.cap A:alloc-many<T> #self.ptr
    0 #self.len
    $self
}
fn init<T>(arena: .A:Arena, ptr: .T, elems: i32) -> Array<T> {
    local self: Array<T>
    $elems #self.cap
    $arena $ptr $elems A:push-many<T> #self.ptr
    $elems #self.len
    $arena #self.arena
    $self
}
fn push<T>(arena: .A:Arena, self: .Array<T>, val: T) {
    $self $arena check-same-arena<T>
    $self.len 1 + $self.cap le if {
        $self.ptr $self.len sizeof(T) * + $val store
        $self.len 1 + #self.len
    } else {
        $arena A:save @save
        $self.ptr $self.cap + $arena A:alloc<T> = if {
            // Optimization in case the newly allocated bytes immediately 
            // follow the already allocated bytes of this ByteArray.
            $self.cap 1 + #self.cap
            $self $val push-assert-no-alloc<T>
        } else {
            $arena $save A:restore
            $self.cap 2 CORE:max 2 * #self.cap
            $arena $self.cap A:alloc-many<T> @new-buf
            $self.ptr $new-buf $self.len CORE:copy<T>
            $new-buf #self.ptr
            $self $val push-assert-no-alloc<T>
        }
    } 
}
fn push-assert-no-alloc<T>(self: .Array<T>, val: T) {
    $self.len 1 + $self.cap le if {
        $self.ptr $self.len sizeof(T) * + $val store
        $self.len 1 + #self.len
    } else {
        2 "Array:push-assert-no-alloc: needed to allocate, assert failed!\n" IO:write-all IO:check
        0 0 / drop
        1 CORE:exit
    }
}
fn get<T>(self: .Array<T>, index: i32) -> .T {
    $index $self.len ge if {
        2 "Index out of bounds\n" IO:write-all IO:check
        0 0 / drop
        1 CORE:exit
    }
    $self.ptr $index sizeof(T) * +
}
fn last<T>(self: .Array<T>) -> .T {
    $self $self.len 1 - get<T>
}
fn set<T>(self: .Array<T>, index: i32, value: T) -> T {
    $self $index get<T> CORE:dup<.T> ~ flip $value store
}
fn pop<T>(self: .Array<T>) -> T {
    $self.len 0 = if {
        2 "Cannot pop from empty Array" IO:write-all IO:check
        1 CORE:exit
    }
    $self $self.len 1 - get<T> ~ 
    $self.len 1 - #self.len
}
fn clone<T>(arena: .A:Arena, self: .Array<T>) -> Array<T> {
    $arena $self.ptr $self.len init<T>
}
fn format<T>(formatter: .FMT:Formatter, format-element: (.FMT:Formatter, .T ->), self: .Array<T>) {
    $formatter "[" FMT:Formatter-write
    0 @i
    loop {
        $i $self.len = if { break }
        $formatter $self $i get<T> $format-element ->
        $i 1 + #i
        $i $self.len /= if { $formatter ", " FMT:Formatter-write }
    }
    $formatter "]" FMT:Formatter-write
}
fn print<T>(fd: i32, print-element: (i32, .T -> i32), self: .Array<T>) -> i32 { block {
    $fd "[" IO:write-all @code
    $code 0 /= if { $code break }
    0 @i
    loop {
        $i $self.len = if { 0 break }
        $fd $self $i get<T> $print-element -> #code
        $code 0 /= if { $code break }
        $i 1 + #i
        $i $self.len /= if {
            $fd ", " IO:write-all #code
            $code 0 /= if { $code break }
        }
    } #code $code 0 /= if { $code break }
    $fd "]" IO:write-all
} }
fn find<T, A>(self: .Array<T>, compare: (.T, A -> bool), value: A) -> i32, bool {
    local i: i32
    loop {
        $i $self.len = if { 0 0 1 = break }
        $self $i get<T> $value $compare -> if {
            $i 1 1 = break
        }
        $i 1 + #i
    }
}
fn find-ref<T, A>(self: .Array<T>, compare: (.T, A -> bool), value: A) -> .T, bool {
    $self $compare $value find<T, A> if {
        $self flip get<T> 1 1 =
    } else {
        drop 0 !.T 0 1 =
    }
}
fn remove<T>(self: .Array<T>, index: i32) -> T {
    $self $index get<T> ~ @value
    $self.ptr $index 1 + sizeof(T) * +
    $self.ptr $index sizeof(T) * +
    $self.len $index - 1 -
    CORE:copy<T>
    $self.len 1 - #self.len
    $value
}
fn swap<T>(self: .Array<T>, a: i32, b: i32) {
    $a $b /= if {
        $self $a
        $self $b $self $a get<T> ~ set<T>
        set<T> drop
    }
}
fn reverse<T>(self: .Array<T>) { block {
    $self.len 1 le if { break }
    0 @i
    loop {
        $self.len 1 - $i - @j
        $i $j ge if { break }
        $self $i $j swap<T>
        $i 1 + #i
    }
} }
fn find-remove<T, A>(self: .Array<T>, compare: (.T, A -> bool), value: A) -> T, i32, bool {
    local uninit: T
    $self $compare $value find<T, A> if {
        @i
        $self $i remove<T>
        $i 1 1 =
    } else { 
        $uninit flip 0 1 =
    }
}
fn join-with(arena: .A:Arena, self: .Array<ByteSlice:T>, del-ptr: .i32, del-len: i32) -> ByteArray:T {
    ByteArray:new @out
    0 @i
    loop {
        $i $self.len = if { break }
        $arena &out $self $i get<ByteSlice:T> ~ ByteSlice:unpack ByteArray:push
        $i 1 + $self.len /= if {
            $arena &out $del-ptr $del-len ByteArray:push
        }
        $i 1 + #i
    }
    $out
}
// fn map<T, O>(arena: .A:Arena, self: .Array<T>, f: (.T -> O)) -> Array<O> {
//     Array:new<O> @new // TODO: Optimize this by creating an array with the already known minimum capacity to avoid resizing.
//     0 @i
//    loop {
//        $i $self.len = if { break }
//        $arena &new $self $i Array:get<T> $f -> Array:push<O>
//        $i 1 + #i
//    }
//    $new
// }

