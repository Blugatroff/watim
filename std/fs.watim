import "../std/core.watim" as CORE
import "../std/io.watim" as IO
import "../std/str.watim" as STR
import "../std/arena.watim" as Arena
import "../std/array.watim" as Array
import "../std/byte-array.watim" as ByteArray

extern "wasi_snapshot_preview1" "fd_prestat_get" fn fd_prestat_get(fd: i32, prestat: .Prestat) -> i32
extern "wasi_snapshot_preview1" "fd_prestat_dir_name" fn fd_prestat_dir_name(fd: i32, path: .i32, len: i32) -> i32
extern "wasi_snapshot_preview1" "path_open" fn path_open(
    fd: i32, 
    dirflags: i32, 
    path: .i32, 
    path_len: i32, 
    oflags: i32, 
    fs_rights_base: i64, 
    fs_rights_inheriting: i64, 
    fd_flags: i32, 
    res_fd: .i32
) -> i32

fn create-rights(read: bool, write: bool) -> i64 {
    $read !i64 1 rotl // 1 << 1
    $write !i64 5 rotl
    or
}

struct PreopenedFd {
    path: STR:Str
    fd: i32
}
fn PreopenedFd-new(fd: i32, path: STR:Str) -> PreopenedFd {
    local self: PreopenedFd
    $fd #self.fd
    $path #self.path
    $self
}
struct FileSystem {
    preopened-fds: Array:Array<PreopenedFd>
}
fn FileSystem-new(preopened-fds: Array:Array<PreopenedFd>) -> FileSystem {
    local fs: FileSystem
    $preopened-fds #fs.preopened-fds
    $fs
}

fn init(arena: .Arena:Arena) -> FileSystem, i32 {
    local prestat: Prestat
    0 @code
    3 @fd
    $arena Arena:save @restore
    Array:new<PreopenedFd> @fds
    $arena Arena:temp @temp @temp-save
    loop {
        $fd &prestat fd_prestat_get #code
        // 8 = Bad file descriptor
        $code 8 = if { 
            0 #code
            break 
        }
        $code 0 /= if {
            break
        }
        $prestat.path_len @len

        $arena $len Arena:alloc-bytes @buf
        $fd $buf $len fd_prestat_dir_name #code
        $code 0 /= if {
            break
        }
        $buf $len STR:Str-new @path
        $temp &fds $fd $path PreopenedFd-new Array:push<PreopenedFd>
        $fd 1 + #fd
    }
    $arena $fds.ptr $fds.len Array:init<PreopenedFd> FileSystem-new $code
    $code 0 /= if {
        $arena $restore Arena:restore
    }
    $temp $temp-save Arena:restore
}
// returns 0, 0 if not found
// returns 0, e if error
fn find-current-dir(fs: .FileSystem) -> i32, i32 {
    0 @i
    loop {
        $i $fs.preopened-fds.len = if { 
            // not found
            2 "failed to find preopened current directory\n" IO:write-all IO:check
            1 CORE:exit
            0 0 break
        }
        &fs.preopened-fds $i Array:get<PreopenedFd> @preopened-fd
        $preopened-fd.path STR:Str-unpack "." STR:str-is-prefix
        if { $preopened-fd.fd 0 break }
        $i 1 + #i
    }
}

struct Prestat {
    kind: i32
    path_len: i32
}

fn path-dir(path-ptr: .i32, path-len: i32) -> .i32, i32 {
    local index: i32
    $path-ptr $path-len "/" drop load8 STR:str-find-rev if {
        #index $path-ptr $index
    } else {
        drop $path-ptr $path-len
    }
}


fn str-replace(arena: .Arena:Arena, ptr: .i32, len: i32, target-ptr: .i32, target-len: i32, replacement-ptr: .i32, replacement-len: i32) -> .i32, i32 {
    $arena 0 Arena:alloc-bytes @new-ptr
    0 @new-len
    $ptr $len $target-ptr $target-len STR:str-find-str if {
        @index
        $arena $ptr $index Arena:push-bytes drop
        $arena $replacement-ptr $replacement-len Arena:push-bytes drop
        $new-len $index + $replacement-len + #new-len
        
        $arena
        $ptr $index + $target-len + @next-ptr $next-ptr
        $len $index - $target-len -
        $target-ptr
        $target-len
        $replacement-ptr
        $replacement-len
        str-replace @new-next-len @new-next-ptr

        $arena $new-next-ptr $new-next-len Arena:push-bytes drop
        $new-len $new-next-len + #new-len

        $new-ptr $new-len
    } else {
        drop $ptr $len
    }
}
fn str-split(arena: .Arena:Arena, str-ptr: .i32, str-len: i32, del: i32) -> Array:Array<STR:Str> {
    Array:new<STR:Str> @splits
    loop {
        $str-len 0 = if { break }
        $str-ptr $str-len $del STR:str-find if {
            @index
            $arena &splits $str-ptr $index STR:Str-new Array:push<STR:Str>
            $str-ptr $index + 1 + #str-ptr
            $str-len $index - 1 - #str-len
        } else {
            drop
            $arena &splits $str-ptr $str-len STR:Str-new Array:push<STR:Str>
            break
        }
    }
    $splits
}

fn normalize(arena: .Arena:Arena, path-ptr: .i32, path-len: i32) -> .i32, i32 {
    $arena Arena:temp @temp @temp-save
    $temp 0 Arena:alloc-bytes @out-ptr
    0 @out-len

    $path-ptr $path-len "./" STR:str-is-prefix not if {
        $temp "./" Arena:push-bytes drop
        $out-len 2 + #out-len
    }
    $temp $path-ptr $path-len Arena:push-bytes drop
    $out-len $path-len + #out-len
    
    $temp $out-ptr $out-len "//" "/" str-replace #out-len #out-ptr
    $temp $out-ptr $out-len "/./" "/" str-replace #out-len #out-ptr
    $temp $out-ptr $out-len "./." "." str-replace #out-len #out-ptr

    $temp $out-ptr $out-len "/" drop load8 str-split @splits
    Array:new<STR:Str> @outsplits
    0 @i
    loop {
        $i $splits.len = if { break }
        block {
            $i 1 + $splits.len /= if {
                &splits $i 1 + Array:get<STR:Str> ~ STR:Str-unpack ".." STR:str-eq 
                &splits $i Array:get<STR:Str> ~ STR:Str-unpack "." STR:str-eq not and
                &splits $i Array:get<STR:Str> ~ STR:Str-unpack ".." STR:str-eq not and
                if {
                    $i 1 + #i break
                }
            }
            $temp &outsplits &splits $i Array:get<STR:Str> ~ Array:push<STR:Str>
        }
        $i 1 + #i
    }
    $temp &outsplits "/" Array:join-with @out
    $path-ptr $path-len $out STR:Str-unpack STR:str-eq if {
        $arena $out STR:Str-unpack Arena:push-bytes $out.len
    } else {
        $arena $out STR:Str-unpack normalize
    }
    $temp $temp-save Arena:restore
}

fn open-file(fs: .FileSystem, path: .i32, path_len: i32, rights: i64, inheriting_rights: i64) -> i32, i32 {
    local fd: CORE:I32
    $fs find-current-dir @code @parent-fd
    $code 0 /= if {
        0 $code
    } else {
        $parent-fd 0 $path $path_len 0 $rights $inheriting_rights 0 &fd.inner path_open #code
        $fd.inner $code
    }
}

fn read-file(arena: .Arena:Arena, fs: .FileSystem, path: .i32, path-len: i32) -> STR:Str, i32 {
    $fs
    $path $path-len
    0 0 = 0 1 = create-rights
    0 1 = 0 1 = create-rights
    open-file @code @fd
    $code 0 /= if {
        STR:Str-empty $code
    } else {
        $arena $fd read-all
    }
}

fn read-all(arena: .Arena:Arena, file: i32) -> STR:Str, i32 {
    64 @buf-size
    $arena Arena:temp @temp @temp-save
    $temp $buf-size Arena:alloc-bytes @buf
    ByteArray:new @out

    loop {
        $file $buf $buf-size IO:read @code @read
        $code 0 /= if {
            0!.i32 0 STR:Str-new $code break
        }
        $read 0 = if {
            &out ByteArray:unpack STR:Str-new 0 break
        } else {
            $arena &out $buf $read ByteArray:push
        }
    }
    $temp $temp-save Arena:restore
}

