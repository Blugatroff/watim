import "./alloc.watim" as A
import "./core.watim" as CORE
import "./io.watim" as IO

struct DynArray<B> {
    ptr: .B
    len: i32
    cap: i32
    free: (B ->)
}

fn new<T>(free: (T ->)) -> DynArray<T> {
    local self: DynArray<T>
    0 !.T #self.ptr
    0 #self.len
    0 #self.cap
    $free #self.free
    $self
}
fn push<T>(self: .DynArray<T>, val: T) {
    local new-buf: .T
    local size: i32
    $self.len 1 + $self.cap le if {
        $self.ptr $self.len sizeof(T) * + $val store
        $self.len 1 + #self.len
    } else {
        $self.cap 2 CORE:max 2 * #size
        $size sizeof(T) * A:alloc !.T #new-buf
        $self.ptr !.i32
        $new-buf !.i32
        $self.len sizeof(T) *
        CORE:copy
        $size #self.cap
        $self.len 0 gt if {
            $self.ptr !.i32 A:free
        }
        $new-buf #self.ptr
        $self $val push<T>
    } 
}
fn get<T>(self: .DynArray<T>, index: i32) -> .T {
    $index $self.len ge if { 
        2 "Index out of bounds\n" IO:write-all IO:check
        0 0 / drop
        1 CORE:exit
    }
    $self.ptr $index sizeof(T) * +
}
fn pop<T>(self: .DynArray<T>) -> T {
    $self.len 0 = if {
        2 "Cannot pop from empty DynArray" IO:write-all IO:check
        1 CORE:exit
    }
    $self $self.len 1 - get<T> ~ 
    $self.len 1 - #self.len
}
fn free<T>(self: DynArray<T>) {
    0 @i
    loop {
        $i $self.len = if { break }
        &self $i get<T> ~ $self.free ->
        $i 1 + #i
    }
    $self.ptr 0 !.T /= if { $self.ptr !.i32 A:free }
}

