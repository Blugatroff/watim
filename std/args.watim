import "./string.watim" as S
import "./io.watim" as IO
import "./alloc.watim" as A
import "./arena.watim" as Arena
import "./dyn-array.watim" as DynArray
import "./core.watim" as CORE

extern "wasi_unstable" "args_sizes_get" fn args_sizes_get(number: .i32, size: .i32) -> i32
extern "wasi_unstable" "args_get" fn args_get(argv: ..i32, argv_buf: .i32) -> i32

fn get-args(arena: .Arena:Arena) -> DynArray:DynArray<S:String> {
    local arg_number_ptr: CORE:I32
    local arg_sizes_ptr: CORE:I32
    &arg_number_ptr.inner &arg_sizes_ptr.inner args_sizes_get IO:check
    $arg_number_ptr.inner @arg_number
    $arg_sizes_ptr.inner @arg_sizes
    $arg_sizes A:alloc @arg_buf
    $arg_number sizeof(i32) * A:alloc @ptr_buf

    $ptr_buf !..i32 $arg_buf args_get IO:check

    0 !(S:String ->) DynArray:new<S:String> @strings

    0 @i
    loop {
        $i $arg_number ge if { break }
        $ptr_buf $i 4 * + ~ !.i32 @ptr
        $arena &strings 
        $arena $ptr $ptr cstr-len S:String-newA
        DynArray:pushA<S:String>
        $i 1 + #i
    }
    $ptr_buf A:free
    $arg_buf A:free
    $strings
}

fn cstr-len(ptr: .i32) -> i32 {
    local i: i32
    loop {
        $ptr load8 0 = if { $i break }
        $i 1 + #i
        $ptr 1 + #ptr
    }
}

