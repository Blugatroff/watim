import "./io.watim" as IO
import "./core.watim" as CORE

memory LOGGING: bool 4
fn enable-logging() {
    $LOGGING 0 0 = store
}
fn disable-logging() {
    $LOGGING 0 1 = store
}
fn logging() -> bool {
    $LOGGING !.i32 ~ 0 /=
}
memory ROOT: .i32 4
memory BUF_SIZE: i32 4
memory N_ALLOCS: i32 4
memory N_FREES: i32 4
fn root() -> .i32 {
    $ROOT ~
}
fn set-root(root: .i32) {
    $ROOT $root store
}
fn buf-size() -> i32 {
    $BUF_SIZE ~
}
fn set-buf-size(size: i32) {
    $BUF_SIZE $size store
}
fn n-allocs() -> i32 {
    $N_ALLOCS ~
}
fn n-frees() -> i32 {
    $N_FREES ~
}
fn set-n-allocs(n: i32) {
    $N_ALLOCS $n store
}
fn set-n-frees(n: i32) {
    $N_FREES $n store
}
fn inc-n-allocs() {
    n-allocs 1 + set-n-allocs 
}
fn inc-n-frees() {
    n-frees 1 + set-n-frees
}

fn init(mem: .i32, size: i32) {
    local next: .i32
    
    logging if { 2 "ALLOC RESET: \n" IO:write-all IO:check }
    $mem set-root
    $size set-buf-size
    // Set the next pointer of the init block to 0 since there is only this block. 
    0 !.i32 #next
    // Store the next pointer in the block.
    root $next !i32 store
    // Store the size of the block.
    root 4 + $size store
    // Mark this block as unused.
    root 8 + 0 store
    0 set-n-allocs
    0 set-n-frees
}

fn alloc(size: i32) -> .i32 {
    local prev: .i32
    local block: .i32
    local next: .i32
    local block-size: i32
    local new-block: .i32
    local n: i32
    local unused: bool
    $size 4 CORE:align-to #size
    root #prev
    root #block
    loop {
        $block ~ !.i32 #next
        $block 4 + ~ #block-size
        $block 8 + ~ 0 = #unused

        // Test whether this block has enough space for the requested size + the BLOCK_SIZE.
        $block-size $size 12 + >= $unused and if {
            // Is there enough remaining space to split this block in two$
            $block-size $size 12 + 12 + >= if {
                // Calculate the position of the new block.
                $block 12 $size + + #new-block
                // Load the block after the one we are splitting.
                $block ~ #n
                // Set the next-pointer of the new block.
                $new-block $n store
                // Set the size of the new block.
                $new-block 4 + $block-size 12 - $size - store
                // Mark the new block as unused.
                $new-block 8 + 0 store
            } else {
                0 !.i32 #new-block
            }
            $new-block !i32 0 = if {
                $block !..i32 $next store
            } else {
                $new-block !i32 >>block

                // only adjust the size of the block if it was split
                $block 4 + $size 12 + store
            }
            $block 8 + 1 store

            root $prev = if {
                root 8 + ~ 0 /= if { // if the root is used
                    $new-block !i32 0 = if {
                        root find-next-free set-root
                    } else {
                        $new-block set-root
                    }
                }
            } else {
                $new-block !i32 0 = if {
                    $prev $block find-next-free !i32 store
                } else {
                    $prev $new-block !i32 store
                }
            }
            logging if { 
                2 "ALLOCED ptr: " IO:write-all IO:check 
                2 $block 12 + !i32 IO:print-to-fd
                2 " size: " IO:write-all IO:check 
                2 $size IO:print-to-fd
                2 " n-allocs: " IO:write-all IO:check 
                2 n-allocs 1 + IO:print-to-fd
                2 "\n" IO:write-all IO:check
            }
            inc-n-allocs
            $block 12 + break
        }
        $next !i32 0 = if {
            2 "ALLOC FAILED NO MEMORY size: " IO:write-all IO:check 
            2 $size IO:print-to-fd 1 "\n" IO:write-all IO:check
            1 CORE:exit
            0 !.i32 break
        }
        $block #prev
        $next #block
    }
}

fn find-next-free(block: .i32) -> .i32 {
    local b: .i32
    root #b
    loop {
        $b !i32 0 = if { 0 !.i32 break }
        $b 8 + ~ 0 =
        $b !i32 $block !i32 > 
        and
        if {
            $b break
        }
        $b !..i32 ~ #b
    }
}

fn find-prev-free(block: .i32) -> .i32 {
    local b: .i32
    root #b
    loop {
        $b ~ $block !i32 >= if {
            $b break
        }
        $b ~ !.i32 #b
    }
}

fn free(ptr: .i32) {
    local block: .i32
    local next: .i32
    local next-free: .i32
    local b: .i32
    local size: i32
    $ptr 12 - #block
    $block ~ !.i32 #next
    $block find-next-free #next-free
    $block 4 + ~ 12 - #size

    logging if { 
        2 "FREEING ptr: " IO:write-all IO:check 
        2 $ptr !i32 IO:print-to-fd
        2 " size: " IO:write-all IO:check 
        2 $size IO:print-to-fd
        2 " n-allocs: " IO:write-all IO:check 
        2 n-allocs n-frees - 1 - IO:print-to-fd
        2 "\n" IO:write-all IO:check 
    }
    $block $next-free !i32 store
    $block 8 + 0 store

    root !i32 $block !i32 > if {
        $block set-root
    } else {
        $block root = // The root block is being freed
        root ~ 0 = // The root has no next block
        and if {
            // The last block is being freed, therefore 
            // everything is free and we can simply reset.
            root buf-size init
        } else {
            $block find-prev-free !..i32 $block store
       }
    }
    inc-n-frees
    $ptr $size clear
    merge
}

fn clear(ptr: .i32, len: i32) {
    local i: i32
    loop {
        $i $len = if { break }
        $ptr $i + 0 store8
        $i 1 + #i
    }
}

fn merge() {
    local block: .i32
    local next: .i32
    local size: i32
    local used: bool
    local next-next: .i32
    local next-size: i32
    local next-used: bool

    root #block
    loop {
        $block !i32 0 = if { break }
        $block ~ !.i32 #next
        $next !i32 0 = if { break }
        
        $block 4 + ~ #size
        $block 8 + ~ 0 /= #used
        $next ~ !.i32 #next-next
        $next 4 + ~ #next-size
        $next 8 + ~ 0 /= #next-used

        $block $size + $next = $used not and $next-used not and if {
            $block $next-next !i32 store
            $block 4 + $size $next-size + store
        } else {
            $next #block
        }
    }
}

fn print-alloc-list(start: .i32) {
    local block: .i32
    local next: .i32
    local size: i32
    local used: bool
    $start #block
    2 "BLOCK LIST STARTING AT: " IO:write-all IO:check $block !i32 IO:print 1 10 IO:write-byte IO:check
    loop {
        $block !i32 0 = if { break }
        $block ~ !.i32 #next
        $block 4 + ~ #size
        $block 8 + ~ 0 > #used

        2 "\t" IO:write-all IO:check 
        2 $block !i32 IO:print-to-fd
        2 ": " IO:write-all IO:check
        2 " " IO:write-all IO:check
        2 $next !i32 IO:print-to-fd
        2 " " IO:write-all IO:check
        2 $size IO:print-to-fd
        2 " " IO:write-all IO:check
        2 $used !i32 IO:print-to-fd
        2 "\n" IO:write-all IO:check 
        
        $next #block
    }
}

fn size-of-largest-free-block() -> i32 {
    local block: .i32
    local max: i32
    root #block
    loop {
        $block !i32 0 = if { break }
        $block 4 + ~ $max CORE:max #max 
        $block ~ !.i32 #block
    }
    $max
}

fn is-empty() -> bool {
    usage 0 =
}

fn usage() -> i32 {
    buf-size remaining - 
}

fn remaining() -> i32 {
    local block: .i32
    local free: i32
    root #block
    loop {
        $block !i32 0 = if { break }
        $block 4 + ~ $free + #free
        $block ~ !.i32 #block
    }
    $free
}

fn report(fd: i32) {
    $fd "Memory usage: \n\t" IO:write-all IO:check 
    $fd usage IO:print-to-fd
    $fd " bytes,\n\tlargest free block: " IO:write-all IO:check
    $fd size-of-largest-free-block IO:print-to-fd
    $fd "\n\tactive allocations: " IO:write-all IO:check
    $fd n-allocs n-frees - IO:print-to-fd
    $fd "\n\ttotal allocations: " IO:write-all IO:check
    $fd n-allocs IO:print-to-fd
    $fd "\n" IO:write-all IO:check
}

