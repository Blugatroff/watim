import "./io.watim" as IO
import "./core.watim" as CORE

memory LOGGING: bool 4 4;
fn enable-logging() {
    $LOGGING 0 0 = store32
}
fn disable-logging() {
    $LOGGING 0 1 = store32
}
fn logging() -> bool {
    $LOGGING !.i32 load32 0 /=
}
memory ROOT: .i32 4 4;
memory BUF_SIZE: i32 4 4;
fn root() -> .i32 {
    $ROOT load32
}
fn set-root(root: .i32) {
    $ROOT $root store32
}
fn buf-size() -> i32 {
    $BUF_SIZE load32
}
fn set-buf-size(size: i32) {
    $BUF_SIZE $size store32
}

fn init(mem: .i32, size: i32) {
    local next: .i32
    
    logging if { 1 "ALLOC RESET: \n" IO:write_all IO:check }
    $mem set-root
    $size set-buf-size
    // Set the next pointer of the init block to 0 since there is only this block. 
    0 !.i32 #next
    // Store the next pointer in the block.
    root $next !i32 store32
    // Store the size of the block.
    root 4 + $size store32
    // Mark this block as unused.
    root 8 + 0 store32
}

fn alloc(size: i32) -> .i32 {
    local prev: .i32
    local block: .i32
    local next: .i32
    local block-size: i32
    local new-block: .i32
    local n: i32
    local unused: bool
    
    $size 4 CORE:align-to #size
    root #prev
    root #block

    loop {
        $block load32 !.i32 #next
        $block 4 + load32 #block-size
        $block 8 + load32 0 = #unused

        // Test whether this block has enough space for the requested size + the BLOCK_SIZE.
        $block-size $size 12 + >= $unused and if {
            // Is there enough remaining space to split this block in two?
            $block-size 12 - $size - 12 >= if {
                // Calculate the position of the new block.
                $block 12 $size + + #new-block
                // Load the block after the one we are splitting.
                $block load32 #n
                // Set the next-pointer of the new block.
                $new-block $n store32
                // Set the size of the new block.
                $new-block 4 + $block-size 12 - $size - store32
                // Mark the new block as unused.
                $new-block 8 + 0 store32
            } else {
                0 !.i32 #new-block
            }
            $block !..i32 $new-block store32
            $block 4 + $size 12 + store32
            $block 8 + 1 store32

            root $prev = if {
                $new-block !i32 0 = if {
                    $block set-root
                } else {
                    $new-block set-root
                }
            } else {
                $prev $new-block !i32 store32
            }

            logging if { 1 "ALLOCED ptr: " IO:write_all IO:check $block 12 + !i32 IO:print 1 " size: " IO:write_all IO:check $size IO:print 1 "\n" IO:write_all IO:check }
            $block 12 + break
        }
        $next !i32 0 = if {
            0 !.i32 break
        }
        $block #prev
        $next #block
    }
}

fn find_next_free(block: .i32) -> .i32 {
    loop {
        $block !i32 0 = if { 0 !.i32 break }
        $block 8 + load32 0 = if {
            $block break
        }
        $block !..i32 load32 #block
    }
}

fn find_prev_free(block: .i32) -> .i32 {
    local b: .i32
    root #b
    loop {
        $b load32 $block !i32 >= if {
            $b break
        }
        $b load32 !.i32 #b
    }
}

fn free(ptr: .i32) {
    local block: .i32
    local next: .i32
    local next_free: .i32
    local b: .i32
    local size: i32
    
    $ptr 12 - #block
    $block load32 !.i32 #next
    $next find_next_free #next_free
    $block 4 + load32 12 - #size
    logging if { 1 "FREEING ptr: " IO:write_all IO:check $ptr !i32 IO:print 1 " size: " IO:write_all IO:check $size IO:print 1 "\n" IO:write_all IO:check }
    $block $next_free !i32 store32
    $block 8 + 0 store32

    root !i32 $block !i32 > if {
        $block set-root
    } else {
        $block root = root load32 0 = and if {
            // The last block is being freed, therefore 
            // everything is free and we can simply reset.
            root buf-size init
        } else {
            $block find_prev_free !..i32 $block store32
       }
    }
    merge
}

fn merge() {
    local block: .i32
    local next: .i32
    local size: i32
    local used: bool
    local next_next: .i32
    local next_size: i32
    local next_used: bool

    root #block

    loop {
        $block !i32 0 = if { break }
        $block load32 !.i32 #next
        $next !i32 0 = if { break }
        
        $block 4 + load32 #size
        $block 8 + load32 0 /= #used
        $next load32 !.i32 #next_next
        $next 4 + load32 #next_size
        $next 8 + load32 0 /= #next_used

        $block $size + $next = $used not and $next_used not and if {
            $block $next_next !i32 store32
            $block 4 + $size $next_size + store32
        } else {
            $next #block
        }
    }
}

fn print_alloc_list(start: .i32) {
    local block: .i32
    local next: .i32
    local size: i32
    local used: bool
    $start #block
    1 "BLOCK LIST STARTING AT: " IO:write_all IO:check $block !i32 IO:print 1 10 IO:write_byte IO:check
    loop {
        $block !i32 0 = if { break }
        $block load32 !.i32 #next
        $block 4 + load32 #size
        $block 8 + load32 0 > #used

        1 9 IO:write_byte IO:check 
        $block !i32 IO:print
        1 ": " IO:write_all IO:check
        1 " " IO:write_all IO:check
        $next !i32 IO:print
        1 " " IO:write_all IO:check
        $size IO:print
        1 " " IO:write_all IO:check
        $used !i32 IO:print
        1 10 IO:write_byte IO:check 

        $next #block
    }
}

fn is_empty() -> bool {
    root 4 + load32 buf-size =
}

