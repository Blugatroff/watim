import "./alloc.watim" as A
import "./core.watim" as CORE
import "./io.watim" as IO
import "./string.watim" as S

struct String {
    ptr: .i32
    len: i32
    cap: i32
}
fn String-empty() -> String {
    local self: String
    0 !.i32 @self.ptr
    0 @self.len
    0 @self.cap
    ?self
}
fn String-new(ptr: .i32, len: i32) -> String {
    local buf: .i32
    ?len A:alloc @buf
    ?ptr ?buf ?len CORE:copy
    ?buf ?len String-new-from-buf
}
fn String-new-from-buf(ptr: .i32, len: i32) -> String {
    local self: String
    ?ptr @self.ptr
    ?len @self.len
    ?len @self.cap
    ?self
}
fn String-push(self: .String, char: i32) {
    local new-buf: .i32
    local size: i32
    local ptr: .i32
    ?self.len 1 + ?self.cap > if {
        ?self.cap 2 CORE:max 2 * @size
        ?size A:alloc @new-buf
        ?self.ptr ?new-buf ?self.len CORE:copy
        $self.cap @ptr
        ?size >>ptr
        ?self.ptr !i32 0 /= if {
            ?self.ptr A:free
        }
        ?new-buf @self.ptr
        ?self ?char String-push
    } else {
        ?self.ptr ?self.len + ?char store8
        ?self.len 1 + @self.len
    }
}
fn String-append(self: .String, ptr: .i32, len: i32) {
    local i: i32
    loop {
        ?i ?len = if { break }
        ?self ?ptr ?i + load8 String-push
        ?i 1 + @i
    }
}
fn String-unpack(self: .String) -> .i32, i32 {
    ?self.ptr ?self.len
}
fn String-free(self: String) {
    ?self.ptr 0 !i32 /= if {
        ?self.ptr A:free
    }
}
fn String-len(self: .String) -> i32 {
    ?self.len
}
fn String-clone(self: .String) -> String {
    ?self String-unpack String-new
}
fn String-merge(self: String, other: String) -> String {
    &self &other String-unpack String-append
    ?other String-free
    ?self
}

struct StringVec {
    ptr: .String
    len: i32
    cap: i32
}
fn StringVec-new() -> StringVec {
    local self: StringVec
    0 !.String @self.ptr
    0 @self.len
    0 @self.cap
    ?self
}
fn StringVec-len(self: .StringVec) -> i32 {
    ?self.len
}
fn StringVec-get(self: .StringVec, index: i32) -> .String {
    ?index ?self StringVec-len >= if { 
        1 "Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    ?self.ptr ?index sizeof(String) * +
}
fn StringVec-free(self: StringVec) {
    local i: i32
    local s: .String
    loop {
        ?i ?self.len = if { break }
        &self ?i StringVec-get ~ String-free
        ?i 1 + @i
    }
    &self StringVec-len 0 > if { 
        ?self.ptr !.i32 A:free 
    }
}
fn StringVec-push(self: .StringVec, str: String) {
    local new-buf: .String
    local size: i32
    local ptr: .String
    ?self.len 1 + ?self.cap <= if {
        ?self.ptr ?self.len sizeof(String) * + @ptr
        ?str >>ptr
        // increment len
        ?self.len 1 + @self.len
    } else {
        ?self.cap 2 CORE:max 2 * @size
        ?size sizeof(String) * A:alloc !.String @new-buf
        ?self.ptr !.i32
        ?new-buf !.i32
        ?self.len sizeof(String) * 
        CORE:copy
        ?size @self.cap
        ?self.len 0 > if {
            ?self.ptr !.i32 A:free
        }
        ?new-buf @self.ptr
        ?self ?str StringVec-push
    }
}
fn StringVec-print(strings: .StringVec) {
    local i: i32
    ?strings StringVec-len 0 = if {
        2 "[]" IO:write-all IO:check
    } else {
        2 "[\n" IO:write-all IO:check
        loop {
            ?i ?strings StringVec-len = if { break }
            2 "  \"" IO:write-all IO:check
            2 ?strings ?i StringVec-get String-unpack IO:write-all IO:check
            2 "\",\n" IO:write-all IO:check
            ?i 1 + @i
        }
        2 "]" IO:write-all IO:check
    }
}

fn str-replace(str-ptr: .i32, str-len: i32, old-ptr: .i32, old-len: i32, new-ptr: .i32, new-len: i32) -> String {
    local out: String
    local index: i32
    local next: String
    String-empty @out
    ?str-ptr ?str-len ?old-ptr ?old-len S:str-find-str if {
        @index

        &out ?str-ptr ?index String-append
        &out ?new-ptr ?new-len String-append

        ?str-ptr ?index + ?old-len + 
        ?str-len ?index - ?old-len -
        ?old-ptr
        ?old-len
        ?new-ptr
        ?new-len
        str-replace @next

        ?out ?next String-merge
    } else {
        drop 
        &out ?str-ptr ?str-len String-append
        ?out
    }
}
fn str-split(str-ptr: .i32, str-len: i32, del: i32) -> StringVec {
    local splits: StringVec
    local index: i32
    StringVec-new @splits
    loop {
        ?str-len 0 = if { break }
        ?str-ptr ?str-len ?del S:str-find if {
            @index
            &splits ?str-ptr ?index String-new StringVec-push
            ?str-ptr ?index + 1 + @str-ptr
            ?str-len ?index - 1 - @str-len
        } else {
            drop
            &splits ?str-ptr ?str-len String-new StringVec-push
            break
        }
    }
    ?splits
}
fn StringVec-join(self: .StringVec) -> String {
    ?self "" StringVec-join-with
}
fn StringVec-join-with(self: .StringVec, del-ptr: .i32, del-len: i32) -> String {
    local out: String
    local i: i32
    String-empty @out
    loop {
        ?i ?self StringVec-len = if { break }
        &out ?self ?i StringVec-get String-unpack String-append
        ?i 1 + ?self StringVec-len /= if {
            &out ?del-ptr ?del-len String-append
        }
        ?i 1 + @i
    }
    ?out
}

