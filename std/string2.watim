import "./alloc.watim" as A
import "./core.watim" as CORE
import "./io.watim" as IO

struct String {
    ptr: .i32
    len: i32
    cap: i32
}
fn String-empty() -> String {
    local self: String
    0 !.i32 @self.ptr
    0 @self.len
    0 @self.cap
    ?self
}
fn String-new(ptr: .i32, len: i32) -> String {
    local buf: .i32
    ?len A:alloc @buf
    ?ptr ?buf ?len CORE:copy
    ?buf ?len String-new-from-buf
}
fn String-new-from-buf(ptr: .i32, len: i32) -> String {
    local self: String
    ?ptr @self.ptr
    ?len @self.len
    ?len @self.cap
    ?self
}
fn String-push(self: .String, char: i32) {
    local new-buf: .i32
    local size: i32
    local ptr: .i32
    ?self.len 1 + ?self.cap > if {
        ?self.cap 2 CORE:max 2 * @size
        ?size A:alloc @new-buf
        ?self.ptr ?new-buf ?self.len CORE:copy
        $self.cap @ptr
        ?size >>ptr
        ?self.ptr !i32 0 /= if {
            ?self.ptr A:free
        }
        ?new-buf @self.ptr
        ?self ?char String-push
    } else {
        ?self.ptr ?self.len + ?char store8
        ?self.len 1 + @self.len
    }
}
fn String-append(self: .String, ptr: .i32, len: i32) {
    local i: i32
    loop {
        ?i ?len = if { break }
        ?self ?ptr ?i + load8 String-push
        ?i 1 + @i
    }
}
fn String-unpack(self: .String) -> .i32, i32 {
    ?self.ptr ?self.len
}
fn String-free(self: String) {
    ?self.ptr 0 !i32 /= if {
        ?self.ptr A:free
    }
}

struct StringVec {
    ptr: .String
    len: i32
    cap: i32
}
fn StringVec-new() -> StringVec {
    local self: StringVec
    0 !.String @self.ptr
    0 @self.len
    0 @self.cap
    ?self
}
fn StringVec-len(self: .StringVec) -> i32 {
    ?self.len
}
fn StringVec-get(self: .StringVec, index: i32) -> .String {
    ?index ?self StringVec-len >= if { 
        1 "Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    ?self.ptr ?index sizeof(String) * +
}
fn StringVec-free(self: StringVec) {
    local i: i32
    local s: .String
    loop {
        ?i ?self.len = if { break }
        &self ?i StringVec-get ~ String-free
        ?i 1 + @i
    }
    &self StringVec-len 0 > if { 
        ?self.ptr !.i32 A:free 
    }
}
fn StringVec-push(self: .StringVec, str: String) {
    local new-buf: .String
    local size: i32
    local ptr: .String
    ?self.len 1 + ?self.cap <= if {
        ?self.ptr ?self.len sizeof(String) * + @ptr
        ?str >>ptr
        // increment len
        ?self.len 1 + @self.len
    } else {
        ?self.cap 2 CORE:max 2 * @size
        ?size sizeof(String) * A:alloc !.String @new-buf
        ?self.ptr !.i32
        ?new-buf !.i32
        ?self.len sizeof(String) * 
        CORE:copy
        ?size @self.cap
        ?self.len 0 > if {
            ?self.ptr !.i32 A:free
        }
        ?new-buf @self.ptr
        ?self ?str StringVec-push
    }
}
fn StringVec-print(strings: .StringVec) {
    local i: i32
    ?strings StringVec-len 0 = if {
        2 "[]" IO:write-all IO:check
    } else {
        2 "[\n" IO:write-all IO:check
        loop {
            ?i ?strings StringVec-len = if { break }
            2 "  \"" IO:write-all IO:check
            2 ?strings ?i StringVec-get String-unpack IO:write-all IO:check
            2 "\",\n" IO:write-all IO:check
            ?i 1 + @i
        }
        2 "]" IO:write-all IO:check
    }
}

