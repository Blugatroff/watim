import "./maybe.watim" as Maybe (Maybe)
import "./io.watim" as IO
import "./array.watim" as Array (Array)
import "./arena.watim" as Arena (Arena)

struct Map<K, V> {
    keys: Array<K>
    values: Array<V>
    compare: (.K, .K -> bool)
}
fn new<K, V>(compare: (.K, .K -> bool)) -> Map<K, V> {
    Array:new<K> Array:new<V> $compare make Map<K, V>
}
fn insert<K, V>(arena: .Arena, self: .Map<K, V>, key: K, value: V) -> Maybe<V> {
    0 @i
    loop {
        $i $self.keys.len = if { 
            $arena &self.keys $key Array:push<K>
            $arena &self.values $value Array:push<V>
            make Maybe<V>.None
            break
        }
        $self $i get-key<K, V> &key $self.compare -> if {
            &self.values $i $value Array:set<V>
            make Maybe<V>.Some
            break
        }
        $i 1 + #i
    }
}
fn get<K, V>(self: .Map<K, V>, key: .K) -> Maybe<.V> {
    $self $key get-index<K, V> match {
        case None -> { make Maybe<.V>.None }
        case Some -> { $self flip get-value<K, V> make Maybe<.V>.Some }
    }
}
fn get-index<K, V>(self: .Map<K, V>, key: .K) -> Maybe<i32> {
    0 @i
    loop {
        $i $self size<K, V> = if { make Maybe<i32>.None break }
        $self $i get-key<K, V> $key $self.compare -> if {
            $i make Maybe<i32>.Some break
        }
        $i 1 + #i
    }
}
fn size<K, V>(self: .Map<K, V>) -> i32 {
    $self.keys.len
}
fn get-key<K, V>(self: .Map<K, V>, index: i32) -> .K {
    &self.keys $index Array:get<K>
}
fn get-value<K, V>(self: .Map<K, V>, index: i32) -> .V {
    &self.values $index Array:get<V>
}

