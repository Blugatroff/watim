import "./string.watim" as S
import "./str.watim" as STR
import "./i32vec.watim" as IV
import "./io.watim" as IO
import "./alloc.watim" as A
import "./util.watim" as U
import "./dyn-array.watim" as DynArray

struct StringMap {
    keys: S:StringVec
    values: DynArray:DynArray<i32>
}
fn StringMap-new() -> StringMap {
    local self: StringMap
    S:StringVec-new #self.keys
    0!(i32 ->) DynArray:new<i32> #self.values
    $self
}
fn StringMap-free(self: StringMap) {
    $self.keys S:StringVec-free
    $self.values DynArray:free<i32>
}
fn StringMap-insert(self: .StringMap, key: S:String, value: i32) -> i32, bool {
    local i: i32
    loop {
        $i &self.keys S:StringVec-len = if { 
            &self.keys $key S:StringVec-push
            &self.values $value DynArray:push<i32>
            0 0 1 = break 
        }
        $self $i StringMap-get-key S:String-unpack &key S:String-unpack STR:str-eq if {
            $key S:String-free
            &self.values $i $value DynArray:set<i32>
            0 0 =
            break
        }
        $i 1 + #i
    }
}
fn StringMap-get(self: .StringMap, key-ptr: .i32, key-len: i32) -> i32, bool {
    local i: i32
    loop {
        $i $self StringMap-len = if {
            0 0 1 = break
        }
        $self $i StringMap-get-key S:String-unpack $key-ptr $key-len STR:str-eq if {
            $self $i StringMap-get-value 0 0 = break
        }
        $i 1 + #i
    }
}
fn StringMap-len(self: .StringMap) -> i32 {
    &self.keys S:StringVec-len
}
fn StringMap-get-key(self: .StringMap, index: i32) -> .S:String {
    &self.keys $index S:StringVec-get
}
fn StringMap-get-value(self: .StringMap, index: i32) -> i32 {
    &self.values $index DynArray:get<i32> ~
}

