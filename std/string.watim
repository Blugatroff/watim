import "./alloc.watim" as A
import "./core.watim" as CORE
import "./io.watim" as IO

fn str-eq(ptr-a: .i32, len-a: i32, ptr-b: .i32, len-b: i32) -> bool {
    local i: i32
    $len-a $len-b = if {
        loop {
            $i $len-a = if { 0 0 = break }
            $ptr-a $i + load8
            $ptr-b $i + load8
            /= if {
                0 1 = break
            }
            $i 1 + #i
        }
    } else {
        0 1 =
    }
}
fn str-find(ptr: .i32, len: i32, char: i32) -> i32, bool {
    local i: i32
    loop {
        $i $len = if {
            0 0 1 = break
        }
        $ptr $i + load8 $char = if {
            $i 0 0 = break
        }
        $i 1 + #i
    }
}
fn str-find-rev(ptr: .i32, len: i32, char: i32) -> i32, bool {
    local i: i32
    $len #i
    loop {
        $i 0 = if {
            0 0 1 = break
        }
        $ptr $i 1 - + load8 $char = if {
            $i 0 0 = break
        }
        $i 1 - #i
    }
}
fn str-is-prefix(ptr: .i32, len: i32, prefix-ptr: .i32, prefix-len: i32) -> bool {
    $ptr $len $prefix-len CORE:min $prefix-ptr $prefix-len str-eq
}
fn str-find-str(ptr: .i32, len: i32, target-ptr: .i32, target-len: i32) -> i32, bool {
    local char: i32
    local index: i32
    loop {
        $target-len 0 = if { 0 0 0 = break }
        $len 0 = if {
            0 $target-len 0 = break
        }
        $target-ptr load8 #char
        $ptr $len $char str-find if {
            #index
            $ptr $index + $len $index - 
            $target-ptr $target-len
            str-is-prefix if {
                $index 0 0 = break
            }
        } else {
            0 1 = break
        } 
        $ptr $index + 1 +
        $len $index - 1 -
        $target-ptr $target-len 
        str-find-str if {
            $index + 1 + 0 0 = break
        } else {
            0 1 = break
        }
    }
}
fn str-replace(str-ptr: .i32, str-len: i32, old-ptr: .i32, old-len: i32, new-ptr: .i32, new-len: i32) -> .String {
    local out: .String
    local index: i32
    local next: .String
    String-empty #out
    $str-ptr $str-len $old-ptr $old-len str-find-str if {
        #index

        $out $str-ptr $index String-append
        $out $new-ptr $new-len String-append

        $str-ptr $index + $old-len + 
        $str-len $index - $old-len -
        $old-ptr
        $old-len
        $new-ptr
        $new-len
        str-replace #next

        $out $next String-merge
        $out
    } else {
        drop 
        $out $str-ptr $str-len String-append
        $out
    }
}
fn str-split(str-ptr: .i32, str-len: i32, del: i32) -> .StringVec {
    local splits: .StringVec
    local index: i32
    StringVec-new #splits
    loop {
        $str-len 0 = if { break }
        $str-ptr $str-len $del str-find if {
            #index
            $splits $str-ptr $index String-new StringVec-push
            $str-ptr $index + 1 + #str-ptr
            $str-len $index - 1 - #str-len
        } else {
            drop
            $splits $str-ptr $str-len String-new StringVec-push
            break
        }
    }
    $splits
}

struct Str {
    ptr: .i32
    len: i32
}
fn Str-free(str: .Str) {
    $str !.i32 A:free
}
fn Str-new(ptr: .i32, len: i32) -> .Str {
    local s: .Str
    8 A:alloc !.Str #s
    $s.ptr $ptr store32
    $s.len $len store32
    $s
}
fn Str-copy(str: .Str) -> .Str {
    $str.ptr load32 $str.len load32 Str-new
}
fn Str-len(str: .Str) -> i32 {
    $str.len load32
}
fn Str-unpack(str: .Str) -> .i32, i32 {
    $str.ptr load32 $str.len load32
}
fn Str-get(str: .Str, index: i32) -> i32 {
    $index $str Str-len >= if { 
        1 "Str-get Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    $str.ptr load32 $index + load8
}
fn Str-slice(str: .Str, index: i32, len: i32) -> .Str {
    $index $len + $str Str-len > if { 
        1 "Str-slice Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    $str.ptr load32 $index + $len Str-new
}

struct String {
    ptr: .i32
    len: i32
    cap: i32
}
fn String-empty() -> .String {
    local self: .String
    12 A:alloc !.String #self
    $self.ptr 0 !.i32 store32
    $self.len 0 store32
    $self.cap 0 store32
    $self
}
fn String-new(ptr: .i32, len: i32) -> .String {
    local s: .String
    local buf: .i32
    12 A:alloc !.String #s
    $len A:alloc #buf
    $ptr $buf $len CORE:copy
    $s.ptr $buf store32
    $s.len $len store32
    $s.cap $len store32
    $s
}
fn String-new-from-buf(ptr: .i32, len: i32) -> .String {
    local s: .String
    12 A:alloc !.String #s
    $s.ptr $ptr store32
    $s.len $len store32
    $s.cap $len store32
    $s
}
fn String-push(self: .String, char: i32) {
    local new-buf: .i32
    local size: i32
    $self.len load32 1 + $self.cap load32 > if {
        $self.cap load32 2 CORE:max 2 * #size
        $size A:alloc #new-buf
        $self.ptr load32 $new-buf $self.len load32 CORE:copy
        $self.cap $size store32
        $self.ptr load32 !i32 0 /= if { 
            $self.ptr load32 A:free
        }
        $self.ptr $new-buf store32
        $self $char String-push
    } else {
        $self.ptr load32 $self.len load32 + $char store8
        $self.len $self.len load32 1 + store32
    }
}
fn String-append(self: .String, ptr: .i32, len: i32) {
    local i: i32
    loop {
        $i $len = if { break }
        $self $ptr $i + load8 String-push
        $i 1 + #i
    }
}
fn String-merge(self: .String, other: .String) {
    $self $other String-unpack String-append
    $other String-free
}
fn String-len(self: .String) -> i32 {
    $self.len load32
}
fn String-get(self: .String, index: i32) -> i32 {
    $self String-len $index <= if { 
        1 "String-get Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    $self.ptr load32 $index + load8
}
fn String-unpack(self: .String) -> .i32, i32 {
    $self.ptr load32 $self.len load32
}
fn String-free(self: .String) {
    $self.ptr load32 !i32 0 /= if {
        $self.ptr load32 A:free
    }
    $self !.i32 A:free
}
fn String-to-Str(self: .String) -> .Str {
    $self.ptr load32 $self.len load32 Str-new
}
fn String-slice(str: .Str, index: i32, len: i32) -> .Str {
    $index $len + $str Str-len > if { 
        1 "Str-slice Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    $str.ptr load32 $index + $len Str-new
}
fn String-indent(self: .String) -> .String {
    local new: .String
    local i: i32
    local char: i32
    String-empty #new
    loop {
        $i $self String-len = if { break }
        $self $i String-get #char
        $new $char String-push
        $char 10 = if {
            $new "  " String-append
        }
        $i 1 + #i
    }
    $self String-free
    $new
}

struct StringVec {
    ptr: ..String
    len: i32
    cap: i32
}
fn StringVec-new() -> .StringVec {
    local vec: .StringVec
    12 A:alloc !.StringVec #vec
    $vec.ptr 0 !..String store32
    $vec.len 0 store32
    $vec.cap 0 store32
    $vec
}
fn StringVec-len(vec: .StringVec) -> i32 {
    $vec.len load32
}
fn StringVec-get(vec: .StringVec, index: i32) -> .String {
    $index $vec StringVec-len >= if { 
        1 "Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    $vec.ptr load32 $index 4 * + load32
}
fn StringVec-free(vec: .StringVec) {
    local i: i32
    local ptr: ..String
    local s: .String
    $vec.ptr load32 #ptr
    loop {
        $i $vec.len load32 = if { break }
        $ptr $i 4 * + load32 #s
        $s String-free
        $i 1 + #i
    }
    $vec StringVec-len 0 > if { $vec.ptr load32 !.i32 A:free }
    $vec !.i32 A:free
}
fn StringVec-push(vec: .StringVec, str: .String) {
    local new-buf: ..String
    local size: i32
    $vec.len load32 1 + $vec.cap load32 <= if {
        $vec.ptr load32 $vec.len load32 4 * + $str store32
        // increment len
        $vec.len $vec.len load32 1 + store32
    } else {
        $vec.cap load32 2 CORE:max 2 * #size
        $size 4 * A:alloc !..String #new-buf
        $vec.ptr load32 !.i32
        $new-buf !.i32
        $vec.len load32 4 * 
        CORE:copy
        $vec.cap $size store32
        $vec.len load32 0 > if {
            $vec.ptr load32 !.i32 A:free
        }
        $vec.ptr $new-buf store32
        $vec $str StringVec-push
    }
}
fn StringVec-print(strings: .StringVec) {
    local i: i32
    $strings StringVec-len 0 = if {
        1 "[]" IO:write-all IO:check
    } else {
        1 "[\n" IO:write-all IO:check
        loop {
            $i $strings StringVec-len = if { break }
            1 "  \"" IO:write-all IO:check
            1 $strings $i StringVec-get String-unpack IO:write-all IO:check
            1 "\",\n" IO:write-all IO:check
            $i 1 + #i
        }
        1 "]" IO:write-all IO:check
    }
}
fn StringVec-join(self: .StringVec) -> .String {
    local out: .String
    local i: i32
    String-empty #out
    loop {
        $i $self StringVec-len = if { break }
        $out $self $i StringVec-get String-unpack String-append
        $i 1 + #i
    }
    $out
}

fn StringVec-join-with(self: .StringVec, del-ptr: .i32, del-len: i32) -> .String {
    local out: .String
    local i: i32
    String-empty #out
    loop {
        $i $self StringVec-len = if { break }
        $out $self $i StringVec-get String-unpack String-append
        $i 1 + $self StringVec-len /= if {
            $out $del-ptr $del-len String-append
        }
        $i 1 + #i
    }
    $out

}

