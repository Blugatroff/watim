import "./alloc.watim" as A
import "./core.watim" as CORE
import "./io.watim" as IO
import "./str.watim" as S
import "./arena.watim" as Arena

struct String {
    ptr: .i32
    len: i32 // 4 used for inline strings
    cap: i32 // 8
    buf_1: i32 // 12
    buf_2: i32 // 16
    buf_3: i32 // 20
    buf_4: i32 // 24
    buf_5: i32 // 28
}
fn String-ptr(self: .String) -> .i32 {
    $self String-is-inline if {
        &self.len !.i32
    } else {
        $self.ptr
    }
}
fn String-len(self: .String) -> i32 {
    $self String-is-inline if {
        $self.ptr !i32 1 not and 1 rotr
    } else {
        $self.len
    }
}
fn String-is-inline(self: .String) -> bool {
    $self.ptr !i32 1 and 0 /=
}
fn String-empty() -> String {
    local self: String
    0 !.i32 #self.ptr
    0 #self.len
    0 #self.cap
    $self
}
fn String-new-heapA(arena: .Arena:Arena, ptr: .i32, len: i32) -> String {
    $arena $ptr $len Arena:push-bytes @buf
    $buf $len String-new-from-buf
}
fn String-new-heap(ptr: .i32, len: i32) -> String {
    $len A:alloc @buf
    $ptr $buf $len CORE:copy-bytes
    $buf $len String-new-from-buf
}
fn String-new-inline(ptr: .i32, len: i32) -> String {
    local self: String
    $len 1 rotl 1 + !.i32 #self.ptr
    $ptr &self.len $len CORE:copy-bytes
    $self
}
fn String-newA(arena: .Arena:Arena, ptr: .i32, len: i32) -> String {
    $len sizeof(String) 4 - le if {
        $ptr $len String-new-inline
    } else {
        $arena $ptr $len String-new-heapA
    }
}
fn String-new(ptr: .i32, len: i32) -> String {
    $len sizeof(String) 4 - le if {
        $ptr $len String-new-inline
    } else {
        $ptr $len String-new-heap
    }
}
fn String-new-from-buf(ptr: .i32, len: i32) -> String {
    local self: String
    $ptr #self.ptr
    $len #self.len
    $len #self.cap
    $self
}
fn String-push(self: .String, char: i32) {
    local new-buf: .i32
    local size: i32
    $self String-is-inline if {
        $self String-len #size
        $size sizeof(String) 4 - lt if {
            &self.len $self String-len + $char store8
            $size 1 + 1 rotl 1 or !.i32 #self.ptr
        } else {
            &self.len $size 1 + String-new =>self
            $self $size $char String-set
        }
    } else {
        $self.len 1 + $self.cap gt if {
            $self.cap 2 CORE:max 2 * #size
            $size A:alloc #new-buf
            $self.ptr $new-buf $self.len CORE:copy-bytes
            $size #self.cap
            $self.ptr !i32 0 /= if {
                $self.ptr A:free
            }
            $new-buf #self.ptr
            $self $char String-push
        } else {
            $self.ptr $self.len + $char store8
            $self.len 1 + #self.len
        }
    }
}
fn String-pushA(arena: .Arena:Arena, self: .String, char: i32) {
    $self String-is-inline if {
        $self String-len @size
        $size sizeof(String) 4 - lt if {
            &self.len $self String-len + $char store8
            $size 1 + 1 rotl 1 or !.i32 #self.ptr
        } else {
            $arena &self.len $size 1 + String-newA =>self
            $self $size $char String-set
        }
    } else {
        $self.len 1 + $self.cap gt if {
            $self.cap 2 CORE:max 2 * @size
            $arena $self.ptr $size Arena:push-bytes @new-buf
            $size #self.cap
            $new-buf #self.ptr
            $self $char String-push
        } else {
            $self.ptr $self.len + $char store8
            $self.len 1 + #self.len
        }
    }
}
fn String-appendA(arena: .Arena:Arena, self: .String, ptr: .i32, len: i32) {
    0 @i
    loop {
        $i $len = if { break }
        $arena $self $ptr $i + load8 String-pushA
        $i 1 + #i
    }
}
fn String-append(self: .String, ptr: .i32, len: i32) {
    local i: i32
    loop {
        $i $len = if { break }
        $self $ptr $i + load8 String-push
        $i 1 + #i
    }
}
fn String-unpack(self: .String) -> .i32, i32 {
    $self String-ptr $self String-len
}
fn String-free(self: String) {
    &self String-is-inline not 
    $self.ptr 0 !.i32 /= 
    and if {
        $self.ptr A:free
    }
}
fn String-leak(self: String) -> .i32, i32 {
    &self String-unpack
}
fn String-clone(self: .String) -> String {
    $self String-unpack String-new
}
fn String-merge(self: String, other: String) -> String {
    &self &other String-unpack String-append
    $other String-free
    $self
}
fn String-set(self: .String, index: i32, char: i32) {
    $index $self String-len ge if {
        2 "Index out of bounds: " IO:write-all IO:check
        2 $index IO:print-to-fd
        2 ", len is: " IO:write-all IO:check
        2 $self String-len IO:print-to-fd
        2 "\n" IO:write-all IO:check
        0 0 / drop
    }
    $self String-ptr $index + $char store8
}
fn String-compare-with-str(self: .String, other: .S:Str) -> bool {
    $self String-unpack $other ~ S:Str-unpack S:str-eq
}

struct StringVec {
    ptr: .String
    len: i32
    cap: i32
}
fn StringVec-new() -> StringVec {
    local self: StringVec
    0 !.String #self.ptr
    0 #self.len
    0 #self.cap
    $self
}
fn StringVec-len(self: .StringVec) -> i32 {
    $self.len
}
fn StringVec-get(self: .StringVec, index: i32) -> .String {
    $index $self StringVec-len ge if { 
        1 "Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    $self.ptr $index sizeof(String) * +
}
fn StringVec-free(self: StringVec) {
    local i: i32
    local s: .String
    loop {
        $i $self.len = if { break }
        &self $i StringVec-get ~ String-free
        $i 1 + #i
    }
    &self StringVec-len 0 gt if { 
        $self.ptr !.i32 A:free 
    }
}
fn StringVec-push(self: .StringVec, str: String) {
    local new-buf: .String
    local size: i32
    local ptr: .String
    $self.len 1 + $self.cap le if {
        $self.ptr $self.len sizeof(String) * + #ptr
        $str =>ptr
        // increment len
        $self.len 1 + #self.len
    } else {
        $self.cap 2 CORE:max 2 * #size
        $size sizeof(String) * A:alloc !.String #new-buf
        $self.ptr !.i32
        $new-buf !.i32
        $self.len sizeof(String) * 
        CORE:copy-bytes
        $size #self.cap
        $self.len 0 gt if {
            $self.ptr !.i32 A:free
        }
        $new-buf #self.ptr
        $self $str StringVec-push
    }
}
fn StringVec-print(fd: i32, strings: .StringVec) {
    local i: i32
    $strings StringVec-len 0 = if {
        $fd "[]" IO:write-all IO:check
    } else {
        $fd "[\n" IO:write-all IO:check
        loop {
            $i $strings StringVec-len = if { break }
            $fd "  \"" IO:write-all IO:check
            $fd $strings $i StringVec-get String-unpack IO:write-all IO:check
            $fd "\",\n" IO:write-all IO:check
            $i 1 + #i
        }
        $fd "]" IO:write-all IO:check
    }
}
fn StringVec-find(self: .StringVec, ptr: .i32, len: i32) -> i32, bool {
    local i: i32
    loop {
        $i $self StringVec-len = if { 0 0 1 = break }
        $self $i StringVec-get String-unpack $ptr $len S:str-eq if {
            $i 1 1 = break
        }
        $i 1 + #i
    }
}
fn StringVec-remove(self: .StringVec, index: i32) -> String {
    local string: String
    $self $index StringVec-get ~ #string
    $self.ptr $index 1 + sizeof(String) * + !.i32
    $self.ptr $index sizeof(String) * + !.i32
    $self.len $index - 1 - sizeof(String) *
    CORE:copy-bytes
    $string
}
fn StringVec-find-remove(self: .StringVec, ptr: .i32, len: i32) -> i32, bool {
    local i: i32
    $self $ptr $len StringVec-find if {
        #i
        $self $i StringVec-remove String-free
        $i 1 1 =
    } else { 
        0 1 =
    }
}

fn str-replace(str-ptr: .i32, str-len: i32, old-ptr: .i32, old-len: i32, new-ptr: .i32, new-len: i32) -> String {
    local out: String
    local index: i32
    local next: String
    String-empty #out
    $str-ptr $str-len $old-ptr $old-len S:str-find-str if {
        #index

        &out $str-ptr $index String-append
        &out $new-ptr $new-len String-append

        $str-ptr $index + $old-len + 
        $str-len $index - $old-len -
        $old-ptr
        $old-len
        $new-ptr
        $new-len
        str-replace #next

        $out $next String-merge
    } else {
        drop 
        &out $str-ptr $str-len String-append
        $out
    }
}
fn str-split(str-ptr: .i32, str-len: i32, del: i32) -> StringVec {
    local splits: StringVec
    local index: i32
    StringVec-new #splits
    loop {
        $str-len 0 = if { break }
        $str-ptr $str-len $del S:str-find if {
            #index
            &splits $str-ptr $index String-new StringVec-push
            $str-ptr $index + 1 + #str-ptr
            $str-len $index - 1 - #str-len
        } else {
            drop
            &splits $str-ptr $str-len String-new StringVec-push
            break
        }
    }
    $splits
}
fn StringVec-join(self: .StringVec) -> String {
    $self "" StringVec-join-with
}
fn StringVec-join-with(self: .StringVec, del-ptr: .i32, del-len: i32) -> String {
    local out: String
    local i: i32
    String-empty #out
    loop {
        $i $self StringVec-len = if { break }
        &out $self $i StringVec-get String-unpack String-append
        $i 1 + $self StringVec-len /= if {
            &out $del-ptr $del-len String-append
        }
        $i 1 + #i
    }
    $out
}

fn str-escape(str-ptr: .i32, str-len: i32) -> String {
    memory buf: i32 4
    local out: String
    local i: i32
    String-empty #out
    loop {
        $str-len $i = if { break }
        &out $buf $str-ptr $i + load8 $buf CORE:escape String-append
        $i 1 + #i
    }
    $out
}

