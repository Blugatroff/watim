import "./alloc.watim" as A
import "./core.watim" as CORE
import "./io.watim" as IO
import "./str.watim" as S

struct String {
    ptr: .i32
    len: i32 // 4 used for inline strings
    cap: i32 // 8
    buf_1: i32 // 12
    buf_2: i32 // 16
    buf_3: i32 // 20
    buf_4: i32 // 24
    buf_5: i32 // 28
}
fn String-ptr(self: .String) -> .i32 {
    $self String-is-inline if {
        &self.len !.i32
    } else {
        $self.ptr
    }
}
fn String-len(self: .String) -> i32 {
    $self String-is-inline if {
        $self.ptr !i32 1 not and 1 rotr
    } else {
        $self.len
    }
}
fn String-is-inline(self: .String) -> bool {
    $self.ptr !i32 1 and 0 /=
}
fn String-empty() -> String {
    local self: String
    0 !.i32 #self.ptr
    0 #self.len
    0 #self.cap
    $self
}
fn String-new-heap(ptr: .i32, len: i32) -> String {
    $len A:alloc @buf
    $ptr $buf $len CORE:copy-bytes
    $buf $len String-new-from-buf
}
fn String-new-inline(ptr: .i32, len: i32) -> String {
    local self: String
    $len 1 rotl 1 + !.i32 #self.ptr
    $ptr &self.len $len CORE:copy-bytes
    $self
}
fn String-new(ptr: .i32, len: i32) -> String {
    $len sizeof(String) 4 - le if {
        $ptr $len String-new-inline
    } else {
        $ptr $len String-new-heap
    }
}
fn String-new-from-buf(ptr: .i32, len: i32) -> String {
    local self: String
    $ptr #self.ptr
    $len #self.len
    $len #self.cap
    $self
}
fn String-push(self: .String, char: i32) {
    local new-buf: .i32
    local size: i32
    $self String-is-inline if {
        $self String-len #size
        $size sizeof(String) 4 - lt if {
            &self.len $self String-len + $char store8
            $size 1 + 1 rotl 1 or !.i32 #self.ptr
        } else {
            &self.len $size 1 + String-new =>self
            $self $size $char String-set
        }
    } else {
        $self.len 1 + $self.cap gt if {
            $self.cap 2 CORE:max 2 * #size
            $size A:alloc #new-buf
            $self.ptr $new-buf $self.len CORE:copy-bytes
            $size #self.cap
            $self.ptr !i32 0 /= if {
                $self.ptr A:free
            }
            $new-buf #self.ptr
            $self $char String-push
        } else {
            $self.ptr $self.len + $char store8
            $self.len 1 + #self.len
        }
    }
}
fn String-append(self: .String, ptr: .i32, len: i32) {
    local i: i32
    loop {
        $i $len = if { break }
        $self $ptr $i + load8 String-push
        $i 1 + #i
    }
}
fn String-unpack(self: .String) -> .i32, i32 {
    $self String-ptr $self String-len
}
fn String-free(self: String) {
    &self String-is-inline not 
    $self.ptr 0 !.i32 /= 
    and if {
        $self.ptr A:free
    }
}
fn String-set(self: .String, index: i32, char: i32) {
    $index $self String-len ge if {
        2 "Index out of bounds: " IO:write-all IO:check
        2 $index IO:print-to-fd
        2 ", len is: " IO:write-all IO:check
        2 $self String-len IO:print-to-fd
        2 "\n" IO:write-all IO:check
        0 0 / drop
    }
    $self String-ptr $index + $char store8
}

