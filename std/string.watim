import "./alloc.watim" as A
import "./core.watim" as CORE
import "./io.watim" as IO

fn str-eq(ptr-a: .i32, len-a: i32, ptr-b: .i32, len-b: i32) -> bool {
    local i: i32
    $len-a $len-b = if {
        loop {
            $i $len-a = if { 0 0 = break }
            $ptr-a $i + load8
            $ptr-b $i + load8
            /= if {
                0 1 = break
            }
            $i 1 + #i
        }
    } else {
        0 1 =
    }
}

struct Str {
    ptr: .i32
    len: i32
}
fn Str-free(str: .Str) {
    $str.ptr load32 A:free
    $str !.i32 A:free
}
fn Str-new(ptr: .i32, len: i32) -> .Str {
    local buf: .i32
    local s: .Str
    $len A:alloc #buf
    $ptr $buf $len CORE:copy
    $buf $len Str-new-borrowed
}
fn Str-new-borrowed(ptr: .i32, len: i32) -> .Str {
    local s: .Str
    8 A:alloc !.Str #s
    $s.ptr $ptr store32
    $s.len $len store32
    $s
}
fn Str-copy(str: .Str) -> .Str {
    $str.ptr load32 $str.len load32 Str-new
}
fn Str-len(str: .Str) -> i32 {
    $str.len load32
}
fn Str-unpack(str: .Str) -> .i32, i32 {
    $str.ptr load32 $str.len load32
}
fn Str-get(str: .Str, index: i32) -> i32 {
    $index $str Str-len >= if { 
        1 "Str-get Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    $str.ptr load32 $index + load8
}
fn Str-slice(str: .Str, index: i32, len: i32) -> .Str {
    $index $len + $str Str-len > if { 
        1 "Str-slice Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    $str.ptr load32 $index + $len Str-new-borrowed
}

struct String {
    ptr: .i32
    len: i32
    cap: i32
}
fn String-new() -> .String {
    local self: .String
    12 A:alloc !.String #self
    $self.ptr 0 !.i32 store32
    $self.len 0 store32
    $self.cap 0 store32
    $self
}
fn copy(a: .i32, b: .i32, len: i32) {
    loop {
        $len 0 = if { break }
        $b $a load8 store8
        $len 1 - #len
        $a 1 + #a
        $b 1 + #b
    }
}
fn String-push(self: .String, char: i32) {
    local new-buf: .i32
    local size: i32
    $self.len load32 1 + $self.cap load32 > if {
        $self.cap load32 2 CORE:max 2 * #size
        $size A:alloc #new-buf
        $self.ptr load32 $new-buf $self.len load32 CORE:copy
        $self.cap $size store32
        $self.ptr load32 !i32 0 /= if { 
            $self.ptr load32 A:free
        }
        $self.ptr $new-buf store32
        $self $char String-push
    } else {
        $self.ptr load32 $self.len load32 + $char store8
        $self.len $self.len load32 1 + store32
    }
}
fn String-len(self: .String) -> i32 {
    $self.len load32
}
fn String-get(self: .String, index: i32) -> i32 {
    $self String-len $index >= if { 
        1 "String-get Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    $self.ptr load32 $index + load8
}
fn String-unpack(self: .String) -> .i32, i32 {
    $self.ptr load32 $self.len load32
}
fn String-free(self: .String) {
    $self.ptr load32 !i32 0 /= if {
        $self.ptr load32 A:free
    }
    $self !.i32 A:free
}

struct StrVec {
    ptr: ..Str
    len: i32
    cap: i32
}
fn StrVec-new() -> .StrVec {
    local vec: .StrVec
    12 A:alloc !.StrVec #vec
    $vec.ptr 0 !..Str store32
    $vec.len 0 store32
    $vec.cap 0 store32
    $vec
}
fn StrVec-len(vec: .StrVec) -> i32 {
    $vec.len load32
}
fn StrVec-get(vec: .StrVec, index: i32) -> .i32, i32 {
    $index $vec StrVec-len >= if { 
        1 "Index out of bounds\n" IO:write-all IO:check
        1 CORE:exit
    }
    $vec.ptr load32 $index 4 * + load32 Str-unpack
}
fn StrVec-free(vec: .StrVec) {
    local i: i32
    local ptr: ..Str
    local s: .Str
    $vec.ptr load32 #ptr
    loop {
        $i $vec.len load32 = if { break }
        $ptr $i 4 * + load32 #s
        $s Str-free
        $i 1 + #i
    }
    $vec StrVec-len 0 > if { $vec.ptr load32 !.i32 A:free }
    $vec !.i32 A:free
}
fn StrVec-push(vec: .StrVec, str: .Str) {
    local new-buf: ..Str
    local size: i32
    $vec.len load32 1 + $vec.cap load32 <= if {
        $vec.ptr load32 $vec.len load32 4 * + $str store32
        // increment len
        $vec.len $vec.len load32 1 + store32
    } else {
        $vec.cap load32 2 CORE:max 2 * #size
        $size 4 * A:alloc !..Str #new-buf
        $vec.ptr load32 !.i32
        $new-buf !.i32
        $vec.len load32 4 * 
        CORE:copy
        $vec.cap $size store32
        $vec.len load32 0 > if {
            $vec.ptr load32 !.i32 A:free
        }
        $vec.ptr $new-buf store32
        $vec $str StrVec-push
    }
}
fn StrVec-print(strings: .StrVec) {
    local i: i32
    $strings StrVec-len 0 = if {
        1 "[]" IO:write-all IO:check
    } else {
        1 "[\n" IO:write-all IO:check
        loop {
            $i $strings StrVec-len = if { break }
            1 "  \"" IO:write-all IO:check
            1 $strings $i StrVec-get IO:write-all IO:check
            1 "\",\n" IO:write-all IO:check
            $i 1 + #i
        }
        1 "]" IO:write-all IO:check
    }
}

