extern "wasi_unstable" "fd_read" fn raw_read(file: i32, iovs: .i32, iovs_count: i32, read: .i32) -> i32
extern "wasi_unstable" "fd_write" fn raw_write(file: i32, iovs: .Iov, iovs_count: i32, written: .i32) -> i32
extern "wasi_unstable" "proc_exit" fn raw_exit(code: i32)

import "./alloc.watim" as A

struct Iov {
    ptr: .i32
    len: i32
}

fn exit(code: i32) {
    $code raw_exit
}

fn write(fd: i32, pt: .i32, len: i32) -> i32, i32 {
    memory space: Iov 8 4;
    memory writ: i32 4 4;
    local code: i32
    $writ 0 store32
    $space.ptr $pt store32
    $space.len $len store32
    $fd $space 1 $writ raw_write #code
    $writ load32 $code
}

fn write_all_inner(fd: i32, pt: .i32, len: i32) -> i32, i32 {
    local written: i32
    local code: i32
    $fd $pt $len write #code #written
    $code 0 = if {
        $written $len = if {
            $written $code
        } else {
            $fd 
            $pt $written + 
            $len $written - 
            write_all_inner
            flip $written + flip
        }
    } else {
        0 $code
    }
}

fn write_all(fd: i32, pt: .i32, len: i32) -> i32 {
    $fd $pt $len write_all_inner flip drop
}

fn write_byte(file: i32, b: i32) -> i32 {
    memory buf: i32 1;
    $buf $b store8
    $file $buf 1 write_all
}

fn print_i64_fallible(n: i64) -> i32 {
    memory buf: i32 24;
    memory buf_reversed: i32 24;
    local l: i32
    local i: i32
    0 #l
    $n 0 !i64 = if {
        1 #l // length = 1
        $buf 48 store8 // put '0' in buf
    } else {
        loop {
            $n 0 !i64 = if { break }
            $buf !i32 $l + !.i32
            $n 10 !i64 % !i32 // rightmost digit
            48 + // + ascii 'a'
            store8
            $n 10 !i64 / #n // shift right in decimal
            $l 1 + #l
        }
    }
    0 #i
    loop {
        $buf_reversed !i32 $i + !.i32
        $buf !i32 $l 1 - $i - + !.i32 load8
        store8
        $i 1 + #i
        $i $l = if { break }
    }
    1 $buf_reversed $l write_all
}

fn print_i64(n: i64) {
    $n print_i64_fallible check
}

fn print(n: i32) {
    $n !i64 print_i64
}

fn read(file: i32, buf_addr: .i32, buf_size: i32) -> i32, i32 {
    memory space: i32 8 4;
    memory writ: i32 4 4;
    local code: i32
    $space $buf_addr !i32 store32 
    $space !i32 4 + !.i32 $buf_size store32 
    $file $space 1 $writ raw_read #code
    $writ load32 $code
}

fn read_all(file: i32) -> .i32, i32, i32 {
    local buf: .i32
    local old-buf: .i32
    local buf-size: i32
    local read: i32
    local code: i32
    local r: i32
    0 #read
    0 #r
    64 #buf-size
    $buf-size A:alloc #buf

    loop {
        $buf-size $read = if {
            $buf #old-buf
            $buf-size 2 * A:alloc #buf
            $buf !i32 0 = if {
                $old-buf A:free
                // 48 Error code = Not enough space
                0 !.i32 0 48 break
            }
            $old-buf $buf $buf-size copy
            $buf-size 2 * #buf-size
            $old-buf A:free
        }
        $file 
        $buf $read + 
        $buf-size $read -
        read #code #r
        $code 0 /= if {
            0 !.i32 0 $code break
        }
        $r 0 = if {
            $buf $read 0 break
        } else {
            $read $r + #read
        }
    }
}

fn copy(a: .i32, b: .i32, len: i32) {
    loop {
        $len 0 = if { break }
        $b $a load8 store8
        $len 1 - #len
        $a 1 + #a
        $b 1 + #b
    }
}

fn parse(pt: .i32, len: i32) -> i32 {
    local n: i32
    local d: i32
    local original-ptr: .i32
    local original-len: i32
    $pt #original-ptr
    $len #original-len
    loop {
        $pt load8 #d
        $d 48 >= $d 58 <= and if { // 48 is ascii '0'
            $n $d 48 - + #n
        } else {
            1 "Failed to parse: '" write_all check
            1 $original-ptr $original-len write_all check
            1 "'" write_all check
            1 10 write_byte check
            1 exit
        }
        $pt 1 + #pt // advance pointer
        $len 1 - #len // reduce length
        $len 0 = if { $n break }
        $n 10 * #n
    }
}

fn dup(a: i32) -> i32, i32 {
    $a $a
}

fn flip(a: i32, b: i32) -> i32, i32 {
    $b $a
}

fn check(code: i32) {
    $code 0 /= if {
        1 "Error Code: " write_all drop $code !i64 print_i64_fallible drop
        1 10 write_byte drop
        1 exit
    }
}

fn print_alloc_list(start: .i32) {
    local block: .i32
    local next: .i32
    local size: i32
    local used: bool
    $start #block
    1 "BLOCK LIST STARTING AT: " write_all check $block !i32 print 1 10 write_byte check
    loop {
        $block !i32 0 = if { break }
        $block load32 !.i32 #next
        $block 4 + load32 #size
        $block 8 + load32 0 > #used

        1 9 write_byte check 
        $block !i32 print
        1 ": " write_all check
        1 " " write_all check
        $next !i32 print
        1 " " write_all check
        $size print
        1 " " write_all check
        $used !i32 print
        1 10 write_byte check 

        $next #block
    }
}

