memory MEM: i32 16384 4;

fn init() {
    local root: .i32
    local next: .i32
    local size: i32
    
    $MEM 4 + #root
    // Set the next pointer of the init block to 0 since there is only this block. 
    0 !.i32 #next
    // Store the next pointer in the block.
    $root $next !i32 store32
    // MEM_CAPACITY - root_ptr
    16384 4 - #size
    $root 4 + $size store32
    // Mark this block as unused.
    $root 8 + 0 store32
    // Make the root point to this block.
    $MEM !.i32 $root !i32 store32
}

fn alloc(size: i32) -> .i32 {
    local root: .i32
    local prev: .i32
    local block: .i32
    local next: .i32
    local block-size: i32
    local new-block: .i32
    local n: i32
    local unused: bool

    $MEM !.i32 load32 !.i32 #root
    $root #prev
    $root #block

    loop {
        $block load32 !.i32 #next
        $block 4 + load32 #block-size
        $block 8 + load32 0 = #unused

        // Test whether this block has enough space for the requested size + the BLOCK_SIZE.
        $block-size $size 12 + >= $unused and if {
            // Is there enough remaining space to split this block in two?
            $block-size 12 - $size - 12 >= if {
                // Calculate the position of the new block.
                $block 12 $size + + #new-block
                // Load the block after the one we are splitting.
                $block load32 #n
                // Set the next-pointer of the new block.
                $new-block $n store32
                // Set the size of the new block.
                $new-block 4 + $block-size 12 - $size - store32
                // Mark the new block as unused.
                $new-block 8 + 0 store32
            } else {
                0 !.i32 #new-block
            }
            $block !..i32 $new-block store32
            $block 4 + $size 12 + store32
            $block 8 + 1 store32

            $root $prev = if {
                $new-block !i32 0 = if {
                    $MEM !.i32 $block !i32 store32
                } else {
                    $MEM !.i32 $new-block !i32 store32
                }
            } else {
                $prev $new-block !i32 store32
            }

            $block 12 + break
        }
        $next !i32 0 = if {
            0 !.i32 break
        }
        $block #prev
        $next #block
    }
}

fn find_next_free(block: .i32) -> .i32 {
    loop {
        $block !i32 0 = if { 0 !.i32 break }
        $block 8 + load32 0 = if {
            $block break
        }
        $block !..i32 load32 #block
    }
}

fn free(ptr: .i32) {
    local block: .i32
    local next: .i32
    local next_free: .i32
    local root: .i32
    local b: .i32

    $ptr 12 - #block
    $block load32 !.i32 #next
    $next find_next_free #next_free

    $block $next_free !i32 store32
    $block 8 + 0 store32

    $MEM load32 !.i32 #root
    $root !i32 $block !i32 > if {
        $MEM $block !i32 store32
    } else {
        $block $root = $root load32 0 = and if {
            // The last block is being freed, therefore 
            // everything is free and we can simply reset.
            init
        } else {
            $root #b
            loop {
                $b $b 4 + load32 + $block = if {
                    $b !..i32 $block store32 
                    break
                }
                $b load32 !.i32 #b
            }
        }
    }
    merge
}

fn merge() {
    local root: .i32
    local block: .i32
    local next: .i32
    local size: i32
    local used: bool
    local next_next: .i32
    local next_size: i32
    local next_used: bool

    $MEM load32 !.i32 #root
    $root #block

    loop {
        $block !i32 0 = if { break }
        $block load32 !.i32 #next
        $next !i32 0 = if { break }
        
        $block 4 + load32 #size
        $block 8 + load32 0 /= #used
        $next load32 !.i32 #next_next
        $next 4 + load32 #next_size
        $next 8 + load32 0 /= #next_used

        $block $size + $next = $used not and $next_used not and if {
            $block $next_next !i32 store32
            $block 4 + $size $next_size + store32
        } else {
            $next #block
        }
    }
}

