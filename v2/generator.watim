import "../std/core.watim" as Core (align-to)
import "../std/maybe.watim" as Maybe (Maybe, is-some)
import "../std/arena.watim" as Arena (Arena)
import "../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../std/byte-array.watim" as ByteArray (ByteArray)
import "../std/array.watim" as Array (Array)
import "../std/map.watim" as Map (Map)
import "../std/fmt.watim" as Fmt (Formatter, ByteSlice-format)
import "../std/util.watim" as Util (i32-format, bool-format)

import "./lexer.watim" as Lexer (Token, Token-lexeme, Token-format)
import "./type.watim" as Type (CustomTypeHandle)
import "./env.watim" as Env (LocalId)
import "./resolver.watim" as Resolver (GlobalId, VarId)
import "./monomizer.watim" as Monomized (
    Monomized, Module, ExternOrInstances,
    Extern, Function, FunctionHandle, Signature, Global,
    Type, Key, Key-type, NamedTypeId, TypeId, Local,
    CustomType, CustomType-name, FunType,
    Variant, VariantCase, Struct,
    Word, Intrinsic, FieldAccess, MatchCase,
    type-size, field-offset, can-live-in-reg
)

struct Ctx {
    fmt: .Formatter
    program: .Monomized
    module-data-offsets: Array<i32>
}

fn generate(fmt: .Formatter, program: .Monomized) {
    $fmt "(module\n" Fmt:write
    $fmt Fmt:indent


    0 !.Arena Arena:temp @arena @arena-save

    $arena $program.modules.values.len Arena:alloc-many<i32> $program.modules.values.len
    Array:init-no-copy<i32> @static-data-offsets

    ByteArray:new @all-static-data
    0 @i
    loop {
        $program.modules.values.len $i = if { break }
        &program.modules.values $i Array:get<Monomized:Module> @module
        &static-data-offsets $i $all-static-data.len Array:set<i32> drop
        $arena &all-static-data $module.static-data ByteSlice:unpack ByteArray:push
        $i 1 + #i
    }

    $fmt $program $static-data-offsets make Ctx @ctx

    0 @i
    loop {
        $program.modules.values.len $i = if { break }
        &program.modules.values $i Array:get<Monomized:Module> @module
        0 @j
        loop {
            $j $module.functions.len = if { break }
            &module.functions $j Array:get<ExternOrInstances> match {
                case Extern -> { &ctx flip $i generate-extrn }
                case Instances -> { drop }
            }
            $j 1 + #j
        }
        $i 1 + #i
    }

    $fmt Fmt:write-indent $fmt "(memory 1 65536)\n" Fmt:write
    $fmt Fmt:write-indent $fmt "(export \"memory\" (memory 0))\n" Fmt:write

    &ctx generate-function-table
    &ctx $all-static-data.len 4 align-to generate-globals 4 align-to @stack-start

    $fmt Fmt:write-indent
    $fmt "(global $stac:k (mut i32) (i32.const " Fmt:write
    $fmt $stack-start i32-format
    $fmt "))\n" Fmt:write

    $fmt &all-static-data ByteArray:to-slice generate-data

    &ctx generate-functions

    $fmt generate-intrinsic-functions

    $fmt Fmt:dedent
    $fmt ")" Fmt:write
    $arena $arena-save Arena:restore
}

variant FunctionOrExtern {
    case Extern -> .Extern
    case Function -> .Function
}
fn FunctionOrExtern-name(self: .FunctionOrExtern) -> .Token {
    $self match {
        case Extern -> { ~ .name }
        case Function -> { ~ .name }
    }
}

fn lookup-function(program: .Monomized, handle: .FunctionHandle) -> FunctionOrExtern {
    &program.modules.values $handle.module.index Array:get<Module> @module
    &module.functions $handle.index Array:get<ExternOrInstances> match {
        case Extern -> { make FunctionOrExtern.Extern }
        case Instances -> { $handle.instance Array:get<.Function> ~ make FunctionOrExtern.Function }
    }
}

fn lookup-globl(program: .Monomized, id: .GlobalId) -> .Global {
    &program.modules.values $id.module.index Array:get<Module> .globals $id.index Array:get<Global>
}

fn lookup-type(program: .Monomized, type: TypeId) -> .Type {
    &program.types $type.index Array:get<Maybe<Key>> match {
        case None -> { Core:unreachable<.Type> }
        case Some -> { Key-type }
    }
}

fn lookup-custom-type(program: .Monomized, handle: .CustomTypeHandle) -> .CustomType {
    &program.modules.values $handle.module.index Array:get<Module> .custom-types
    $handle.index Array:get<CustomType>
}

fn generate-extrn(ctx: .Ctx, extrn: .Extern, module-id: i32) {
    $ctx.fmt Fmt:write-indent
    $ctx.fmt "(import " Fmt:write
    $ctx.fmt &extrn.extrn-module ByteSlice-format
    $ctx.fmt " " Fmt:write
    $ctx.fmt &extrn.extrn-name ByteSlice-format
    $ctx.fmt " (" Fmt:write
    make Maybe<Token>.None @export
    $ctx &extrn.signature &export $module-id &extrn.name 0 generate-signature
    $ctx.fmt "))\n" Fmt:write
}

fn generate-data(fmt: .Formatter, data: ByteSlice) {
    $fmt Fmt:write-indent
    $fmt "(data (i32.const 0) " Fmt:write
    $fmt &data Fmt:ByteSlice-format
    $fmt ")\n" Fmt:write
}

fn generate-globals(ctx: .Ctx, static-data-len: i32) -> i32 {
    $static-data-len @offset
    0 @i
    loop {
        $i $ctx.program.modules.values.len = if { $offset break }
        &ctx.program.modules.values $i Array:get<Module> @module

        0 @j
        loop {
            $j $module.globals.len = if { break }
            &module.globals $j Array:get<Global> @globl
            $j 1 + #j
            &ctx.program.sizes $globl.type type-size @size
            $globl.reffed &ctx.program.sizes $globl.type can-live-in-reg not or @lives-in-memory
            $lives-in-memory if { $offset } else { 0 } @initial-value

            $ctx.fmt Fmt:write-indent
            $ctx.fmt "(global $" Fmt:write
            $ctx.fmt &globl.name Token-lexeme Fmt:write
            $ctx.fmt ":" Fmt:write
            $ctx.fmt $i i32-format
            $ctx.fmt " (mut i32) (i32.const " Fmt:write
            $ctx.fmt $initial-value i32-format
            $ctx.fmt "))\n" Fmt:write

            $lives-in-memory if {
                $offset $size + #offset
            }
        }
        $i 1 + #i
    }
}

fn generate-function-table(ctx: .Ctx) { block {
    $ctx.fmt Fmt:write-indent
    $ctx.program.function-table.len 0 = if {
        $ctx.fmt "(table funcref (elem))\n" Fmt:write
        break
    }
    $ctx.fmt "(table funcref (elem $intrinsic:flip\n" Fmt:write

    $ctx.fmt Fmt:indent
    $ctx.fmt Fmt:write-indent

    0 @i
    loop {
        $ctx.program.function-table.len $i = if { break }
        &ctx.program.function-table $i Array:get<FunctionHandle> @handle
        $i 1 + #i

        $ctx.program $handle lookup-function @function
        $ctx.fmt "$" Fmt:write
        $ctx.fmt $handle.module.index i32-format
        $ctx.fmt ":" Fmt:write
        $ctx.fmt &function FunctionOrExtern-name Token-lexeme Fmt:write
        $handle.instance 0 /= if {
            $ctx.fmt ":" Fmt:write
            $ctx.fmt $handle.instance i32-format
        }
        $i $ctx.program.function-table.len /= if {
            $ctx.fmt " " Fmt:write
        }
    }
    $ctx.fmt Fmt:dedent
    $ctx.fmt "))\n" Fmt:write
} }

fn generate-intrinsic-functions(fmt: .Formatter) {
    $fmt Fmt:write-indent
    $fmt "(func $intrinsic:flip (param $a i32) (param $b i32) (result i32 i32) local.get $b local.get $a)\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "(func $intrinsic:dupi32 (param $a i32) (result i32 i32) local.get $a local.get $a)\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "(func $intrinsic:rotate-left (param $a i32) (param $b i32) (param $c i32) (result i32 i32 i32) local.get $b local.get $c local.get $a)\n" Fmt:write
}

fn generate-functions(ctx: .Ctx) {
    0 @module-id
    loop {
        $module-id $ctx.program.modules.values.len = if { break }
        &ctx.program.modules.values $module-id Array:get<Module> @module

        0 @function-id
        loop {
            $function-id $module.functions.len = if { break }
            &module.functions $function-id Array:get<ExternOrInstances> match {
                case Extern -> { drop }
                case Instances -> {
                    @instances

                    0 @instance-id
                    loop {
                        $instance-id $instances.len = if { break }
                        $instances $instance-id Array:get<.Function> ~ @function
                        $ctx $function $module-id $instance-id generate-function
                        $instance-id 1 + #instance-id
                    }
                }
            }

            $function-id 1 + #function-id
        }

        $module-id 1 + #module-id
    }
}

fn globl-lives-in-memory(ctx: .Ctx, globl: .Global) -> bool {
    $ctx.program $globl.type lookup-type match {
        // TODO: this special case for I64s can be removed, once i64 structs are supported
        case I64 -> { 0 1 = }
        case _ -> { drop &ctx.program.sizes $globl.type can-live-in-reg not }
    }
    $globl.reffed or
}

fn local-lives-in-memory(ctx: .Ctx, local: .Local) -> bool {
    $ctx.program $local.type lookup-type match {
        // TODO: this special case for I64s can be removed, once i64 structs are supported
        case I64 -> { 0 1 = }
        case _ -> { drop &ctx.program.sizes $local.type can-live-in-reg not }
    }
    $local.reffed or
}

fn any-local-lives-in-memory(ctx: .Ctx, locals: .Map<LocalId, Local>) -> bool {
    0 @i
    loop {
        $i $locals.values.len = if { 0 1 = break }
        $ctx &locals.values $i Array:get<Local> local-lives-in-memory if {
            1 1 = break
        }
        $i 1 + #i
    }
}

fn generate-function(
    ctx: .Ctx,
    function: .Function,
    module: i32,
    instance: i32
) {
    $ctx.fmt Fmt:write-indent
    $ctx.fmt "(" Fmt:write
    $ctx &function.signature &function.export $module &function.name $instance generate-signature
    $function.generic-arguments.len 0 /= if {
        $ctx.fmt " ;;" Fmt:write
        0 @i
        loop {
            $i $function.generic-arguments.len = if { break }
            $ctx.fmt " " Fmt:write
            $ctx
            &function.generic-arguments $i Array:get<TypeId> ~
            generate-type-pretty
            $i 1 + #i
        }
    }
    $ctx.fmt "\n" Fmt:write
    $ctx.fmt Fmt:indent
    $ctx &function.locals generate-locals

    0 @i
    loop {
        $i $function.max-stack-returns = if { break }
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "(local $s" Fmt:write
        $ctx.fmt $i i32-format
        $ctx.fmt ":a i32)\n" Fmt:write
        $i 1 + #i
    }

    $function.local-copy-space 0 /= if {
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "(local $locl-copy-spac:e i32)\n" Fmt:write
    }

    $function.local-copy-space 0 /=
    $ctx &function.locals any-local-lives-in-memory or @uses-stack
    $uses-stack if {
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "(local $stac:k i32)\n" Fmt:write
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "global.get $stac:k local.set $stac:k\n" Fmt:write
    }

    $function.local-copy-space 0 /= if {
        $ctx "locl-copy-spac:e" $function.local-copy-space 0 0 generate-memory-slot
    }

    $ctx &function.locals generate-memory-slots-for-locals

    $ctx $module &function.locals &function.words generate-words

    $uses-stack if {
        $ctx.fmt Fmt:write-indent
        $ctx.fmt "local.get $stac:k global.set $stac:k\n" Fmt:write
    }

    $ctx.fmt Fmt:dedent
    $ctx.fmt Fmt:write-indent
    $ctx.fmt ")\n" Fmt:write
}

fn generate-memory-slots-for-locals(ctx: .Ctx, locals: .Map<LocalId, Local>) {
    0 @i
    loop {
        $i $locals.values.len = if { break }
        &locals.values $i Array:get<Local> @local

        $ctx $local local-lives-in-memory @lives-in-memory
        &ctx.program.sizes $local.type can-live-in-reg @can-live-in-reg

        $local.is-parameter $lives-in-memory and $can-live-in-reg and if {
            // This parameter must be put on the stack, because it is reffed
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "global.get $stac:k global.get $stac:k local.get $" Fmt:write
            $ctx.fmt &local.name Token-lexeme Fmt:write
            $ctx.fmt " " Fmt:write
            $ctx $local.type generate-type
            $ctx.fmt ".store local.tee $" Fmt:write
            $ctx.fmt &local.name Token-lexeme Fmt:write
            $ctx.fmt " i32.const " Fmt:write
            $ctx.fmt &ctx.program.sizes $local.type type-size i32-format
            $ctx.fmt " i32.add global.set $stac:k\n" Fmt:write
        }

        $local.is-parameter not $lives-in-memory and if {
            &locals.keys $i Array:get<LocalId> @local-id

            $ctx
            &local.name Token-lexeme
            &ctx.program.sizes $local.type type-size
            $local-id.scope
            $local-id.shadow
            generate-memory-slot
        }

        $i 1 + #i
    }
}

fn generate-memory-slot(ctx: .Ctx, name-ptr: .i32, name-len: i32, size: i32, scope: i32, shadow: i32) {
    $ctx.fmt Fmt:write-indent
    $ctx.fmt "global.get $stac:k global.get $stac:k i32.const " Fmt:write
    $ctx.fmt $size 4 align-to i32-format
    $ctx.fmt " i32.add global.set $stac:k local.set $" Fmt:write
    $ctx.fmt $name-ptr $name-len Fmt:write
    $scope 0 /= $shadow 0 /= or if {
        $ctx.fmt ":" Fmt:write
        $ctx.fmt $scope i32-format
        $ctx.fmt ":" Fmt:write
        $ctx.fmt $shadow i32-format
    }
    $ctx.fmt "\n" Fmt:write
}

fn generate-locals(ctx: .Ctx, locals: .Map<LocalId, Local>) {
    0 @i
    loop {
        $i $locals.values.len = if { break }
        &locals.values $i Array:get<Local> @local
        $local.is-parameter not if {
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "(local $" Fmt:write
            $ctx.fmt &local.name Token-lexeme Fmt:write
            &locals.keys $i Array:get<LocalId> @local-id
            $local-id.scope 0 /= $local-id.shadow 0 /= or if {
                $ctx.fmt ":" Fmt:write
                $ctx.fmt $local-id.scope i32-format
                $ctx.fmt ":" Fmt:write
                $ctx.fmt $local-id.shadow i32-format
            }
            $ctx.fmt " " Fmt:write
            $ctx $local.type generate-type
            $ctx.fmt ")\n" Fmt:write
        }
        $i 1 + #i
    }
}

fn generate-words(ctx: .Ctx, module: i32, locals: .Map<LocalId, Local>, words: .Array<Word>) {
    0 @i
    loop {
        $i $words.len = if { break }
        $ctx $module $locals $words $i Array:get<Word> generate-word
        $i 1 + #i
    }
}

fn generate-word(ctx: .Ctx, module: i32, locals: .Map<LocalId, Local>, word: .Word) {
    $ctx.fmt Fmt:write-indent
    $word match {
        case Number -> {
            $ctx.fmt "i32.const " Fmt:write
            $ctx.fmt flip Token-lexeme Fmt:write
        }
        case String -> {
            @word
            $ctx.fmt "i32.const " Fmt:write
            $ctx.fmt
            &ctx.module-data-offsets $module Array:get<i32> ~ $word.offset +
            i32-format
            $ctx.fmt " i32.const " Fmt:write
            $ctx.fmt $word.len i32-format
        }
        case Drop -> {
            drop $ctx.fmt "drop" Fmt:write
        }
        case Intrinsic -> {
            .intrinsic $ctx flip generate-intrinsic
        }
        case InitLocal -> {
            @word
            $locals &word.local Map:get<LocalId, Local> Maybe:assert-some<.Local> @local
            $ctx $local local-lives-in-memory not if {
                // The local does not live in linear memory, so
                // the target_taip must also already be on the stack unpacked.
                0 &ctx.program.sizes $word.type can-live-in-reg !i32 / drop // assert can-live-in-reg

                $ctx.fmt "local.set " Fmt:write
                $ctx.fmt $local &word.local generate-local-ident
            } else {
                $ctx.fmt "local.get " Fmt:write
                $ctx.fmt $local &word.local generate-local-ident
                $ctx.fmt " call $intrinsic:flip " Fmt:write
                $ctx $word.type generate-store
            }
        }
        case GetLocal -> {
            @word
            &ctx.program.sizes $word.result-type can-live-in-reg @result-can-live-in-reg

            $ctx.program $word.result-type lookup-type @result-type

            // TODO: this hack can be removed, once i64 structs are supported
            $result-type match {
                case I64 -> { 1 1 = #result-can-live-in-reg }
                case _ -> { drop }
            }

            $result-can-live-in-reg not if {
                // set up the address to store the result in
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset i32-format
                $ctx.fmt " i32.add call $intrinsic:dupi32 " Fmt:write
            }
            &word.var match {
                case Global -> {
                    @global-id
                    $ctx.fmt "global.get $" Fmt:write
                    $ctx.program $global-id lookup-globl @globl
                    $ctx.fmt &globl.name Token-lexeme Fmt:write
                    $ctx.fmt ":" Fmt:write
                    $ctx.fmt $global-id.module.index i32-format
                    $ctx $globl globl-lives-in-memory
                }
                case Local -> {
                    @local-id
                    $ctx.fmt "local.get " Fmt:write
                    $locals $local-id Map:get<LocalId, Local> Maybe:assert-some<.Local> @local
                    $ctx.fmt $local $local-id generate-local-ident
                    $ctx $local local-lives-in-memory
                }
            } @var-lives-in-memory
            // at this point, either the value itself or a pointer to it is on the stack

            0 !.Arena Arena:temp @temp @temp-save
            $temp $ctx &word.fields $var-lives-in-memory determine-loads @loads

            &ctx.program.sizes $word.result-type type-size @result-size

            $loads.len 0 = if {
                $result-can-live-in-reg not if {
                    $ctx.fmt " i32.const " Fmt:write
                    $ctx.fmt $result-size i32-format
                    $ctx.fmt " memory.copy" Fmt:write
                } else {
                    $var-lives-in-memory if {
                        $ctx.fmt $result-type match {
                            case I64 -> { " i64.load" }
                            case _ -> { drop " i32.load" }
                        } Fmt:write
                    }
                }
            } else {
                0 @i
                loop {
                    $i $loads.len = if { break }
                    &loads $i Array:get<i32> ~ @load
                    $i 1 + #i
                    $i $loads.len = $result-can-live-in-reg not and if {
                        $ctx.fmt " i32.const " Fmt:write
                        $ctx.fmt $load i32-format
                        $ctx.fmt " i32.add i32.const " Fmt:write
                        $ctx.fmt $result-size i32-format
                        $ctx.fmt " memory.copy" Fmt:write
                        break
                    }
                    $ctx.fmt " i32.load offset=" Fmt:write
                    $ctx.fmt $load i32-format
                }
            }
            $temp $temp-save Arena:restore

        }
        case SetLocal -> {
            @word
            0 !.Arena Arena:temp @temp @temp-save
            &word.var match {
                case Local -> {
                    $locals flip Map:get<LocalId, Local> Maybe:assert-some<.Local> @local
                    $ctx $local local-lives-in-memory
                    $local.type
                }
                case Global -> {
                    $ctx.program flip lookup-globl @globl
                    $ctx $globl globl-lives-in-memory
                    $globl.type
                }
            } @var-type @var-lives-in-memory
            $temp $ctx &word.fields $var-lives-in-memory determine-loads @loads
            $loads.len 0 = $var-lives-in-memory not and if {
                $ctx.fmt &word.var match {
                    case Local -> { drop "local.set " }
                    case Global -> { drop "global.set " }
                } Fmt:write
                $ctx $locals &word.var generate-var-ident
            } else {
                $ctx.fmt &word.var match {
                    case Local -> { drop "local.get " }
                    case Global -> { drop "global.get " }
                } Fmt:write
                $ctx $locals &word.var generate-var-ident

                $word.fields.len 0 = if { $var-type } else {
                    &word.fields $word.fields.len 1 - Array:get<FieldAccess> .target-type ~
                } @target-type

                $loads.len 0 = if {
                    $ctx.fmt " call $intrinsic:flip " Fmt:write
                    $ctx $target-type generate-store
                } else {
                    0 @i
                    loop {
                        $i $loads.len = if { break }
                        &loads $i Array:get<i32> ~ @load
                        $i 1 + #i
                        $ctx.fmt " i32.const " Fmt:write
                        $ctx.fmt $load i32-format
                        $ctx.fmt " i32.add " Fmt:write
                        $i $loads.len = if {
                            $ctx.fmt "call $intrinsic:flip " Fmt:write
                            $ctx $target-type generate-store
                        } else {
                            $ctx.fmt "i32.load" Fmt:write
                        }
                    }
                }
            }
            $temp $temp-save Arena:restore
        }
        case RefLocal -> {
            @word
            0 !.Arena Arena:temp @temp @temp-save
            $temp $ctx &word.fields 1 1 = determine-loads @loads
            $ctx.fmt &word.var match {
                case Local -> { drop "local.get " }
                case Global -> { drop "global.get " }
            } Fmt:write
            $ctx $locals &word.var generate-var-ident
            0 @i
            loop {
                $i $loads.len = if { break }
                &loads $i Array:get<i32> ~ @load
                $i 1 + #i
                $i $loads.len = if {
                    $ctx.fmt " i32.const " Fmt:write
                    $ctx.fmt $load i32-format
                    $ctx.fmt " i32.add" Fmt:write
                } else {
                    $ctx.fmt " i32.load offset=" Fmt:write
                    $ctx.fmt $load i32-format
                }
            }
            $temp $temp-save Arena:restore
        }
        case Call -> {
            @word
            $ctx.fmt "call $" Fmt:write
            $ctx.fmt $word.function.module.index i32-format
            $ctx.fmt ":" Fmt:write
            $ctx.fmt $ctx.program &word.function lookup-function match {
                case Extern -> { @ext &ext.name &ext.signature }
                case Function -> { @fun &fun.name &fun.signature }
            } @signature Token-lexeme Fmt:write
            $word.function.instance 0 /= if {
                $ctx.fmt ":" Fmt:write
                $ctx.fmt $word.function.instance i32-format
            }
            $ctx $word.copy-space-offset &signature.returns write-return-receivers
        }
        case If -> {
            @word
            $ctx.fmt "(if" Fmt:write
            $ctx &word.parameters generate-parameters-unnamed
            $ctx &word.returns match {
                case None -> { drop }
                case Some -> { generate-returns }
            }
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "(then\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx $module $locals &word.true-words generate-words
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")\n" Fmt:write
            $word.false-words.len 0 /= if {
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "(else\n" Fmt:write
                $ctx.fmt Fmt:indent
                $ctx $module $locals &word.false-words generate-words
                $ctx.fmt Fmt:dedent
                $ctx.fmt Fmt:write-indent
                $ctx.fmt ")\n" Fmt:write
            }
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")" Fmt:write
            &word.returns match {
                case None -> {
                    $ctx.fmt "\n" Fmt:write
                    $ctx.fmt Fmt:write-indent
                    $ctx.fmt "unreachable" Fmt:write
                }
                case Some -> { drop }
            }
        }
        case Break -> { drop $ctx.fmt "br $block" Fmt:write }
        case Block -> {
            @word
            $ctx.fmt "(block $block" Fmt:write
            $ctx &word.parameters generate-parameters-unnamed
            $ctx &word.returns generate-returns
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx $module $locals &word.words generate-words
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")" Fmt:write
        }
        case Loop -> {
            @word
            $ctx.fmt "(block $block " Fmt:write
            $ctx &word.parameters generate-parameters-unnamed
            $ctx &word.returns match { case Some -> { generate-returns } case None -> { drop } }
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "(loop $loop " Fmt:write
            $ctx &word.parameters generate-parameters-unnamed
            $ctx &word.returns match { case Some -> { generate-returns } case None -> { drop } }
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $ctx $module $locals &word.words generate-words
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "br $loop\n" Fmt:write
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")\n" Fmt:write
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt ")" Fmt:write
            &word.returns match {
                case Some -> { drop }
                case None -> {
                    $ctx.fmt "\n" Fmt:write
                    $ctx.fmt Fmt:write-indent
                    $ctx.fmt "unreachable" Fmt:write
                }
            }
        }
        case Load -> {
            @word
            &ctx.program.sizes $word.type can-live-in-reg if {
                $ctx $word.type generate-type
                $ctx.fmt ".load" Fmt:write
            } else {
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset i32-format
                $ctx.fmt " i32.add call $intrinsic:dupi32 call $intrinsic:rotate-left i32.const " Fmt:write
                $ctx.fmt &ctx.program.sizes $word.type type-size i32-format
                $ctx.fmt " memory.copy" Fmt:write
            }
        }
        case Struct -> {
            @word
            $ctx.program $word.type lookup-type match {
                case Custom -> {}
                case _ -> { drop Core:unreachable<.CustomTypeHandle> }
            } @custom-type-handle
            $ctx.program $custom-type-handle lookup-custom-type match {
                case Variant -> { drop Core:unreachable<.Struct> }
                case Struct -> {}
            } @struc

            &ctx.program.sizes $word.type type-size @type-size
            &ctx.program.sizes $word.type can-live-in-reg if {
                $type-size 0 = if {
                    0 @i
                    loop {
                        $i $struc.fields.len = if { break }
                        $ctx.fmt "drop " Fmt:write
                        $i 1 + #i
                    }
                    $ctx.fmt "i32.const 0 " Fmt:write
                }
                $ctx.fmt ";; make " Fmt:write
                $ctx $word.type generate-type-pretty
            } else {
                $ctx.fmt ";; make " Fmt:write
                $ctx $word.type generate-type-pretty
                $ctx.fmt "\n" Fmt:write
                $ctx.fmt Fmt:indent
                $struc.fields.len @i
                loop {
                    $i 0 = if { break }
                    $i 1 - @field-index
                    &struc.fields $field-index Array:get<NamedTypeId> @field
                    &ctx.program.sizes $struc $field-index field-offset @field-offset
                    $ctx.fmt Fmt:write-indent
                    $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                    $ctx.fmt $word.copy-space-offset $field-offset + i32-format
                    $ctx.fmt " i32.add call $intrinsic:flip " Fmt:write
                    $ctx $field.type generate-store
                    $ctx.fmt "\n" Fmt:write
                    $i 1 - #i
                }
                $ctx.fmt Fmt:dedent
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset i32-format
                $ctx.fmt " i32.add ;; make " Fmt:write
                $ctx $word.type generate-type-pretty
                $ctx.fmt " end" Fmt:write
            }
        }
        case StructNamed -> {
            @word
            $ctx.program $word.type lookup-type match {
                case Custom -> {}
                case _ -> { drop Core:unreachable<.CustomTypeHandle> }
            } @custom-type-handle
            $ctx.program $custom-type-handle lookup-custom-type match {
                case Variant -> { drop Core:unreachable<.Struct> }
                case Struct -> {}
            } @struc
            &ctx.program.sizes $word.type type-size @type-size
            $type-size 0 = if {
                0 @i
                loop {
                    $i $struc.fields.len = if { break }
                    $ctx.fmt "drop " Fmt:write
                    $i 1 + #i
                }
                $ctx.fmt "i32.const 0 ;; make " Fmt:write
                $ctx $word.type generate-type-pretty
            } else {
                $ctx.fmt ";; make " Fmt:write
                $ctx $word.type generate-type-pretty
                $ctx.fmt "\n" Fmt:write
                $ctx.fmt Fmt:indent
                $ctx $module $locals &word.words generate-words
                $ctx.fmt Fmt:dedent
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset i32-format
                $ctx.fmt " i32.add ;; make " Fmt:write
                $ctx $word.type generate-type-pretty
                $ctx.fmt " end" Fmt:write
            }
        }
        case FieldInit -> {
            @word
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add call $intrinsic:flip " Fmt:write
            $ctx $word.type generate-store
        }
        case Variant -> {
            @word
            $ctx.program $word.type lookup-type match {
                case Custom -> {}
                case _ -> { drop Core:unreachable<.CustomTypeHandle> }
            } @custom-type-handle
            $ctx.program $custom-type-handle lookup-custom-type match {
                case Variant -> {}
                case Struct -> { drop Core:unreachable<.Variant> }
            } @varint
            &varint.cases $word.tag Array:get<VariantCase> @cays
            &ctx.program.sizes $word.type can-live-in-reg if {
                $cays.type match {
                    case Some -> { drop $ctx.fmt "drop " Fmt:write }
                    case None -> {}
                }
                $ctx.fmt "i32.const " Fmt:write
                $ctx.fmt $word.tag i32-format
                $ctx.fmt " ;; store tag " Fmt:write
                $ctx.fmt &varint.name Token-lexeme Fmt:write
                $ctx.fmt "." Fmt:write
                $ctx.fmt &cays.name Token-lexeme Fmt:write
            } else {
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset i32-format
                $ctx.fmt " i32.add i32.const " Fmt:write
                $ctx.fmt $word.tag i32-format
                $ctx.fmt " i32.store ;; store tag\n" Fmt:write
                $cays.type match {
                    case Some -> {
                        @case-type
                        $ctx.fmt Fmt:write-indent
                        $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                        $ctx.fmt $word.copy-space-offset 4 + i32-format
                        $ctx.fmt " i32.add call $intrinsic:flip " Fmt:write
                        &ctx.program.sizes $case-type can-live-in-reg not if {
                            $ctx.fmt "i32.const " Fmt:write
                            $ctx.fmt &ctx.program.sizes $case-type type-size i32-format
                            $ctx.fmt " memory.copy ;; store value\n" Fmt:write
                        } else {
                            $ctx $case-type generate-type
                            $ctx.fmt ".store ;; store value\n" Fmt:write
                        }
                    }
                    case None -> {}
                }
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset i32-format
                $ctx.fmt " i32.add" Fmt:write
            }
        }
        case Match -> {
            @word
            $ctx.program $word.type lookup-type match {
                case Custom -> {}
                case _ -> { drop Core:unreachable<.CustomTypeHandle> }
            } @custom-type-handle
            $ctx.program $custom-type-handle lookup-custom-type match {
                case Variant -> {}
                case Struct -> { drop Core:unreachable<.Variant> }
            } @varint
            $ctx.fmt ";; match on " Fmt:write
            $ctx.fmt &varint.name Token-lexeme Fmt:write
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:write-indent
            0 @i
            &ctx.program.sizes $word.type can-live-in-reg @variant-can-live-in-reg
            loop {
                $i $word.cases.len = if {
                    &word.default match {
                        case None -> {
                            $ctx.fmt "unreachable" Fmt:write
                        }
                        case Some -> {
                            $ctx flip $module flip $locals flip generate-words
                        }
                    }
                    break
                }
                &word.cases $i Array:get<MatchCase> @cays
                $ctx.fmt "call $intrinsic:dupi32 " Fmt:write
                $variant-can-live-in-reg not $word.by-ref or if {
                    $ctx.fmt "i32.load " Fmt:write
                }
                $ctx.fmt "i32.const " Fmt:write
                $ctx.fmt $cays.tag i32-format
                $ctx.fmt " i32.eq (if (param i32)" Fmt:write
                $ctx &word.parameters generate-parameters-unnamed
                $ctx &word.returns generate-returns
                $ctx.fmt "\n" Fmt:write
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "(then\n" Fmt:write
                $ctx.fmt Fmt:indent
                $ctx.fmt Fmt:write-indent
                $cays.type match {
                    case None -> {
                        $ctx.fmt "drop" Fmt:write
                        $ctx.fmt "\n" Fmt:write
                    }
                    case Some -> {
                        @case-type
                        &ctx.program.sizes $case-type type-size 0 /= if {
                            $ctx.fmt "i32.const 4 i32.add" Fmt:write
                            $word.by-ref not if { &ctx.program.sizes $case-type can-live-in-reg if {
                                $ctx.fmt " " Fmt:write
                                $ctx $case-type generate-type
                                $ctx.fmt ".load" Fmt:write
                            } }
                            $ctx.fmt "\n" Fmt:write
                        }
                    }
                }
                $ctx $module $locals &cays.words generate-words
                $ctx.fmt Fmt:dedent
                $ctx.fmt Fmt:write-indent
                $ctx.fmt ")\n" Fmt:write
                $ctx.fmt Fmt:write-indent
                $i 1 + $word.cases.len = &word.default is-some<Array<Word>> and if {
                    $ctx.fmt "(else\n" Fmt:write
                    $ctx.fmt Fmt:indent
                } else {
                    $ctx.fmt "(else " Fmt:write
                }
                $i 1 + #i
            }
            loop {
                $i 0 = if { break }
                $i $word.cases.len = &word.default is-some<Array<Word>> and if {
                    $ctx.fmt Fmt:dedent
                    $ctx.fmt Fmt:write-indent
                }
                $ctx.fmt "))" Fmt:write
                $i 1 - #i
            }
        }
        case Flip -> { drop $ctx.fmt "call $intrinsic:flip" Fmt:write }
        case Cast -> {
            @word
            block {
                &ctx.program.sizes $word.src can-live-in-reg
                &ctx.program.sizes $word.dst can-live-in-reg and
                if {
                    &ctx.program.sizes $word.src type-size @src-size
                    &ctx.program.sizes $word.dst type-size @dst-size
                    $src-size 4 le $dst-size 4 gt and if {
                        $ctx.fmt "i64.extend_i32_s ;; cast to " Fmt:write
                        $ctx $word.dst generate-type-pretty
                        break
                    }
                    $ctx.fmt ";; cast to " Fmt:write
                    $ctx $word.dst generate-type-pretty
                    break
                }

                $ctx.program $word.dst lookup-type match {
                    case I64 -> {
                        &ctx.program.sizes $word.src can-live-in-reg if {
                            $ctx.fmt "i64.extend_i32_s" Fmt:write
                            break
                        }
                    }
                    case _ -> { drop }
                }

                $ctx.fmt "UNSUPPORTED Cast from " Fmt:write
                $ctx $word.src generate-type-pretty
                $ctx.fmt " to " Fmt:write
                $ctx $word.dst generate-type-pretty
            }
        }
        case Sizeof -> {
            &ctx.program.sizes flip ~ type-size
            $ctx.fmt "i32.const " Fmt:write
            $ctx.fmt flip i32-format
        }
        case IndirectCall -> {
            @word
            $ctx.program $word.type lookup-type match {
                case Fun -> {}
                case _ -> { drop Core:unreachable<.FunType> }
            } @fun-type
            $ctx.fmt "(call_indirect" Fmt:write
            $ctx &fun-type.parameters generate-parameters-unnamed
            $ctx &fun-type.returns generate-returns
            $ctx.fmt ")" Fmt:write
            $ctx $word.copy-space-offset &fun-type.returns write-return-receivers
        }
        case GetField -> {
            @word
            0 !.Arena Arena:temp @temp @temp-save
            $temp $ctx &word.fields $word.on-ptr determine-loads @loads
            block {
                $word.on-ptr $loads.len 1 = and if {
                    &loads 0 Array:get<i32> ~ 0 = if {
                        // Accessing a field at offset 0 on a ptr is a no-op.
                        // eg.: struct V2 { x: i32 y: i32 }
                        //      fn example() { 0 !.V2 .x drop }
                        $ctx.fmt ";; GetField was no-op" Fmt:write
                        break
                    }
                }
                &ctx.program.sizes $word.type can-live-in-reg @target-type-can-live-in-reg
                $word.on-ptr not $target-type-can-live-in-reg not and if {
                    $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                    $ctx.fmt $word.copy-space-offset i32-format
                    $ctx.fmt " i32.add call $intrinsic:dupi32 " Fmt:write
                }
                0 @i
                loop {
                    $i $loads.len = if { break }
                    &loads $i Array:get<i32> ~ @load
                    $i 1 + #i
                    $i $loads.len = if {
                        $word.on-ptr $load 0 /= and if {
                            $ctx.fmt "i32.const " Fmt:write
                            $ctx.fmt $load i32-format
                            $ctx.fmt " i32.add" Fmt:write
                        }
                        $word.on-ptr not if {
                            $target-type-can-live-in-reg if {
                                $ctx.fmt "i32.load offset=" Fmt:write
                                $ctx.fmt $load i32-format
                            } else {
                                $ctx.fmt " i32.const " Fmt:write
                                $ctx.fmt $load i32-format
                                $ctx.fmt " i32.add i32.const " Fmt:write
                                $ctx.fmt &ctx.program.sizes $word.type type-size i32-format
                                $ctx.fmt " memory.copy" Fmt:write
                            }
                        }
                        break
                    }
                    $word.on-ptr not if {
                        $ctx.fmt "i32.load offset=" Fmt:write
                        $ctx.fmt $load i32-format
                    } else {
                        $ctx.fmt "i32.load offset=" Fmt:write
                        $ctx.fmt $load i32-format
                    }
                }
            }
            $temp $temp-save Arena:restore
        }
        case Uninit -> {
            @word
            &ctx.program.sizes $word.type can-live-in-reg if {
                $ctx.fmt "i32.const 0" Fmt:write
            } else {
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset i32-format
                $ctx.fmt " i32.add" Fmt:write
            }
        }
        case FunRef -> {
            $ctx.fmt "i32.const " Fmt:write
            .table-index ~ $ctx.fmt flip 1 + i32-format
        }
        case StoreLocal -> {
            @word
            $ctx.fmt &word.var match {
                case Local -> { drop "local.get " }
                case Global -> { drop "global.get " }
            } Fmt:write
            $ctx $locals &word.var generate-var-ident
            0 !.Arena Arena:temp @temp @temp-save
            $temp $ctx &word.fields 1 1 = determine-loads @loads
            0 @i
            loop {
                $i $loads.len = if { break }
                &loads $i Array:get<i32> ~ @load
                $ctx.fmt " i32.load offset=" Fmt:write
                $ctx.fmt $load i32-format
                $i 1 + #i
            }
            $ctx.fmt " call $intrinsic:flip " Fmt:write
            $ctx $word.type generate-store
            $temp $temp-save Arena:restore
        }
        case MakeTuple -> { block {
            @word
            $ctx.program $word.type lookup-type match {
                case Tuple -> {}
                case _ -> { drop Core:unreachable<.Array<TypeId>> }
            } @items
            &ctx.program.sizes $word.type type-size @tuple-size
            &ctx.program.sizes $word.type can-live-in-reg if {
                $tuple-size 0 = if {
                    0 @i
                    loop {
                        $i $items.len = if { break }
                        $ctx.fmt "drop " Fmt:write
                        $i 1 + #i
                    }
                }
                $ctx.fmt ";; make " Fmt:write
                $ctx $word.type generate-type-pretty
                break
            }
            $ctx.fmt ";; make " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt "\n" Fmt:write
            $tuple-size @item-offset
            $ctx.fmt Fmt:indent
            $items.len @i
            loop {
                $i 0 = if { break }
                $i 1 - #i
                $items $i Array:get<TypeId> ~ @item
                &ctx.program.sizes $item type-size @item-size
                $item-offset $item-size - #item-offset
                $ctx.fmt Fmt:write-indent
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $word.copy-space-offset $item-offset + i32-format
                $ctx.fmt " i32.add call $intrinsic:flip " Fmt:write
                &ctx.program.sizes $item can-live-in-reg if {
                    $ctx.fmt "i32.store\n" Fmt:write
                } else {
                    $ctx.fmt "i32.const " Fmt:write
                    $ctx.fmt $item-size i32-format
                    $ctx.fmt " memory.copy\n" Fmt:write
                }
            }
            $ctx.fmt Fmt:dedent
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
            $ctx.fmt $word.copy-space-offset i32-format
            $ctx.fmt " i32.add ;; make " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt " end" Fmt:write
        } }
        case UnpackTuple -> {
            @word
            $ctx.program $word.type lookup-type match {
                case Tuple -> {}
                case _ -> { drop Core:unreachable<.Array<TypeId>> }
            } @items
            $ctx.fmt ";; unpack " Fmt:write
            $ctx $word.type generate-type-pretty
            $ctx.fmt "\n" Fmt:write
            $ctx.fmt Fmt:indent
            $word.copy-space-offset @copy-space-offset
            0 @offset
            0 @i
            loop {
                $i $items.len = if { break }
                $items $i Array:get<TypeId> ~ @item
                $i 1 + #i
                &ctx.program.sizes $item type-size @item-size
                $ctx.fmt Fmt:write-indent
                $item-size 0 = if {
                    $ctx.fmt "i32.const " Fmt:write
                } else {
                    $i $items.len /= if {
                        $ctx.fmt "call $intrinsic:dupi32 " Fmt:write
                    }
                    $ctx.fmt "i32.const " Fmt:write
                    $ctx.fmt $offset i32-format
                    $ctx.fmt " i32.add " Fmt:write

                    &ctx.program.sizes $item can-live-in-reg if {
                        $ctx.fmt "i32.load" Fmt:write
                    } else {
                        $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                        $ctx.fmt $copy-space-offset i32-format
                        $ctx.fmt " i32.add call $intrinsic:dupi32 call $intrinsic:rotate-left i32.const " Fmt:write
                        $ctx.fmt $item-size i32-format
                        $ctx.fmt " memory.copy" Fmt:write
                        $copy-space-offset $item-size + #copy-space-offset
                    }
                    $i $items.len /= if {
                        $ctx.fmt " call $intrinsic:flip\n" Fmt:write
                    }
                }
                $offset $item-size + #offset
            }
            $ctx.fmt Fmt:dedent
        }
    }
    $ctx.fmt "\n" Fmt:write
}

fn write-return-receivers(ctx: .Ctx, offset: i32, returns: .Array<TypeId>) {
    0 @i
    loop {
        $i $returns.len = if {
            // all returns can live in reg
            0 1 = break
        }
        &ctx.program.sizes $returns $i Array:get<TypeId> ~ can-live-in-reg not if {
            $ctx.program $returns $i Array:get<TypeId> ~ lookup-type match {
                // TODO: this special case for I64s can be removed, once i64 structs are supported
                case I64 -> {}
                case _ -> {
                    drop
                    1 1 = break
                }
            }
        }
        $i 1 + #i
    } if {
        // not all returns can live in reg
        $ctx.fmt "\n" Fmt:write
        0 @i
        loop {
            $i $returns.len = if { break }
            $ctx.fmt Fmt:write-indent
            $ctx.fmt "local.set $s" Fmt:write
            $ctx.fmt $i i32-format
            $ctx.fmt ":a\n" Fmt:write
            $i 1 + #i
        }
        $returns.len @i
        loop {
            $i 0 = if { break }
            $returns $returns.len $i - Array:get<TypeId> ~ @ret
            $ctx.fmt Fmt:write-indent
            &ctx.program.sizes $ret can-live-in-reg if {
                $ctx.fmt "local.get $s" Fmt:write
                $ctx.fmt $i 1 - i32-format
                $ctx.fmt ":a" Fmt:write
            } else {
                $ctx.fmt "local.get $locl-copy-spac:e i32.const " Fmt:write
                $ctx.fmt $offset i32-format
                $ctx.fmt " i32.add call $intrinsic:dupi32 local.get $s" Fmt:write
                $ctx.fmt $i 1 - i32-format
                $ctx.fmt ":a i32.const " Fmt:write
                &ctx.program.sizes $ret type-size @ret-size
                $ctx.fmt $ret-size i32-format
                $ctx.fmt " memory.copy" Fmt:write
                $offset $ret-size + #offset
            }
            $i 1 - #i
            $i 0 = if { break }
            $ctx.fmt "\n" Fmt:write
        }
    }
}

fn determine-loads(arena: .Arena, ctx: .Ctx, fields: .Array<FieldAccess>, lives-in-memory: bool) -> Array<i32> {
    Array:new<i32> @loads
    0 @i
    loop {
        $i $fields.len = if { $loads break }
        $fields $i Array:get<FieldAccess> @field
        $ctx.program $field.source-type lookup-type match {
            case Ptr -> { drop 1 1 = }
            case _ -> { drop 0 1 = }
        } @source-type-is-ptr
        &ctx.program.sizes $field.source-type can-live-in-reg
        $i 0 = $lives-in-memory and not and
        $source-type-is-ptr not and if {
            $i 1 + #i
        } else {
            0 @offset
            loop {
                $i $fields.len = if { break }
                $fields $i Array:get<FieldAccess> @field

                $ctx.program $field.source-type lookup-type match {
                    case Custom -> {}
                    case Ptr -> { $ctx.program flip ~ lookup-type match {
                        case Custom -> {}
                        case _ -> { drop Core:unreachable<.CustomTypeHandle> }
                    } }
                    case _ -> { drop Core:unreachable<.CustomTypeHandle> }
                } @struct-handle

                $ctx.program $struct-handle lookup-custom-type match {
                    case Variant -> { drop Core:unreachable<.Struct> }
                    case Struct -> {}
                } @struc

                &ctx.program.sizes $struc $field.field-index field-offset @field-offset

                $offset $field-offset + #offset
                $i 1 + #i

                $ctx.program $field.target-type lookup-type match {
                    case Custom -> { drop }
                    case _ -> { drop break }
                }
            }
            $arena &loads $offset Array:push<i32>
        }
    }
}

fn generate-store(ctx: .Ctx, type: TypeId) { block {
    &ctx.program.sizes $type can-live-in-reg not if {
        $ctx.fmt "i32.const " Fmt:write
        $ctx.fmt &ctx.program.sizes $type type-size i32-format
        $ctx.fmt " memory.copy" Fmt:write
        break
    }
    $ctx.fmt $ctx.program $type lookup-type match {
        case I64 -> { "i64.store" }
        case _ -> { drop "i32.store" }
    } Fmt:write
} }

fn generate-var-ident(ctx: .Ctx, locals: .Map<LocalId, Local>, var-id: .VarId) {
    $ctx $var-id match {
        case Local -> {
            $locals flip generate-local-ident-by-id
        }
        case Global -> {
            @global-id
            .fmt ~ "$" Fmt:write
            $ctx.program $global-id lookup-globl @globl
            $ctx.fmt &globl.name Token-lexeme Fmt:write
            $ctx.fmt ":" Fmt:write
            $ctx.fmt $global-id.module.index i32-format
        }
    }
}

fn generate-local-ident-by-id(ctx: .Ctx, locals: .Map<LocalId, Local>, local-id: .LocalId) {
    $ctx.fmt 
    $locals $local-id Map:get<LocalId, Local> Maybe:assert-some<.Local>
    $local-id generate-local-ident
}

fn generate-local-ident(fmt: .Formatter, local: .Local, local-id: .LocalId) {
    $fmt "$" Fmt:write
    $fmt &local.name Token-lexeme Fmt:write
    $local-id.scope 0 /= $local-id.shadow 0 /= or if {
        $fmt ":" Fmt:write
        $fmt $local-id.scope i32-format
        $fmt ":" Fmt:write
        $fmt $local-id.shadow i32-format
    }
}

fn generate-intrinsic(ctx: .Ctx, intrinsic: .Intrinsic) { block () -> {
    $ctx.fmt $intrinsic match {
        case Add -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.add" }
            case _ -> { drop "i32.add" }
        } }
        case Sub -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.sub" }
            case _ -> { drop "i32.sub" }
        } }
        case Eq -> {
            ~ @type
            $ctx.program $type lookup-type match {
                case I64 -> { "i64.eq" }
                case _ -> {
                    0 &ctx.program.sizes $type can-live-in-reg !i32 / drop // assert
                    drop "i32.eq"
                }
            }
        }
        case NotEq -> {
            ~ @type
            $ctx.program $type lookup-type match {
                case I64 -> { "i64.ne" }
                case _ -> {
                    0 &ctx.program.sizes $type can-live-in-reg !i32 / drop // assert
                    drop "i32.ne"
                }
            }
        }
        case Mod -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.rem_u" }
            case I64 -> { "i64.rem_u" }
            case _ -> { !.i32 0 0 / }
        } }
        case Mul -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.mul" }
            case I64 -> { "i64.mul" }
            case _ -> { !.i32 0 0 / }
        } }
        case Div -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.div_u" }
            case I64 -> { "i64.div_u" }
            case _ -> { !.i32 0 0 / }
        } }
        case Lt -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.lt_u" }
            case I64 -> { "i64.lt_u" }
            case _ -> { !.i32 0 0 / }
        } }
        case Gt -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.gt_u" }
            case I64 -> { "i64.gt_u" }
            case _ -> { !.i32 0 0 / }
        } }
        case Le -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.le_u" }
            case I64 -> { "i64.le_u" }
            case _ -> { !.i32 0 0 / }
        } }
        case Ge -> { $ctx.program flip ~ lookup-type match {
            case I32 -> { "i32.ge_u" }
            case I64 -> { "i64.ge_u" }
            case _ -> { !.i32 0 0 / }
        } }
        case And -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.and" }
            case I32 -> { "i32.and" }
            case Bool -> { "i32.and" }
            case _ -> { !.i32 0 0 / }
        } }
        case Or -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.or" }
            case I32 -> { "i32.or" }
            case Bool -> { "i32.or" }
            case _ -> { !.i32 0 0 / }
        } }
        case Not -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.const -1 i64.xor" }
            case I32 -> { "i32.const -1 i32.xor" }
            case Bool -> { "i32.const 1 i32.and i32.const 1 i32.xor i32.const 1 i32.and" }
            case _ -> { !.i32 0 0 / }
        } }
        case Load8 -> { "i32.load8_u" }
        case Store8 -> { "i32.store8" }
        case Rotl -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.extend_i32_s i64.rotl" }
            case _ -> { drop "i32.rotl" }
        } }
        case Rotr -> { $ctx.program flip ~ lookup-type match {
            case I64 -> { "i64.extend_i32_s i64.rotr" }
            case _ -> { drop "i32.rotr" }
        } }
        case MemCopy -> { "memory.copy" }
        case MemFill -> { "memory.fill" }
        case MemGrow -> { "memory.grow" }
        case Store -> { $ctx flip ~ generate-store break }
        case SetStackSize -> { "drop" } // TODO: support stack guards
        case _ -> { drop "TODO" }
    } Fmt:write
} }

fn generate-signature(ctx: .Ctx, signature: .Signature, export: .Maybe<Token>, module: i32, name: .Token, instance: i32) {
    $ctx.fmt "func $" Fmt:write
    $ctx.fmt $module i32-format
    $ctx.fmt ":" Fmt:write
    $ctx.fmt $name Token-lexeme Fmt:write
    $instance 0 /= if {
        $ctx.fmt ":" Fmt:write
        $ctx.fmt $instance i32-format
    }
    $export match {
        case None -> {}
        case Some -> {
            $ctx.fmt " (export " Fmt:write
            $ctx.fmt flip Token-lexeme Fmt:write
            $ctx.fmt ")" Fmt:write
        }
    }
    $ctx &signature.parameters generate-parameters
    $ctx &signature.returns    generate-returns
}

fn generate-parameters(ctx: .Ctx, parameters: .Array<NamedTypeId>) {
    0 @i
    loop {
        $i $parameters.len = if { break }
        $parameters $i Array:get<NamedTypeId> @parameter
        $ctx.fmt " (param $" Fmt:write
        $ctx.fmt &parameter.name Token-lexeme Fmt:write
        $ctx.fmt " " Fmt:write
        $ctx $parameter.type generate-type
        $ctx.fmt ")" Fmt:write
        $i 1 + #i
    }
}

fn generate-parameters-unnamed(ctx: .Ctx, parameters: .Array<TypeId>) {
    0 @i
    loop {
        $i $parameters.len = if { break }
        $parameters $i Array:get<TypeId> ~ @parameter
        $ctx.fmt " (param " Fmt:write
        $ctx $parameter generate-type
        $ctx.fmt ")" Fmt:write
        $i 1 + #i
    }
}

fn generate-returns(ctx: .Ctx, returns: .Array<TypeId>) {
    0 @i
    loop {
        $i $returns.len = if { break }
        $ctx.fmt " (result " Fmt:write
        $ctx $returns $i Array:get<TypeId> ~ generate-type
        $ctx.fmt ")" Fmt:write
        $i 1 + #i
    }
}

fn generate-type(ctx: .Ctx, type: TypeId) { block {
    &ctx.program.sizes $type type-size @size
    $ctx.program $type lookup-type match {
        // TODO: this case is redundant once i64 structs are supported
        case I64 -> { $ctx.fmt "i64" Fmt:write break }
        case _ -> { drop }
    }
    $ctx.fmt $size 4 gt $size 8 le and if {
        // "i64" TODO: support this everywhere else
        "i32"
    } else {
        "i32"
    } Fmt:write
} }

fn generate-type-pretty(ctx: .Ctx, type: TypeId) { block {
    $ctx.fmt $ctx.program $type lookup-type match {
        case I32 -> { "i32" }
        case I64 -> { "i64" }
        case Bool -> { "bool" }
        case Ptr -> { $ctx.fmt "." Fmt:write $ctx flip ~ generate-type-pretty drop break }
        case Tuple -> {
            @items
            "[" Fmt:write
            0 @i
            loop {
                $i $items.len = if { break }
                $ctx $items $i Array:get<TypeId> ~ generate-type-pretty
                $i 1 + #i
                $items.len $i /= if {
                    $ctx.fmt ", " Fmt:write
                }
            }
            $ctx.fmt "]" Fmt:write
            break
        }
        case Fun -> {
            @type
            "(" Fmt:write
            0 @i
            loop {
                $i $type.parameters.len = if { break }
                $ctx &type.parameters $i Array:get<TypeId> ~ generate-type-pretty
                $i 1 + #i
                $i $type.parameters.len /= if {
                    $ctx.fmt ", " Fmt:write
                } else {
                    $ctx.fmt " " Fmt:write
                }
            }
            $ctx.fmt "->" Fmt:write
            0 @i
            loop {
                $i $type.returns.len = if { break }
                $i 0 = if {
                    $ctx.fmt " " Fmt:write
                } else {
                    $i 1 + $type.returns.len /= if {
                        $ctx.fmt ", " Fmt:write
                    }
                }
                $ctx &type.returns $i Array:get<TypeId> ~ generate-type-pretty
                $i 1 + #i
            }
            $ctx.fmt ")" Fmt:write
            break
        }
        case Custom -> {
            $ctx.program flip lookup-custom-type CustomType-name Token-lexeme
        }
    } Fmt:write
} }

