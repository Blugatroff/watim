import "../std/maybe.watim" as Maybe (Maybe)
import "../std/array.watim" as Array (Array)
import "../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../std/util.watim" as Util (i32-format)
import "../std/fmt.watim" as Fmt (Formatter)
import "../std/io.watim" as IO

import "./lexer.watim" as Lexer (Token, Token-format, Token-lexeme)
import "./parser.watim" as P

struct ModuleId { index: i32 }

struct NamedType {
    name: Token
    type: Type
}
fn NamedType-format(fmt: .Formatter, self: .NamedType) {
    $fmt "(NamedType " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}
fn NamedType-type(self: .NamedType) -> Type { $self.type }

struct Struct {
    name: Token
    generic-parameters: Array<Token>
    fields: Array<NamedType>
}
fn Struct-format(fmt: .Formatter, self: .Struct) {
    $fmt "(Struct\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "generic-parameters=" Fmt:write
    $fmt \Token-format &self.generic-parameters Array:format<Token>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "fields=" Fmt:write
    $fmt \NamedType-format &self.fields Array:format-multi-line<NamedType>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

struct VariantCase {
    name: Token
    type: Maybe<Type>
}
fn VariantCase-format(fmt: .Formatter, self: .VariantCase) {
    $fmt "(VariantCase " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt \Type-format &self.type Maybe:format<Type>
    $fmt ")" Fmt:write
}
fn VariantCase-name(self: .VariantCase) -> ByteSlice {
    &self.name Token-lexeme make ByteSlice
}

struct Variant {
    name: Token
    generic-parameters: Array<Token>
    cases: Array<VariantCase>
}
fn Variant-format(fmt: .Formatter, self: .Variant) {
    $fmt "(Variant\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "generic-parameters=" Fmt:write
    $fmt \Token-format &self.generic-parameters Array:format<Token>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "cases=" Fmt:write
    $fmt \VariantCase-format &self.cases Array:format-multi-line<VariantCase>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

variant CustomType {
    case Struct -> Struct
    case Variant -> Variant
}
fn CustomType-format(fmt: .Formatter, self: .CustomType) {
    $fmt $self match {
        case Struct -> { Struct-format }
        case Variant -> { Variant-format }
    }
}

struct TypeLookup {
    module-id: ModuleId
    types: .Array<CustomType>
    other-modules: .Array<.Array<CustomType>>
}
fn lookup-type(lookup: .TypeLookup, handle: CustomTypeHandle) -> .CustomType {
    $handle.module $lookup.module-id = if {
        $lookup.types $handle.index Array:get<CustomType>
    } else {
        $lookup.other-modules $handle.module.index Array:get<.Array<CustomType>> ~ $handle.index Array:get<CustomType>
    }
}

variant Type {
    case Bool
    case I32
    case I64
    case Ptr -> .Type
    case Custom -> CustomTypeType
    case Fun -> FunType
    case Tuple -> TupleType
    case Generic -> P:GenericType
}
fn Type-format(fmt: .Formatter, self: .Type) { block {
    $fmt $self match {
        case Bool -> { "Bool" }
        case I32 -> { "I32" }
        case I64 -> { "I64" }
        case Ptr -> {
            $fmt "(Ptr " Fmt:write
            ~ Type-format
            $fmt ")" Fmt:write
            break
        }
        case Custom -> { CustomTypeType-format break }
        case Fun -> { FunType-format break }
        case Tuple -> { TupleType-format break }
        case Generic -> { P:GenericType-format break }
    } Fmt:write
} }
fn Types-format(fmt: .Formatter, self: .Array<Type>) {
    $fmt \Type-format $self Array:format<Type>
}
fn Type-pretty(fmt: .Formatter, lookup: .TypeLookup, self: .Type) { block {
    $fmt $self match {
        case Bool -> { "bool" }
        case I32 -> { "i32" }
        case I64 -> { "i64" }
        case Ptr -> { $fmt "." Fmt:write ~ $lookup flip Type-pretty break }
        case Custom -> { $lookup flip CustomTypeType-pretty break }
        case Fun -> { $lookup flip FunType-pretty break }
        case Tuple -> { $lookup flip TupleType-pretty break }
        case Generic -> { P:GenericType-pretty break }
    } Fmt:write
} }
fn Type-eq(a: .Type, b: .Type) -> bool {
    $a match {
        case Bool -> { $b match { case Bool -> { 1 1 = } case _ -> { drop 0 1 = } } }
        case I32 -> { $b match { case I32 -> { 1 1 = } case _ -> { drop 0 1 = } } }
        case I64 -> { $b match { case I64 -> { 1 1 = } case _ -> { drop 0 1 = } } }
        case Ptr -> {
            ~ $b match {
                case Ptr -> { ~ Type-eq }
                case _ -> { drop drop 0 1 = }
            }
        }
        case Custom -> {
            $b match {
                case Custom -> { CustomTypeType-eq }
                case _ -> { drop drop 0 1 = }
            }
        }
        case Fun -> {
            $b match {
                case Fun -> { FunType-eq }
                case _ -> { drop drop 0 1 = }
            }
        }
        case Tuple -> {
            $b match {
                case Tuple -> { TupleType-eq }
                case _ -> { drop drop 0 1 = }
            }
        }
        case Generic -> {
            .index ~ $b match {
                case Generic -> { .index ~ = }
                case _ -> { drop drop 0 1 = }
            }
        }
    }
}

fn Types-eq(a: .Array<Type>, b: .Array<Type>) -> bool {
    \Type-eq $a $b Array:eq<Type>
}
fn Types-pretty(fmt: .Formatter, lookup: .TypeLookup, self: .Array<Type>) {
    0 @i
    loop {
        $i $self.len = if { break }
        $fmt $lookup $self $i Array:get<Type> Type-pretty
        $i 1 + #i
        $i $self.len = if { break }
        $fmt ", " Fmt:write
    }
}
fn Types-pretty-bracketed(fmt: .Formatter, lookup: .TypeLookup, self: .Array<Type>) {
    $fmt "[" Fmt:write
    $fmt $lookup $self Types-pretty
    $fmt "]" Fmt:write
}

struct FunType {
    token: Token
    parameters: Array<Type>
    returns: Array<Type>
}
fn FunType-format(fmt: .Formatter, self: .FunType) {
    $fmt "(FunType " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \Type-format &self.parameters Array:format<Type>
    $fmt " " Fmt:write
    $fmt \Type-format &self.returns Array:format<Type>
    $fmt ")" Fmt:write
}
fn FunType-pretty(fmt: .Formatter, lookup: .TypeLookup, self: .FunType) {
    $fmt "(" Fmt:write
    $fmt $lookup &self.parameters Types-pretty
    $fmt " -> " Fmt:write
    $fmt $lookup &self.returns Types-pretty
    $fmt ")" Fmt:write
}
fn FunType-eq(a: .FunType, b: .FunType) -> bool {
    \Type-eq &a.parameters &b.parameters Array:eq<Type> if {
        \Type-eq &a.returns &b.returns Array:eq<Type>
    } else {
        0 1 =
    }
}

struct TupleType {
    token: Token
    items: Array<Type>
}
fn TupleType-format(fmt: .Formatter, self: .TupleType) {
    $fmt "(TupleType " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \Type-format &self.items Array:format<Type>
    $fmt ")" Fmt:write
}
fn TupleType-pretty(fmt: .Formatter, thr: .TypeLookup, self: .TupleType) {
    $fmt "[" Fmt:write
    0 @i
    loop {
        $i $self.items.len = if { break }
        $fmt $thr &self.items $i Array:get<Type> Type-pretty
        $i 1 + #i
        $i $self.items.len = if { break }
        $fmt ", " Fmt:write
    }
    $fmt "]" Fmt:write
}
fn TupleType-eq(a: .TupleType, b: .TupleType) -> bool {
    \Type-eq &a.items &b.items Array:eq<Type>
}

struct CustomTypeType {
    type-definition: CustomTypeHandle
    generic-arguments: Array<Type>
}
fn CustomTypeType-format(fmt: .Formatter, self: .CustomTypeType) {
    $fmt "(CustomType " Fmt:write
    $fmt $self.type-definition.module.index i32-format
    $fmt " " Fmt:write
    $fmt $self.type-definition.index i32-format
    $fmt " " Fmt:write
    $fmt \Type-format &self.generic-arguments Array:format<Type>
    $fmt ")" Fmt:write
}
fn CustomTypeType-pretty(fmt: .Formatter, thr: .TypeLookup, self: .CustomTypeType) {
    $fmt $thr $self.type-definition lookup-type match {
        case Struct  -> { .name }
        case Variant -> { .name }
    } Token-lexeme Fmt:write
}
fn CustomTypeType-eq(a: .CustomTypeType, b: .CustomTypeType) -> bool {
    &a.type-definition &b.type-definition CustomTypeHandle-eq if {
        \Type-eq &a.generic-arguments &b.generic-arguments Array:eq<Type>
    } else {
        0 1 =
    }
}

struct CustomTypeHandle { module: ModuleId index: i32 }
fn CustomTypeHandle-format(fmt: .Formatter, self: .CustomTypeHandle) {
    $fmt "(CustomTypeHandle " Fmt:write
    $fmt $self.module.index i32-format
    $fmt " " Fmt:write
    $fmt $self.index i32-format
    $fmt ")" Fmt:write
}
fn CustomTypeHandle-eq(a: .CustomTypeHandle, b: .CustomTypeHandle) -> bool {
    $a.module.index $b.module.index = $a.index $b.index = and
}

