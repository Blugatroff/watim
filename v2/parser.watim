import "../std/core.watim" as CORE
import "../std/io.watim" as IO
import "../std/array.watim" as Array
import "../std/arena.watim" as A
import "../std/byte-slice.watim" as ByteSlice
import "../std/byte-array.watim" as ByteArray
import "../std/optional.watim" as Optional

import "./lexer.watim" as L

struct ParsedFunction {
    name: L:Token
    export-name: Optional:T<L:Token>
    generic-parameters: Array:Array<L:Token>
    parameters: Array:Array<ParsedNamedType>
    returns: Array:Array<ParsedType>
    locals: Array:Array<ParsedNamedType>
    words: ParsedWords
}
fn ParsedFunction-new(export-name: Optional:T<L:Token>, name: L:Token, generic-parameters: Array:Array<L:Token>, parameters: Array:Array<ParsedNamedType>, returns: Array:Array<ParsedType>, locals: Array:Array<ParsedNamedType>, words: ParsedWords) -> ParsedFunction {
    local self: ParsedFunction
    $export-name #self.export-name
    $name #self.name
    $generic-parameters #self.generic-parameters
    $parameters #self.parameters
    $returns #self.returns
    $locals #self.locals
    $words #self.words
    $self
}
fn ParsedFunction-write(fd: i32, self: .ParsedFunction) -> i32 { block {
    $fd "{ \"name\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd &self.name L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"export\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $self.export-name.present if {
        $fd &self.export-name.value L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
    } else {
        $fd "null" IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    }
    $fd ", \"generic-parameters\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd \L:Token-write &self.generic-parameters Array:print<L:Token> CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"parameters\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd \ParsedNamedType-write &self.parameters Array:print<ParsedNamedType> CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"returns\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd \ParsedType-write &self.returns Array:print<ParsedType> CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"locals\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd \ParsedNamedType-write &self.locals Array:print<ParsedNamedType> CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"words\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd &self.words ParsedWords-write CORE:dup<i32> 0 /= if { break } else { drop }
    $fd " }" IO:write-all
} }

struct ParsedExternFunction {
    external-module: L:Token
    external-name: L:Token
    name: L:Token
    parameters: Array:Array<ParsedNamedType>
    returns: Array:Array<ParsedType>
}
fn ParsedExternFunction-new(external-module: L:Token, external-name: L:Token, name: L:Token, parameters: Array:Array<ParsedNamedType>, returns: Array:Array<ParsedType>) -> ParsedExternFunction {
    local self: ParsedExternFunction
    $external-module #self.external-module
    $external-name #self.external-name
    $name #self.name
    $parameters #self.parameters
    $returns #self.returns
    $self
}
fn ParsedExternFunction-write(fd: i32, self: .ParsedExternFunction) -> i32 { block {
    $fd "{ \"external-module\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd &self.external-module L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"external-name\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd &self.external-name L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"name\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd &self.name L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"parameters\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd \ParsedNamedType-write &self.parameters Array:print<ParsedNamedType> CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"returns\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd \ParsedType-write &self.returns Array:print<ParsedType> CORE:dup<i32> 0 /= if { break } else { drop }
    $fd " }" IO:write-all
} }

struct ParsedNamedType {
    name: L:Token
    type: ParsedType
}
fn ParsedNamedType-new(name: L:Token, type: ParsedType) -> ParsedNamedType {
    local self: ParsedNamedType
    $name #self.name
    $type #self.type
    $self
}
fn ParsedNamedType-write(fd: i32, self: .ParsedNamedType) -> i32 { block {
    $fd "{ \"name\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd &self.name L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"type\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd &self.type ParsedType-write CORE:dup<i32> 0 /= if { break } else { drop }
    $fd " }" IO:write-all
} }

struct ParsedImport {
    path: L:Token
    qualifier: L:Token
}
fn ParsedImport-new(path: L:Token, qualifier: L:Token) -> ParsedImport {
    local self: ParsedImport
    $path #self.path
    $qualifier #self.qualifier
    $self
}
fn ParsedImport-write(fd: i32, self: .ParsedImport) -> i32 { block {
    $fd "{ \"path\": " IO:write-all @code $code 0 /= if { $code break }
    $fd &self.path L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"qualifier\": " IO:write-all #code $code 0 /= if { $code break }
    $fd &self.qualifier L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
    $fd " }" IO:write-all
} }

struct ParsedStruct {
    name: L:Token
    fields: Array:Array<ParsedNamedType>
}
fn ParsedStruct-new(name: L:Token, fields: Array:Array<ParsedNamedType>) -> ParsedStruct {
    local self: ParsedStruct
    $name #self.name
    $fields #self.fields
    $self
}
fn ParsedStruct-write(fd: i32, self: .ParsedStruct) -> i32 { block {
    $fd "{ \"name\": " IO:write-all @code $code 0 /= if { $code break }
    $fd &self.name L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"fields\": " IO:write-all #code $code 0 /= if { $code break }
    $fd \ParsedNamedType-write &self.fields Array:print<ParsedNamedType> CORE:dup<i32> 0 /= if { break } else { drop }
    $fd " }" IO:write-all
} }

struct ParsedModule {
    file-path: ByteSlice:T
    types: ParsedTypes
    imports: Array:Array<ParsedImport>
    structs: Array:Array<ParsedStruct>
    functions: Array:Array<ParsedFunction>
}
fn ParsedModule-new(
    file-path: ByteSlice:T,
    types: ParsedTypes,
    imports: Array:Array<ParsedImport>,
    structs: Array:Array<ParsedStruct>,
    functions: Array:Array<ParsedFunction>
) -> ParsedModule {
    local self: ParsedModule
    $file-path #self.file-path
    $types #self.types
    $imports #self.imports
    $structs #self.structs
    $functions #self.functions
    $self
}
fn ParsedModule-write(fd: i32, self: .ParsedModule) -> i32 { block {
    $fd "{ \"file-path\": \"" IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd $self.file-path ByteSlice:unpack IO:write-escaped CORE:dup<i32> 0 /= if { break } else { drop }
    $fd "\", \"types\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd &self.types ParsedTypes-write CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"imports\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd \ParsedImport-write &self.imports Array:print<ParsedImport> CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"structs\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd \ParsedStruct-write &self.structs Array:print<ParsedStruct> CORE:dup<i32> 0 /= if { break } else { drop }
    $fd ", \"functions\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    $fd \ParsedFunction-write &self.functions Array:print<ParsedFunction> CORE:dup<i32> 0 /= if { break } else { drop }
    $fd " }" IO:write-all
} }

fn TYPE_I32() -> i32 { 1 }
fn TYPE_BOOL() -> i32 { 2 }
fn TYPE_PTR() -> i32 { 3 }
fn TYPE_STRUCT() -> i32 { 4 }
fn TYPE_I64() -> i32 { 1 }
fn TypeTy-name(ty: i32) -> .i32, i32 { block {
    $ty TYPE_I32 = if { "TYPE_I32" break }
    $ty TYPE_BOOL = if { "TYPE_BOOL" break }
    $ty TYPE_PTR = if { "TYPE_PTR" break }
    $ty TYPE_STRUCT = if { "TYPE_STRUCT" break }
    $ty TYPE_I64 = if { "TYPE_I64" break }
    "" 0 0 / drop
} }

struct ParsedTypes {
    buf: ByteArray:T
}
fn ParsedTypes-new() -> ParsedTypes {
    local self: ParsedTypes
    ByteArray:new #self.buf
    $self
}
fn ParsedTypes-push-ty(arena: .A:Arena, self: .ParsedTypes, ty: i32) -> ParsedType {
    local type: ParsedType
    $self.buf.len #type.index
    $arena &self.buf $ty ByteArray:push-i32
    $type
}
fn ParsedTypes-push-i32(arena: .A:Arena, self: .ParsedTypes) -> ParsedType {
    $arena $self TYPE_I32 ParsedTypes-push-ty
}
fn ParsedTypes-push-i64(arena: .A:Arena, self: .ParsedTypes) -> ParsedType {
    $arena $self TYPE_I64 ParsedTypes-push-ty
}
fn ParsedTypes-push-bool(arena: .A:Arena, self: .ParsedTypes) -> ParsedType {
    $arena $self TYPE_BOOL ParsedTypes-push-ty
}
fn ParsedTypes-push-ptr(arena: .A:Arena, self: .ParsedTypes) -> ParsedType {
    $arena $self TYPE_PTR ParsedTypes-push-ty
}
fn ParsedTypes-push-struc(arena: .A:Arena, self: .ParsedTypes, name: L:Token) -> ParsedType, i32 {
    $arena $self TYPE_STRUCT ParsedTypes-push-ty
    $arena &self.buf 0 1 = !i32 ByteArray:push-i32 // foreign = false
    $arena &self.buf &name !.i32 sizeof(L:Token) ByteArray:push
    $self.buf.len $arena &self.buf sizeof(i32) ByteArray:alloc-bytes drop
}
fn ParsedTypes-push-foreign-struc(arena: .A:Arena, self: .ParsedTypes, module: L:Token, name: L:Token) -> ParsedType, i32 {
    $arena $self TYPE_STRUCT ParsedTypes-push-ty
    $arena &self.buf 1 1 = !i32 ByteArray:push-i32 // foreign = true
    $arena &self.buf &module !.i32 sizeof(L:Token) ByteArray:push
    $arena &self.buf &name !.i32 sizeof(L:Token) ByteArray:push
    $self.buf.len $arena &self.buf sizeof(i32) ByteArray:alloc-bytes drop
}
fn ParsedTypes-write(fd: i32, self: .ParsedTypes) -> i32 { block {
    $self.buf.len 4 % 0 /= if { 0 0 / drop }
    $fd "[" IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
    0 @cursor
    loop {
        $cursor $self.buf.len = if { 0 break }
        $fd $self $cursor ParsedTypes-write-type @err #cursor $err 0 /= if { $err break }
        $cursor $self.buf.len /= if {
            $fd ", " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
        }
    } CORE:dup<i32> 0 /= if { break } else { drop }
    $fd " ]" IO:write-all
} }
fn ParsedTypes-write-type(fd: i32, types: .ParsedTypes, index: i32) -> i32, i32 {
    block {
        $types.buf.ptr $index + ~ @ty
        $index sizeof(i32) + #index // skip `ty`
        $fd "{ \"ty\": \"" IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
        $fd $ty TypeTy-name IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
        $fd "\"" IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
        block {
            $ty TYPE_I32 = $ty TYPE_BOOL = or if { 0 break }
            $ty TYPE_PTR = if {
                $fd ", \"child\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $fd $types $index ParsedTypes-write-type flip #index break
            }
            $ty TYPE_STRUCT = if {
                $types.buf.ptr $index + !.bool ~
                $index sizeof(i32) + #index // skip `foreign`
                if {
                    $fd ", \"module\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                    $fd $types.buf.ptr $index + !.L:Token L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
                    $index sizeof(L:Token) + #index // skip `module`
                }
                $fd ", \"name\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $fd $types.buf.ptr $index + !.L:Token L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
                $index sizeof(L:Token) + #index // skip `name`

                $types.buf.ptr $index + ~ @generic-arguments-count
                $index sizeof(i32) + #index // skip `generic-arguments-count`
                $fd ", \"generic-arguments\": [" IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                loop {
                    $generic-arguments-count 0 = if { 0 break }
                    $fd $types $index ParsedTypes-write-type @err #index $err 0 /= if { $err break }
                    $generic-arguments-count 1 - #generic-arguments-count
                    $generic-arguments-count 0 = if { 0 break }
                    $fd ", " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                } CORE:dup<i32> 0 /= if { break } else { drop }
                $fd "]" IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                0 break
            }
            CORE:unreachable<i32>
        } CORE:dup<i32> 0 /= if { break } else { drop }
        $fd " }" IO:write-all
    } $index flip
}

struct ParsedType {
    index: i32
}
fn ParsedType-write(fd: i32, self: .ParsedType) -> i32 {
    $fd $self.index IO:print
}

fn WORD_NUMBER() -> i32 { 1 }
fn WORD_STRING() -> i32 { 2 }
fn WORD_GET() -> i32 { 3 }
fn WORD_CALL() -> i32 { 4 }
fn WORD_INIT() -> i32 { 5 }
fn WORD_REF() -> i32 { 6 }
fn WORD_IF() -> i32 { 7 }
fn WORD_LOAD() -> i32 { 8 }
fn WORD_FUN_REF() -> i32 { 9 }
fn WORD_SET() -> i32 { 10 }
fn WORD_BLOCK() -> i32 { 11 }
fn WORD_BREAK() -> i32 { 12 }
fn WORD_CAST() -> i32 { 13 }
fn WORD_SIZEOF() -> i32 { 14 }
fn WORD_LOOP() -> i32 { 15 }
fn WORD_GET_FIELD() -> i32 { 16 }
fn WORD_STORE() -> i32 { 17 }
fn WordTy-name(ty: i32) -> .i32, i32 { block {
    $ty WORD_NUMBER = if { "WORD_NUMBER" break }
    $ty WORD_STRING = if { "WORD_STRING" break }
    $ty WORD_GET = if { "WORD_GET" break }
    $ty WORD_CALL = if { "WORD_CALL" break }
    $ty WORD_INIT = if { "WORD_INIT" break }
    $ty WORD_REF = if { "WORD_REF" break }
    $ty WORD_IF = if { "WORD_IF" break }
    $ty WORD_LOAD = if { "WORD_LOAD" break }
    $ty WORD_FUN_REF = if { "WORD_FUN_REF" break }
    $ty WORD_SET = if { "WORD_SET" break }
    $ty WORD_BLOCK = if { "WORD_BLOCK" break }
    $ty WORD_BREAK = if { "WORD_BREAK" break }
    $ty WORD_CAST = if { "WORD_CAST" break }
    $ty WORD_SIZEOF = if { "WORD_SIZEOF" break }
    $ty WORD_LOOP = if { "WORD_LOOP" break }
    $ty WORD_GET_FIELD = if { "WORD_GET_FIELD" break }
    $ty WORD_STORE = if { "WORD_STORE" break }
    "" 0 0 / drop
} }
struct ParsedWords {
    buf: ByteArray:T
}
fn ParsedWords-new() -> ParsedWords {
    local self: ParsedWords
    ByteArray:new #self.buf
    $self
}
fn ParsedWords-push-ty(arena: .A:Arena, self: .ParsedWords, ty: i32) -> ParsedWord {
    local word: ParsedWord
    $self.buf.len #word.index
    $arena &self.buf $ty ByteArray:push-i32
    $word
}
fn ParsedWords-push-token(arena: .A:Arena, self: .ParsedWords, token: L:Token) {
    $arena &self.buf &token !.i32 sizeof(L:Token) ByteArray:push
}
fn ParsedWords-push-number(arena: .A:Arena, self: .ParsedWords, value: L:Token) -> ParsedWord {
    $arena $self WORD_NUMBER ParsedWords-push-ty
    $arena $self $value ParsedWords-push-token
}
fn ParsedWords-push-string(arena: .A:Arena, self: .ParsedWords, value: L:Token) -> ParsedWord {
    $arena $self WORD_NUMBER ParsedWords-push-ty
    $arena $self $value ParsedWords-push-token
}
fn ParsedWords-push-patch(arena: .A:Arena, self: .ParsedWords) -> i32 {
    $self.buf.len $arena &self.buf sizeof(i32) ByteArray:alloc-bytes drop
}
fn ParsedWords-push-get(arena: .A:Arena, self: .ParsedWords, name: L:Token) -> ParsedWord, i32 {
    $arena $self WORD_GET ParsedWords-push-ty
    $arena $self $name ParsedWords-push-token
    $arena $self ParsedWords-push-patch
}
fn ParsedWords-push-ref(arena: .A:Arena, self: .ParsedWords, name: L:Token) -> ParsedWord, i32 {
    $arena $self WORD_REF ParsedWords-push-ty
    $arena $self $name ParsedWords-push-token
    $arena $self ParsedWords-push-patch
}
fn ParsedWords-push-set(arena: .A:Arena, self: .ParsedWords, name: L:Token) -> ParsedWord, i32 {
    $arena $self WORD_SET ParsedWords-push-ty
    $arena $self $name ParsedWords-push-token
    $arena $self ParsedWords-push-patch
}
fn ParsedWords-push-store(arena: .A:Arena, self: .ParsedWords, name: L:Token) -> ParsedWord, i32 {
    $arena $self WORD_STORE ParsedWords-push-ty
    $arena $self $name ParsedWords-push-token
    $arena $self ParsedWords-push-patch
}
fn ParsedWords-push-init(arena: .A:Arena, self: .ParsedWords, name: L:Token) -> ParsedWord {
    $arena $self WORD_INIT ParsedWords-push-ty
    $arena $self $name ParsedWords-push-token
}
fn ParsedWords-push-call(arena: .A:Arena, self: .ParsedWords, name: L:Token, generic-arguments: Array:Array<ParsedType>) -> ParsedWord {
    $arena $self WORD_CALL ParsedWords-push-ty
    $arena $self $name ParsedWords-push-token
    $arena &self.buf 0 1 = !i32 ByteArray:push-i32
    $arena &self.buf $generic-arguments.len ByteArray:push-i32
    $arena &self.buf $generic-arguments.ptr !.i32 $generic-arguments.len sizeof(ParsedType) * ByteArray:push
}
fn ParsedWords-push-foreign-call(arena: .A:Arena, self: .ParsedWords, name: L:Token, module: L:Token, generic-arguments: Array:Array<ParsedType>) -> ParsedWord {
    $arena $self WORD_CALL ParsedWords-push-ty
    $arena $self $name ParsedWords-push-token
    $arena &self.buf 1 1 = !i32 ByteArray:push-i32
    $arena $self $module ParsedWords-push-token
    $arena &self.buf $generic-arguments.len ByteArray:push-i32
    $arena &self.buf $generic-arguments.ptr !.i32 $generic-arguments.len sizeof(ParsedType) * ByteArray:push
}
fn ParsedWords-push-load(arena: .A:Arena, self: .ParsedWords, token: L:Token) -> ParsedWord {
    $arena $self WORD_LOAD ParsedWords-push-ty
    $arena $self $token ParsedWords-push-token
}
fn ParsedWords-push-break(arena: .A:Arena, self: .ParsedWords, token: L:Token) -> ParsedWord {
    $arena $self WORD_BREAK ParsedWords-push-ty
    $arena $self $token ParsedWords-push-token
}
fn ParsedWords-push-cast(arena: .A:Arena, self: .ParsedWords, token: L:Token, type: ParsedType) -> ParsedWord {
    $arena $self WORD_CAST ParsedWords-push-ty
    $arena $self $token ParsedWords-push-token
    $arena &self.buf &type !.i32 sizeof(ParsedType) ByteArray:push
}
fn ParsedWords-push-sizeof(arena: .A:Arena, self: .ParsedWords, token: L:Token, type: ParsedType) -> ParsedWord {
    $arena $self WORD_SIZEOF ParsedWords-push-ty
    $arena $self $token ParsedWords-push-token
    $arena &self.buf &type !.i32 sizeof(ParsedType) ByteArray:push
}
fn ParsedWords-push-get-field(arena: .A:Arena, self: .ParsedWords, token: L:Token) -> ParsedWord, i32 {
    $arena $self WORD_GET_FIELD ParsedWords-push-ty
    $arena $self $token ParsedWords-push-token
    $arena $self ParsedWords-push-patch
}
fn ParsedWords-write(fd: i32, self: .ParsedWords) -> i32 {
    $fd $self 0 0 not ParsedWords-write-n-from flip drop
}
fn ParsedWords-write-n-from(fd: i32, self: .ParsedWords, cursor: i32, n: i32) -> i32, i32 { block {
    $self.buf.len 4 % 0 /= if { 0 0 / drop }
    $fd "[" IO:write-all CORE:dup<i32> 0 /= if { $cursor break } else { drop }
    loop {
        $cursor $self.buf.len ge if { 0 break }
        $n 0 = if { 0 break }
        $fd $self $cursor ParsedWords-write-word @err #cursor $err 0 /= if { $err break }
        $cursor $self.buf.len /= if {
            $fd ", " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
        }
        $n 1 - #n
    } CORE:dup<i32> 0 /= if { $cursor break } else { drop }
    $cursor
    $fd " ]" IO:write-all
} }
fn ParsedWords-write-word(fd: i32, words: .ParsedWords, index: i32) -> i32, i32 {
    block {
        $words.buf.ptr $index + ~ @ty
        $index sizeof(i32) + #index // skip `ty`
        $fd "{ \"ty\": \"" IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
        $fd $ty WordTy-name IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
        $fd "\"" IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
        block {
            $ty WORD_NUMBER = if {
                $words.buf.ptr $index + !.L:Token @value
                $index sizeof(L:Token) + #index // skip `value`
                $fd ", \"value\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $fd $value L:Token-write break
            }
            $ty WORD_GET =
            $ty WORD_REF = or
            $ty WORD_SET = or
            $ty WORD_STORE = or
            $ty WORD_GET_FIELD = or
            if {
                $ty WORD_GET_FIELD /= if {
                    $words.buf.ptr $index + !.L:Token @name
                    $index sizeof(L:Token) + #index // skip `name`
                    $fd ", \"name\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                    $fd $name L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
                } else {
                    $words.buf.ptr $index + !.L:Token @token
                    $index sizeof(L:Token) + #index // skip `token`
                    $fd ", \"token\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                    $fd $token L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
                }
                $fd ", \"fields\": [" IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $words.buf.ptr $index + ~ @field-count
                $index sizeof(i32) + #index // skip `field-count`
                loop {
                    $field-count 0 = if { 0 break }
                    $words.buf.ptr $index + !.L:Token @field
                    $index sizeof(L:Token) + #index
                    $fd $field L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
                    $field-count 1 - #field-count
                    $field-count 0 = if { 0 break }
                    $fd ", " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                } CORE:dup<i32> 0 /= if { break } else { drop }
                $fd "]" IO:write-all break
            }
            $ty WORD_INIT = if {
                $words.buf.ptr $index + !.L:Token @name
                $index sizeof(L:Token) + #index // skip `name`
                $fd ", \"name\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $fd $name L:Token-write break
            }
            $ty WORD_CALL =
            $ty WORD_FUN_REF = or
            if {
                $words.buf.ptr $index + !.L:Token @name
                $index sizeof(L:Token) + #index // skip `name`
                $fd ", \"name\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $fd $name L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }

                $words.buf.ptr $index + !.bool ~
                $index sizeof(bool) + #index // skip `foreign`
                if {
                    $words.buf.ptr $index + !.L:Token @module
                    $index sizeof(L:Token) + #index // skip `module`
                    $fd ", \"module\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                    $fd $module L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
                }

                $words.buf.ptr $index + !.i32 ~ @generic-argument-count
                $index sizeof(i32) + #index // skip `generic-argument-count`
                $fd ", \"generic-arguments\": [" IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                loop {
                    $generic-argument-count 0 = if { 0 break }
                    $words.buf.ptr $index + !.ParsedType @type
                    $index sizeof(ParsedType) + #index
                    $fd $type ParsedType-write CORE:dup<i32> 0 /= if { break } else { drop }
                    $generic-argument-count 1 - #generic-argument-count
                    $generic-argument-count 0 = if { 0 break }
                    $fd ", " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                } CORE:dup<i32> 0 /= if { break } else { drop }
                $fd "]" IO:write-all break
            }
            $ty WORD_IF = if {
                $words.buf.ptr $index + !.L:Token @token
                $index sizeof(L:Token) + #index // skip `token`
                $fd ", \"token\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $fd $token L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }

                $fd ", \"if-words\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $words.buf.ptr $index + ~ @if-word-count
                $index sizeof(i32) + #index // skip `if-word-count`
                $fd $words $index $if-word-count ParsedWords-write-n-from flip #index CORE:dup<i32> 0 /= if { break } else { drop }

                $fd ", \"else-words\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $words.buf.ptr $index + ~ @else-word-count
                $index sizeof(i32) + #index // skip `else-word-count`
                $fd $words $index $else-word-count ParsedWords-write-n-from flip #index break
            }
            $ty WORD_BLOCK =
            $ty WORD_LOOP = or
            if {
                $words.buf.ptr $index + !.L:Token @token
                $index sizeof(L:Token) + #index // skip `token`
                $fd ", \"token\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $fd $token L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }

                $fd ", \"words\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $words.buf.ptr $index + ~ @word-count
                $index sizeof(i32) + #index // skip `word-count`
                $fd $words $index $word-count ParsedWords-write-n-from flip #index break
            }
            $ty WORD_LOAD =
            $ty WORD_BREAK = or
            if {
                $words.buf.ptr $index + !.L:Token @token
                $index sizeof(L:Token) + #index // skip `token`
                $fd ", \"token\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $fd $token L:Token-write break
            }
            $ty WORD_CAST =
            $ty WORD_SIZEOF = or
            if {
                $words.buf.ptr $index + !.L:Token @token
                $index sizeof(L:Token) + #index // skip `token`
                $fd ", \"token\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $fd $token L:Token-write CORE:dup<i32> 0 /= if { break } else { drop }
                $fd ", \"type\": " IO:write-all CORE:dup<i32> 0 /= if { break } else { drop }
                $words.buf.ptr $index + !.ParsedType @type
                $index sizeof(ParsedType) + #index // skip `type`
                $fd $type ParsedType-write break
            }
            2 "ParsedWords-write-word unhandled Word type " IO:write-all IO:check
            2 $ty WordTy-name IO:write-all IO:check
            2 IO:newline
            CORE:unreachable<i32>
        } CORE:dup<i32> 0 /= if { break } else { drop }
        $fd " }" IO:write-all
    } $index flip
}

struct ParsedWord {
    index: i32
}
fn ParsedWord-write(fd: i32, self: .ParsedWord) -> i32 {
    $fd $self.index IO:print
}

fn parse(arena: .A:Arena, file-path: ByteSlice:T, tokens: .Array:Array<L:Token>) -> ParsedModule {
    Array:new<ParsedImport> @imports
    Array:new<ParsedStruct> @structs
    Array:new<ParsedExternFunction> @extern-functions
    Array:new<ParsedFunction> @functions
    ParsedTypes-new @types
    0 @cursor
    loop {
        $cursor $tokens.len = if { break }
        $cursor &file-path $tokens peek @token
        block {
            $token L:Token-ty L:TOKEN_IMPORT = if {
                $cursor &file-path $tokens next #cursor drop // skip the `import`
                $cursor &file-path $tokens next #cursor @token
                $token L:Token-ty L:TOKEN_STRING /= if {
                    &file-path $token "Expected file path" abort
                }
                $token @file-path-token

                $cursor &file-path $tokens next #cursor @token
                $token L:Token-ty L:TOKEN_AS /= if {
                    &file-path $token "Expected `as`." abort
                }

                $cursor &file-path $tokens next #cursor @token
                $token L:Token-ty L:TOKEN_IDENT /= if {
                    &file-path $token "Expected an identifier as module qualifier." abort
                }
                $token @module-qualifier-token

                $arena &imports $file-path-token ~ $module-qualifier-token ~ ParsedImport-new Array:push<ParsedImport>
                break
            }
            $token L:Token-ty L:TOKEN_FN = if {
                $arena $cursor &file-path $tokens &types parse-function-signature #cursor @returns @parameters @generic-parameters @name @export-name 
                ParsedWords-new @words
                $arena $cursor &file-path $tokens &types &words parse-words-with-locals #cursor drop @locals
                $arena &functions $export-name $name ~ $generic-parameters $parameters $returns $locals $words ParsedFunction-new Array:push<ParsedFunction>
                break
            }
            $token L:Token-ty L:TOKEN_EXTERN = if {
                $cursor &file-path $tokens next #cursor drop // skip the `import`
                $cursor &file-path $tokens next #cursor @extern-module
                $extern-module L:Token-ty L:TOKEN_STRING /= if {
                    &file-path $extern-module "Expected string as extern module name" abort
                }
                $cursor &file-path $tokens next #cursor @extern-name
                $extern-name L:Token-ty L:TOKEN_STRING /= if {
                    &file-path $extern-name "Expected string as extern name" abort
                }
                $arena $cursor &file-path $tokens &types parse-function-signature #cursor @returns @parameters @generic-parameters @name @export-name
                $arena &extern-functions $extern-module ~ $extern-name ~ $name ~ $parameters $returns ParsedExternFunction-new Array:push<ParsedExternFunction>
                break
            }
            $token L:Token-ty L:TOKEN_STRUCT = if {
                $cursor &file-path $tokens next #cursor drop // skip the `struct`
                $cursor &file-path $tokens next #cursor @name
                $name L:Token-ty L:TOKEN_IDENT /= if {
                    &file-path $name "Expected identifer as struct name." abort
                }
                $cursor &file-path $tokens next #cursor @name
                $name L:Token-ty L:TOKEN_LEFT_BRACE /= if {
                    &file-path $token "Expected `{`." abort
                }
                Array:new<ParsedNamedType> @fields
                loop {
                    $cursor &file-path $tokens peek L:Token-ty L:TOKEN_RIGHT_BRACE = if { 
                        $cursor &file-path $tokens next #cursor drop // skip the `}`
                        break
                    }
                    $cursor &file-path $tokens next #cursor @name
                    $name L:Token-ty L:TOKEN_IDENT /= if {
                        &file-path $name "Expected identifer as struct field name." abort
                    }
                    $cursor &file-path $tokens next #cursor @token
                    $token L:Token-ty L:TOKEN_COLON /= if {
                        &file-path $token "Expected `:` after field name." abort
                    }
                    $arena $cursor &file-path $tokens &types parse-type #cursor @type
                    $arena &fields $name ~ $type ParsedNamedType-new Array:push<ParsedNamedType>
                }
                $arena &structs $name ~ $fields ParsedStruct-new Array:push<ParsedStruct>
                break
            }
            2 "Unhanded token in parser: " IO:write-all IO:check
            2 $token L:Token-write IO:check
            2 IO:newline
            0 0 / drop
        }
    }
    $arena $file-path ByteSlice:copy $types $imports $structs $functions ParsedModule-new
}
fn parse-function-signature(arena: .A:Arena, cursor: i32, file-path: .ByteSlice:T, tokens: .Array:Array<L:Token>, types: .ParsedTypes) -> Optional:T<L:Token>, .L:Token, Array:Array<L:Token>, Array:Array<ParsedNamedType>, Array:Array<ParsedType>, i32 {
    $cursor $file-path $tokens next #cursor drop // skip the `fn`
    $cursor $file-path $tokens next #cursor @token
    $token L:Token-ty L:TOKEN_IDENT /= if {
        $file-path $token "Expected identifer as function name." abort
    }
    $token @function-ident-token

    $cursor $file-path $tokens peek @token
    $token L:Token-ty L:TOKEN_LEFT_TRIANGLE = if {
        $arena $cursor $file-path $tokens parse-generic-parameters #cursor
    } else { Array:new<L:Token> } @generic-parameters

    $cursor $file-path $tokens next #cursor @token
    $token L:Token-ty L:TOKEN_LEFT_PAREN /=
    $token L:Token-ty L:TOKEN_STRING /= and if {
        $file-path $token "Expected either `(` or a string as exported function name." abort
    }
    $token L:Token-ty L:TOKEN_STRING = if {
        $token ~ Optional:wrap<L:Token>
        $cursor $file-path $tokens next #cursor #token
        $token L:Token-ty L:TOKEN_LEFT_PAREN /= if {
            $file-path $token "Expected `(`." abort }
    } else { Optional:none<L:Token> } @function-export-name-token

    Array:new<ParsedNamedType> @parameters
    loop {
        $cursor $file-path $tokens next #cursor @token
        $token L:Token-ty L:TOKEN_RIGHT_PAREN = if { break }

        $token L:Token-ty L:TOKEN_IDENT /= if {
            $file-path $token "Expected an identifier as function parameter name." abort
        }
        $token @parameter-name

        $cursor $file-path $tokens next #cursor @token
        $token L:Token-ty L:TOKEN_COLON /= if {
            $file-path $token "Expected `:` after function parameter name." abort
        }
        $arena $cursor $file-path $tokens $types parse-type #cursor @parameter-type
        $arena &parameters $parameter-name ~ $parameter-type ParsedNamedType-new Array:push<ParsedNamedType>

        $cursor $file-path $tokens next #cursor @token
        $token L:Token-ty L:TOKEN_RIGHT_PAREN = if { break }
        $token L:Token-ty L:TOKEN_COMMA /= if {
            $file-path $token "Expected `,` after function parameter." abort
        }
    }
    Array:new<ParsedType> @returns
    $cursor $file-path $tokens peek L:Token-ty L:TOKEN_ARROW = if {
        $cursor $file-path $tokens next #cursor drop // skip the `->`
        loop {
            $arena $cursor $file-path $tokens $types parse-type #cursor @type
            $arena &returns $type Array:push<ParsedType>

            $cursor $tokens.len = if { break }
            $cursor $file-path $tokens peek @token
            $token L:Token-ty L:TOKEN_COMMA /= if { break }
            $cursor $file-path $tokens next #cursor drop // skip the `,`
        }
    }
    $function-export-name-token $function-ident-token $generic-parameters $parameters $returns $cursor
}
fn parse-words-with-locals(arena: .A:Arena, cursor: i32, file-path: .ByteSlice:T, tokens: .Array:Array<L:Token>, types: .ParsedTypes, words: .ParsedWords) -> Array:Array<ParsedNamedType>, i32, i32 {
    $cursor $file-path $tokens next #cursor @token
    $token L:Token-ty L:TOKEN_LEFT_BRACE /= if {
        $file-path $token "Expected `{`." abort
    }

    Array:new<ParsedNamedType> @locals
    loop {
        $cursor $file-path $tokens peek L:Token-ty L:TOKEN_LOCAL /= if {
            break
        }
        $cursor $file-path $tokens next #cursor drop // skip the `local`
        $cursor $file-path $tokens next #cursor @name
        $name L:Token-ty L:TOKEN_IDENT /= if {
            $file-path $name "Expected identifier as local name." abort
        }
        $cursor $file-path $tokens next #cursor @token
        $token L:Token-ty L:TOKEN_COLON /= if {
            $file-path $name "Expected `:` after local name." abort
        }
        $arena $cursor $file-path $tokens $types parse-type #cursor @type
        $arena &locals $name ~ $type ParsedNamedType-new Array:push<ParsedNamedType>
    }
    $locals
    $arena $cursor $file-path $tokens $types $words parse-words-inner
}
fn parse-words(arena: .A:Arena, cursor: i32, file-path: .ByteSlice:T, tokens: .Array:Array<L:Token>, types: .ParsedTypes, words: .ParsedWords) -> i32, i32 {
    $cursor $file-path $tokens next #cursor @token
    $token L:Token-ty L:TOKEN_LEFT_BRACE /= if {
        $file-path $token "Expected `{`." abort
    }
    $arena $cursor $file-path $tokens $types $words parse-words-inner
}
fn parse-words-inner(arena: .A:Arena, cursor: i32, file-path: .ByteSlice:T, tokens: .Array:Array<L:Token>, types: .ParsedTypes, words: .ParsedWords) -> i32, i32 {
    0 @count
    loop {
        $cursor $file-path $tokens peek @token
        $token L:Token-ty L:TOKEN_RIGHT_BRACE = if {
            $cursor $file-path $tokens next #cursor drop // skip the `}`
            break
        }

        $arena $cursor $file-path $tokens $types $words parse-word #cursor
        $count 1 + #count

        $cursor $file-path $tokens peek @token
        $token L:Token-ty L:TOKEN_RIGHT_BRACE = if {
            $cursor $file-path $tokens next #cursor drop // skip the `}`
            break
        }
    }
    $count $cursor
}
fn parse-word(arena: .A:Arena, cursor: i32, file-path: .ByteSlice:T, tokens: .Array:Array<L:Token>, types: .ParsedTypes, words: .ParsedWords) -> i32 {
    block {
        $cursor $file-path $tokens next #cursor @token
        $token L:Token-ty L:TOKEN_NUMBER = if {
            $arena $words $token ~ ParsedWords-push-number drop
            break
        }
        $token L:Token-ty L:TOKEN_STRING = if {
            $arena $words $token ~ ParsedWords-push-string drop
            break
        }
        $token L:Token-ty L:TOKEN_DOLLAR =
        $token L:Token-ty L:TOKEN_AMPERSAND = or
        $token L:Token-ty L:TOKEN_HASH = or
        $token L:Token-ty L:TOKEN_DOUBLE_ARROW = or
        if {
            $token L:Token-ty @type-first-token
            $cursor $file-path $tokens next #cursor @token
            $token L:Token-ty L:TOKEN_IDENT /= if {
                $file-path $token "Expected an identifier as variable name." abort
            }
            block {
                $type-first-token L:TOKEN_DOLLAR = if {
                    $arena $words $token ~ ParsedWords-push-get flip drop break
                }
                $type-first-token L:TOKEN_AMPERSAND = if {
                    $arena $words $token ~ ParsedWords-push-ref flip drop break
                }
                $type-first-token L:TOKEN_HASH = if {
                    $arena $words $token ~ ParsedWords-push-set flip drop break
                }
                $type-first-token L:TOKEN_DOUBLE_ARROW = if {
                    $arena $words $token ~ ParsedWords-push-store flip drop break
                }
                CORE:unreachable<i32>
            } @field-count-patch
            $arena $cursor $file-path $tokens $words parse-field-accesses @field-count
            $words.buf.ptr $field-count-patch + $field-count store
            break
        }
        $token L:Token-ty L:TOKEN_AT = if {
            $cursor $file-path $tokens next #cursor @token
            $token L:Token-ty L:TOKEN_IDENT /= if {
                $file-path $token "Expected an identifier as variable name." abort
            }
            $arena $words $token ~ ParsedWords-push-init drop break
        }
        $token L:Token-ty L:TOKEN_IDENT = if {
            $cursor $file-path $tokens peek L:Token-ty L:TOKEN_COLON = if {
                $token @module
                $cursor $file-path $tokens next #cursor drop // skip the `:`
                $cursor $file-path $tokens next #cursor @name
                $cursor $file-path $tokens peek L:Token-ty L:TOKEN_LEFT_TRIANGLE = if {
                    $arena $cursor $file-path $tokens $types parse-generic-arguments #cursor
                } else { Array:new<ParsedType> } @generic-arguments
                $arena $words $name ~ $module ~ $generic-arguments ParsedWords-push-foreign-call drop
            } else {
                $token @name
                $cursor $file-path $tokens peek L:Token-ty L:TOKEN_LEFT_TRIANGLE = if {
                    $arena $cursor $file-path $tokens $types parse-generic-arguments #cursor
                } else { Array:new<ParsedType> } @generic-arguments
                $arena $words $name ~ $generic-arguments ParsedWords-push-call drop
            }
            break
        }
        $token L:Token-ty L:TOKEN_IF = if {
            $arena $words WORD_IF ParsedWords-push-ty drop
            $arena $words $token ~ ParsedWords-push-token
            $arena $words ParsedWords-push-patch @if-count-patch
            $arena $cursor $file-path $tokens $types $words parse-words #cursor @if-word-count
            $words.buf.ptr $if-count-patch + $if-word-count store
            $arena $words ParsedWords-push-patch @else-count-patch
            $cursor $file-path $tokens peek L:Token-ty L:TOKEN_ELSE = if {
                $cursor $file-path $tokens next #cursor drop // skip the `else`
                $arena $cursor $file-path $tokens $types $words parse-words #cursor
            } else { 0 } @else-word-count
            $words.buf.ptr $else-count-patch + $else-word-count store
            break
        }
        $token L:Token-ty L:TOKEN_BLOCK =
        $token L:Token-ty L:TOKEN_LOOP = or
        if {
            $arena $words $token L:Token-ty L:TOKEN_BLOCK = if { WORD_BLOCK } else { WORD_LOOP } ParsedWords-push-ty drop
            $arena $words $token ~ ParsedWords-push-token
            $arena $words ParsedWords-push-patch @word-count-patch
            $arena $cursor $file-path $tokens $types $words parse-words #cursor @word-count
            $words.buf.ptr $word-count-patch + $word-count store break
        }
        $token L:Token-ty L:TOKEN_TILDE = if {
            $arena $words $token ~ ParsedWords-push-load drop break
        }
        $token L:Token-ty L:TOKEN_BACKSLASH = if {
            $words.buf.len @word-ty-patch
            $arena $cursor $file-path $tokens $types $words parse-word #cursor
            $words.buf.ptr $word-ty-patch + WORD_FUN_REF store break
        }
        $token L:Token-ty L:TOKEN_BREAK = if {
            $arena $words $token ~ ParsedWords-push-break drop break
        }
        $token L:Token-ty L:TOKEN_BANG = if {
            $arena $cursor $file-path $tokens $types parse-type #cursor @type
            $arena $words $token ~ $type ParsedWords-push-cast drop break
        }
        $token L:Token-ty L:TOKEN_SIZEOF = if {
            $token @sizeof-token
            $cursor $file-path $tokens next #cursor @token
            $token L:Token-ty L:TOKEN_LEFT_PAREN /= if {
                $file-path $token "Expected `(` after `sizeof`." abort
            }
            $arena $cursor $file-path $tokens $types parse-type #cursor @type
            $cursor $file-path $tokens next #cursor @token
            $token L:Token-ty L:TOKEN_RIGHT_PAREN /= if {
                $file-path $token "Expected `)` to close preceeding `sizeof(`." abort
            }
            $arena $words $sizeof-token ~ $type ParsedWords-push-sizeof drop break
        }
        $token L:Token-ty L:TOKEN_DOT = if {
            $arena $words $token ~ ParsedWords-push-get-field flip drop @field-count-patch
            $arena $cursor $file-path $tokens $words parse-field-accesses @field-count
            $words.buf.ptr $field-count-patch + $field-count store break
        }
        2 "parse-word: Unhandled Token " IO:write-all IO:check
        2 $token L:Token-write IO:check
        2 IO:newline
        0 0 / drop
    }
    $cursor
}
fn parse-field-accesses(arena: .A:Arena, cursor: i32, file-path: .ByteSlice:T, tokens: .Array:Array<L:Token>, words: .ParsedWords) -> i32 {
    0 @field-count
    loop {
        $cursor $file-path $tokens peek @token
        $token L:Token-ty L:TOKEN_DOT /= if { break }
        $cursor $file-path $tokens next #cursor drop // skip the `.`

        $cursor $file-path $tokens next #cursor @token
        $token L:Token-ty L:TOKEN_IDENT /= if {
            $file-path $token "Expected an identifer as field name." abort
        }
        $arena $words $token ~ ParsedWords-push-token
        $field-count 1 + #field-count
    }
    $field-count
}
fn parse-type(arena: .A:Arena, cursor: i32, file-path: .ByteSlice:T, tokens: .Array:Array<L:Token>, types: .ParsedTypes) -> ParsedType, i32 { block {
    $cursor $file-path $tokens next #cursor @token
    $token L:Token-ty L:TOKEN_I32 = if {
        $arena $types ParsedTypes-push-i32 $cursor break
    }
    $token L:Token-ty L:TOKEN_BOOL = if {
        $arena $types ParsedTypes-push-bool $cursor break
    }
    $token L:Token-ty L:TOKEN_DOT = if {
        $arena $types ParsedTypes-push-ptr
        $arena $cursor $file-path $tokens $types parse-type flip drop break
    }
    $token L:Token-ty L:TOKEN_I64 = if {
        $arena $types ParsedTypes-push-i64 $cursor break
    }
    $token L:Token-ty L:TOKEN_IDENT = if {
        $cursor $file-path $tokens peek L:Token-ty L:TOKEN_COLON = if {
            $cursor $file-path $tokens next #cursor drop // skip the colon
            $token @module-token
            $cursor $file-path $tokens next #cursor @struct-name-token
            $struct-name-token L:Token-ty L:TOKEN_IDENT /= if {
                $file-path $struct-name-token "Expected an identifier as struct name." abort
            }
            $arena $types $module-token ~ $struct-name-token ~ ParsedTypes-push-foreign-struc @generic-arguments-count-patch @type
            $cursor $file-path $tokens peek @token
            $token L:Token-ty L:TOKEN_LEFT_TRIANGLE = if {
                $arena $cursor $file-path $tokens $types parse-generic-arguments #cursor block {} .len ~
            } else { 0 } $types.buf.ptr $generic-arguments-count-patch + flip store
            $type $cursor break
        }
        $token @struct-name-token
        $arena $types $struct-name-token ~ ParsedTypes-push-struc @generic-arguments-count-patch @type
        $cursor $file-path $tokens peek @token
        $token L:Token-ty L:TOKEN_LEFT_TRIANGLE = if {
            $arena $cursor $file-path $tokens $types parse-generic-arguments #cursor block {} .len ~
        } else { 0 } $types.buf.ptr $generic-arguments-count-patch + flip store
        $type $cursor break
    }
    $file-path $token "Failed to parse type" abort CORE:unreachable<ParsedType> CORE:unreachable<i32>
} }
fn foo(fd: i32, v: .i32) -> i32 {
    $fd $v ~ IO:print
}
fn parse-generic-arguments(arena: .A:Arena, cursor: i32, file-path: .ByteSlice:T, tokens: .Array:Array<L:Token>, types: .ParsedTypes) -> Array:Array<ParsedType>, i32 { block {
    Array:new<ParsedType> @parsed-types
    $cursor $file-path $tokens next #cursor @token
    $token L:Token-ty L:TOKEN_LEFT_TRIANGLE /= if {
        $file-path $token "Expected `<`." abort
    }
    loop {
        $cursor $file-path $tokens peek @token
        $token L:Token-ty L:TOKEN_RIGHT_TRIANGLE = if { 
            $cursor $file-path $tokens next #cursor drop // consume the `>`
            break
        }
        $arena $cursor $file-path $tokens $types parse-type #cursor @type
        $arena &parsed-types $type Array:push<ParsedType>
        $cursor $file-path $tokens next #cursor @token
        $token L:Token-ty L:TOKEN_RIGHT_TRIANGLE = if { break }
        $token L:Token-ty L:TOKEN_COMMA /= if {
            $file-path $token "Expected `,`." abort
        }
    }
    $parsed-types $cursor
} }
fn parse-generic-parameters(arena: .A:Arena, cursor: i32, file-path: .ByteSlice:T, tokens: .Array:Array<L:Token>) -> Array:Array<L:Token>, i32 { block {
    Array:new<L:Token> @generic-parameters
    $cursor $file-path $tokens next #cursor @token
    $token L:Token-ty L:TOKEN_LEFT_TRIANGLE /= if {
        $file-path $token "Expected `<`." abort
    }
    loop {
        $cursor $file-path $tokens peek @token
        $token L:Token-ty L:TOKEN_RIGHT_TRIANGLE = if { 
            $cursor $file-path $tokens next #cursor drop // consume the `>`
            break
        }
        $cursor $file-path $tokens next #cursor @token
        $arena &generic-parameters $token ~ Array:push<L:Token>
        $cursor $file-path $tokens next #cursor @token
        $token L:Token-ty L:TOKEN_RIGHT_TRIANGLE = if { break }
        $token L:Token-ty L:TOKEN_COMMA /= if {
            $file-path $token "Expected `,`." abort
        }
    }
    $generic-parameters $cursor
} }
fn peek(cursor: i32, file-path: .ByteSlice:T, tokens: .Array:Array<L:Token>) -> .L:Token {
    $cursor $tokens.len = if {
        $cursor 0 = if {
            2 "Cannot use `peek` with empty array of tokens!" IO:write-all IO:check
            0 0 / drop
        }
        $tokens $cursor 1 - Array:get<L:Token> @previous-token
        $file-path $previous-token abort-unexpected-eof
    }
    $tokens $cursor Array:get<L:Token>
}
fn next(cursor: i32, file-path: .ByteSlice:T, tokens: .Array:Array<L:Token>) -> .L:Token, i32 {
    $cursor $tokens.len = if {
        $cursor 0 = if {
            2 "Cannot use `next` with empty array of tokens!" IO:write-all IO:check
            0 0 / drop
        }
        $tokens $cursor 1 - Array:get<L:Token> @previous-token
        $file-path $previous-token abort-unexpected-eof
    }
    $tokens $cursor Array:get<L:Token>
    $cursor 1 +
}
fn abort-unexpected-eof(file-path: .ByteSlice: T, token: .L:Token) {
    $file-path $token "Unexpected end of file" abort
}
fn abort(file-path: .ByteSlice:T, token: .L:Token, message-ptr: .i32, message-len: i32) {
    2 $file-path ~ ByteSlice:unpack $token L:Token-location L:print-location IO:check
    2 ": " IO:write-all IO:check
    2 $message-ptr $message-len IO:write-all IO:check
    1 CORE:exit
}

