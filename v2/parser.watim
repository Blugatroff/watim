import "../std/core.watim" as Core (exit)
import "../std/maybe.watim" as Maybe (Maybe, assert-some)
import "../std/io.watim" as IO
import "../std/arena.watim" as Arena (Arena)
import "../std/array.watim" as Array (Array)
import "../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../std/byte-array.watim" as ByteArray (ByteArray)
import "../std/fmt.watim" as Fmt (Formatter)

import "./lexer.watim" as Lexer (Token, TokenTy, Token-ty, TokenTy-name, Token-lexeme, Token-format, Token-location, Token-column)

struct Import {
    path: Token
    qualifier: Token
    items: Array<Token>
}
fn Import-format(fmt: .Formatter, self: .Import) {
    $fmt "(Import " Fmt:write
    $fmt &self.path Token-format
    $fmt " " Fmt:write
    $fmt &self.qualifier Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.items Array:format<Token>
    $fmt ")" Fmt:write
}

struct ForeignCustomType {
    module: Token
    name: Token
    generic-arguments: Array<Type>
}
fn ForeignCustomType-format(fmt: .Formatter, self: .ForeignCustomType) {
    $fmt &self.module Token-lexeme Fmt:write
    $fmt ":" Fmt:write
    $fmt &self.name Token-lexeme Fmt:write
    $fmt \Type-format &self.generic-arguments Array:format<Type>
}

struct LocalCustomType {
    name: Token
    generic-arguments: Array<Type>
}
fn LocalCustomType-format(fmt: .Formatter, self: .LocalCustomType) {
    $fmt &self.name Token-lexeme Fmt:write
    $fmt \Type-format &self.generic-arguments Array:format<Type>
}

variant CustomType {
    case Local -> LocalCustomType
    case Foreign -> ForeignCustomType
}
fn CustomType-format(fmt: .Formatter, self: .CustomType) {
    $fmt $self match {
        case Local -> { LocalCustomType-format }
        case Foreign -> { ForeignCustomType-format }
    }
}

variant Type {
    case Bool
    case I32
    case I64
    case Ptr -> .Type
    case Custom -> CustomType
}
fn Type-format(fmt: .Formatter, self: .Type) { block {
    $self match {
        case Bool -> { "bool" }
        case I32 -> { "i32" }
        case I64 -> { "i64" }
        case Ptr -> { $fmt "." Fmt:write ~ $fmt flip Type-format break }
        case Custom -> { $fmt flip CustomType-format break }
    } @len @ptr
    $fmt $ptr $len Fmt:write
} }

struct NamedType {
    name: Token
    type: Type
}
fn NamedType-format(fmt: .Formatter, self: .NamedType) {
    $fmt "(NamedType " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

struct ForeignCall {
    module: Token
    name: Token
}
fn ForeignCall-format(fmt: .Formatter, self: .ForeignCall) {
    $fmt "(ForeignCall " Fmt:write
    $fmt &self.module Token-format
    $fmt " " Fmt:write
    $fmt &self.name Token-format
    $fmt ")" Fmt:write
}

struct RefLocal {
    ident: Token
    fields: Array<Token>
}
fn RefLocal-format(fmt: .Formatter, self: .RefLocal) {
    $fmt "(RefLocal " Fmt:write
    $fmt &self.ident Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.fields Array:format<Token>
    $fmt ")" Fmt:write
}

struct GetLocal {
    ident: Token
    fields: Array<Token>
}
fn GetLocal-format(fmt: .Formatter, self: .GetLocal) {
    $fmt "(GetLocal " Fmt:write
    $fmt &self.ident Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.fields Array:format<Token>
    $fmt ")" Fmt:write
}

struct SetLocal {
    ident: Token
    fields: Array<Token>
}
fn SetLocal-format(fmt: .Formatter, self: .SetLocal) {
    $fmt "(SetLocal " Fmt:write
    $fmt &self.ident Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.fields Array:format<Token>
    $fmt ")" Fmt:write
}

struct If {
    token: Token
    true-words: Array<Word>
    false-words: Array<Word>
}
fn If-format(fmt: .Formatter, self: .If) {
    $fmt "(If " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \Word-format &self.true-words Array:format-multi-line<Word>
    $fmt " " Fmt:write
    $fmt \Word-format &self.false-words Array:format-multi-line<Word>
    $fmt ")" Fmt:write
}

struct Block {
    token: Token
    words: Array<Word>
}
fn Block-format(fmt: .Formatter, self: .Block) {
    $fmt "(Block " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \Word-format &self.words Array:format-multi-line<Word>
    $fmt ")" Fmt:write
}

struct Loop {
    token: Token
    words: Array<Word>
}
fn Loop-format(fmt: .Formatter, self: .Loop) {
    $fmt "(Loop " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \Word-format &self.words Array:format-multi-line<Word>
    $fmt ")" Fmt:write
}

struct Cast {
    token: Token
    type: Type
}
fn Cast-format(fmt: .Formatter, self: .Cast) {
    $fmt "(Cast " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

struct MakeStruct {
    token: Token
    type: CustomType
}
fn MakeStruct-format(fmt: .Formatter, self: .MakeStruct) {
    $fmt "(MakeStruct " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type CustomType-format
    $fmt ")" Fmt:write
}

struct MakeStructNamed {
    token: Token
    type: CustomType
    words: Array<Word>
}
fn MakeStructNamed-format(fmt: .Formatter, self: .MakeStructNamed) {
    $fmt "(MakeStructNamed " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type CustomType-format
    $fmt " " Fmt:write
    $fmt \Word-format &self.words Array:format-multi-line<Word>
    $fmt ")" Fmt:write
}

struct MakeVariant {
    token: Token
    type: CustomType
    cays: Token
}
fn MakeVariant-format(fmt: .Formatter, self: .MakeVariant) {
    $fmt "(MakeVariant " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.type CustomType-format
    $fmt " " Fmt:write
    $fmt &self.cays Token-format
    $fmt ")" Fmt:write
}

variant Call {
    case Local -> Token
    case Foreign -> ForeignCall
}
fn Call-format(fmt: .Formatter, self: .Call) {
    $self match {
        case Local -> {
            $fmt "(Call " Fmt:write
            $fmt flip Token-format
            $fmt ")" Fmt:write
        }
        case Foreign -> { $fmt flip ForeignCall-format }
    }
}

variant Word {
    case Call -> Call
    case String -> Token
    case InitLocal -> Token
    case RefLocal -> RefLocal
    case GetLocal -> GetLocal
    case SetLocal -> SetLocal
    case Number -> Token
    case If -> If
    case Block -> Block
    case Load -> Token
    case Cast -> Cast
    case Break -> Token
    case Loop -> Loop
    case MakeStruct -> MakeStruct
    case MakeStructNamed -> MakeStructNamed
    case MakeVariant -> MakeVariant
    case IndirectCall -> Call
}
fn Word-format(fmt: .Formatter, self: .Word) { block {
    $self match {
        case Call -> { $fmt flip Call-format break }
        case String -> { "String" }
        case InitLocal -> { "InitLocal" }
        case RefLocal -> { $fmt flip RefLocal-format break }
        case GetLocal -> { $fmt flip GetLocal-format break }
        case SetLocal -> { $fmt flip SetLocal-format break }
        case Number -> { "Number" }
        case If -> { $fmt flip If-format break }
        case Block -> { $fmt flip Block-format break }
        case Load -> { "Load" }
        case Cast -> { $fmt flip Cast-format break }
        case Break -> { "Break" }
        case Loop -> { $fmt flip Loop-format break }
        case MakeStruct -> { $fmt flip MakeStruct-format break }
        case MakeStructNamed -> { $fmt flip MakeStructNamed-format break }
        case MakeVariant -> { $fmt flip MakeVariant-format break }
        case IndirectCall -> { $fmt "(Indirect " Fmt:write $fmt flip Call-format $fmt ")" Fmt:write break }
    } @name-len @name-ptr
    $fmt "(" Fmt:write
    $fmt $name-ptr $name-len Fmt:write
    $fmt " " Fmt:write
    $fmt flip Token-format
    $fmt ")" Fmt:write
} }

struct Signature {
    generic-parameters: Array<Token>
    parameters: Array<NamedType>
    returns: Array<Type>
}
fn Signature-format(fmt: .Formatter, self: .Signature) {
    $fmt "(Signature " Fmt:write
    $fmt \Token-format &self.generic-parameters Array:format<Token>
    $fmt " " Fmt:write
    $fmt \NamedType-format &self.parameters Array:format<NamedType>
    $fmt " " Fmt:write
    $fmt \Type-format &self.returns Array:format<Type>
    $fmt ")" Fmt:write
}

struct Function {
    name: Token
    export: Maybe<Token>
    signature: Signature
    words: Array<Word>
}
fn Function-format(fmt: .Formatter, self: .Function) {
    $fmt "(Function " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    &self.export match {
        case None -> { }
        case Some -> {
            $fmt flip Token-format
            $fmt " " Fmt:write
        }
    }
    $fmt &self.signature Signature-format
    $fmt " " Fmt:write
    $fmt \Word-format &self.words Array:format-multi-line<Word>
    $fmt ")" Fmt:write
}

struct Struct {
    name: Token
    generic-parameters: Array<Token>
    fields: Array<NamedType>
}
fn Struct-format(fmt: .Formatter, self: .Struct) {
    $fmt "(Struct " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.generic-parameters Array:format<Token>
    $fmt " " Fmt:write
    $fmt \NamedType-format &self.fields Array:format-multi-line<NamedType>
    $fmt ")" Fmt:write
}

variant TopItem {
    case Import -> Import
    case Function -> Function
    case Struct -> Struct
}
fn TopItem-format(fmt: .Formatter, self: .TopItem) {
    $fmt $self match {
        case Import -> { Import-format }
        case Function -> { Function-format }
        case Struct -> { Struct-format }
    }
}

struct Parser {
    arena: .Arena
    tokens: Array<Token>
    cursor: i32
}
fn eof(parser: .Parser) -> bool {
    $parser.cursor $parser.tokens.len ge
}
fn peek-immediate(parser: .Parser) -> Maybe<.Token> {
    $parser.cursor $parser.tokens.len = if {
        make Maybe<.Token>.None
    } else {
        &parser.tokens $parser.cursor Array:get<Token> make Maybe<.Token>.Some
    }
}
fn peek(parser: .Parser) -> Maybe<.Token> {
    $parser.cursor @i
    loop {
        $parser.tokens.len $i = if { make Maybe<.Token>.None break }
        &parser.tokens $i Array:get<Token> @token
        $i 1 + #i
        $token Token-ty match {
            case TOKEN_SPACE -> {}
            case _ -> { drop $token make Maybe<.Token>.Some break }
        }
    }
}
fn advance-immediate(parser: .Parser) -> Maybe<.Token> {
    $parser.cursor $parser.tokens.len = if {
        make Maybe<.Token>.None
    } else {
        &parser.tokens $parser.cursor Array:get<Token> make Maybe<.Token>.Some
        $parser.cursor 1 + #parser.cursor
    }
}
fn advance(parser: .Parser) -> Maybe<.Token> {
    loop {
        $parser.tokens.len $parser.cursor = if { make Maybe<.Token>.None break }
        &parser.tokens $parser.cursor Array:get<Token> @token
        $parser.cursor 1 + #parser.cursor
        $token Token-ty match {
            case TOKEN_SPACE -> {}
            case _ -> { drop $token make Maybe<.Token>.Some break }
        }
    }
}
fn abort<T>(parser: .Parser, message-ptr: .i32, message-len: i32) -> Result<T, ParseError> {
    $parser.tokens.len 0 = if {
        0 0 / drop // parsing an empty file always should always succeed
    }
    &parser.tokens $parser.cursor 0 = if { 0 } else { $parser.cursor 1 - } Array:get<Token> @token
    $token Token-location $parser.arena $message-ptr $message-len ByteArray:copy make ParseError
    make Result<T, ParseError>.Error
}

variant Result<T, E> {
    case Success -> T
    case Error -> E
}

struct ParseError {
    line: i32
    column: i32
    message: ByteArray
}
fn ParseError-print(fd: i32, self: ParseError, file-path-ptr: .i32, file-path: i32) -> i32 { block {
    $fd $file-path-ptr $file-path IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd ":" IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.line IO:print Core:dup<i32> 0 /= if { break } drop
    $fd ":" IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.column IO:print Core:dup<i32> 0 /= if { break } drop
    $fd " " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd &self.message ByteArray:unpack IO:write-all
} }

fn parse(arena: .Arena, tokens: Array<Token>) -> Result<Array<TopItem>, ParseError> {
    Array:new<TopItem> @items
    $arena $tokens 0 make Parser @parser
    loop {
        &parser advance match {
            case None -> { $items make Result<Array<TopItem>, ParseError>.Success break }
            case Some -> {}
        }
        &parser flip top-item match {
            case Success -> { @top-item $arena &items $top-item Array:push<TopItem> }
            case Error -> {
                2 flip "DEBUG" ParseError-print IO:check
                2 IO:newline
                $items make Result<Array<TopItem>, ParseError>.Success break
                // make Result<Array<TopItem>, ParseError>.Error break
            }
        }
    }
}

fn top-item(parser: .Parser, token: .Token) -> Result<TopItem, ParseError> { block () -> Result<TopItem, ParseError> {
    $token Token-ty match {
        case TOKEN_IMPORT -> {
            $parser advance match {
                case None -> { $parser "expected a file path" abort<TopItem> break }
                case Some -> {}
            } @token
            $token Token-ty match {
                case TOKEN_STRING -> { $token }
                case _ -> { drop $parser "expected a file path" abort<TopItem> break }
            } @path

            $parser advance match {
                case None -> { $parser "expected `as`" abort<TopItem> break }
                case Some -> {}
            } @token
            $token Token-ty match {
                case TOKEN_AS -> { }
                case _ -> { drop $parser "expected `as`" abort<TopItem> break }
            }
            $parser advance match {
                case None -> { $parser "expected an identifier" abort<TopItem> break }
                case Some -> {}
            } @token
            $token Token-ty match {
                case TOKEN_IDENT -> { $token }
                case _ -> { drop $parser "expected an identifier" abort<TopItem> break }
            } @qualifier

            $parser peek match {
                case None -> { 1 1 = }
                case Some -> { Token-ty make TokenTy.TOKEN_LEFT_PAREN /= }
            } if {
                make Import {
                    $path ~ @path
                    $qualifier ~ @qualifier
                    Array:new<Token> @items
                }
                make TopItem.Import
                make Result<TopItem, ParseError>.Success break
            }
            Array:new<Token> @items
            $parser advance drop // drop the `(`
            loop {
                $parser advance match {
                    case None -> { $parser "expected `)` or an identifier" abort<Array<Token>> break }
                    case Some -> {}
                } @item
                $item Token-ty match {
                    case TOKEN_RIGHT_PAREN -> {
                        $items make Result<Array<Token>, ParseError>.Success break
                    }
                    case TOKEN_IDENT -> {
                        $parser.arena &items $item ~ Array:push<Token>
                        $parser peek match {
                            case None -> { $parser "expected `)` or `,`" abort<Array<Token>> break }
                            case Some -> { }
                        } @comma
                        $comma Token-ty match {
                            case TOKEN_COMMA -> { $parser advance drop }
                            case TOKEN_RIGHT_PAREN -> { 
                                $parser advance drop
                                $items make Result<Array<Token>, ParseError>.Success break
                            }
                            case _ -> {
                                drop $parser "expected `)` or `,`" abort<Array<Token>> break
                            }
                        }
                    }
                    case _ -> {
                        drop $parser "expected `)` or an identifier" abort<Array<Token>> break
                    }
                }
            } match {
                case Success -> {
                    @items
                    make Import {
                        $path ~ @path
                        $qualifier ~ @qualifier
                        $items @items
                    }
                    make TopItem.Import
                    make Result<TopItem, ParseError>.Success break
                }
                case Error -> { make Result<TopItem, ParseError>.Error break }
            }
        }
        case TOKEN_FN -> {
            $parser make TokenTy.TOKEN_IDENT expect-token match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @name
            $parser advance match {
                case None -> { $parser "expected `(`, `<` or a string" abort<TopItem> break }
                case Some -> {}
            } @paren-or-export
            $paren-or-export Token-ty match {
                case TOKEN_STRING -> {
                    $parser advance match {
                        case None -> { $parser "expected `(` or `<`" abort<TopItem> break }
                        case Some -> {}
                    } @paren
                    $paren Token-ty match {
                        case TOKEN_LEFT_PAREN -> {}
                        case TOKEN_LEFT_TRIANGLE -> {}
                        case _ -> { drop $parser "expected `(`" abort<TopItem> break }
                    }
                    $paren-or-export ~ make Maybe<Token>.Some $paren
                }
                case TOKEN_LEFT_PAREN -> { make Maybe<Token>.None $paren-or-export }
                case _ -> { drop $parser "expected `(` or a string" abort<TopItem> break }
            } @paren @export
            $parser $paren signature match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @signature

            $parser advance match {
                case None -> { $parser "expected `{`" abort<TopItem> break }
                case Some -> {}
            } @brace
            $parser $brace words match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @body
            $name ~ $export $signature $body make Function make TopItem.Function make Result<TopItem, ParseError>.Success break
        }
        case TOKEN_STRUCT -> {
            $parser make TokenTy.TOKEN_IDENT expect-token match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @name
            $parser advance match {
                case None -> { $parser "expected `<` or `{`" abort<TopItem> break }
                case Some -> {}
            } @left-triangle-or-brace
            $left-triangle-or-brace Token-ty match {
                case TOKEN_LEFT_TRIANGLE -> {
                    $parser $left-triangle-or-brace generic-parameters match {
                        case Error -> { make Result<TopItem, ParseError>.Error break }
                        case Success -> {}
                    }
                    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
                        case Error -> { make Result<TopItem, ParseError>.Error break }
                        case Success -> { drop }
                    }
                }
                case TOKEN_LEFT_BRACE -> { Array:new<Token> }
                case _ -> { drop $parser "expected `<` or `{`" abort<TopItem> break }
            } @generic-parameters

            Array:new<NamedType> @fields
            loop () -> Result<Array<NamedType>, ParseError> {
                $parser.arena &fields
                $parser make TokenTy.TOKEN_IDENT expect-token match {
                    case Error -> { make Result<Array<NamedType>, ParseError>.Error break }
                    case Success -> {}
                } ~
                $parser make TokenTy.TOKEN_COLON expect-token match {
                    case Error -> { make Result<Array<NamedType>, ParseError>.Error break }
                    case Success -> { drop }
                }
                $parser advance match {
                    case None -> { $parser "expected a type" abort<Array<NamedType>> break }
                    case Some -> {}
                } $parser flip type match {
                    case Error -> { make Result<Array<NamedType>, ParseError>.Error break }
                    case Success -> {}
                }
                make NamedType Array:push<NamedType>
                $parser peek match {
                    case None -> { $parser "expected `}`" abort<Array<NamedType>> break }
                    case Some -> {}
                } Token-ty match {
                    case TOKEN_RIGHT_BRACE -> {
                        $parser advance assert-some<.Token> drop
                        $fields make Result<Array<NamedType>, ParseError>.Success break
                    }
                    case _ -> { drop }
                }
            } match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @fields
            $name ~ $generic-parameters $fields make Struct
            make TopItem.Struct
            make Result<TopItem, ParseError>.Success
            break
        }
        case _ -> { drop $parser "TODO" abort<TopItem> }
    }
} }

fn words(parser: .Parser, token: .Token) -> Result<Array<Word>, ParseError> { block {
    Array:new<Word> @words
    loop {
        $parser advance match {
            case None -> { $parser "expected `}` or a word" abort<Array<Word>> break }
            case Some -> {}
        } @token
        $token Token-ty match {
            case TOKEN_RIGHT_BRACE -> {
                $words make Result<Array<Word>, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser $token word match {
            case Error -> {
                2 Fmt:to-fd @fmt
                &fmt \Word-format &words Array:format-multi-line<Word>
                2 IO:newline
                make Result<Array<Word>, ParseError>.Error break
            }
            case Success -> {}
        } @word
        $parser.arena &words $word Array:push<Word>
    }
} }
fn word(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    $token Token-ty match {
        case TOKEN_IDENT -> { $parser $token call match { case Error -> { make Result<Word, ParseError>.Error } case Success -> { make Word.Call make Result<Word, ParseError>.Success } } break }
        case TOKEN_STRING -> { $token ~ make Word.String }
        case TOKEN_AT -> { $parser init-locl break }
        case TOKEN_AMPERSAND -> { $parser ref-locl break }
        case TOKEN_DOLLAR -> { $parser get-locl break }
        case TOKEN_HASH -> { $parser set-locl break }
        case TOKEN_NUMBER -> { $token ~ make Word.Number }
        case TOKEN_IF -> { $parser $token iff break }
        case TOKEN_BLOCK -> { $parser $token blok break }
        case TOKEN_TILDE -> { $token ~ make Word.Load }
        case TOKEN_BANG -> { $parser $token cast break }
        case TOKEN_BREAK -> { $token ~ make Word.Break }
        case TOKEN_LOOP -> { $parser $token lop break }
        case TOKEN_MAKE -> { $parser $token mayk break }
        case TOKEN_BACKSLASH -> { $parser $token indirect-call break }
        case _ -> {
            drop
            $parser "word TODO" abort<Word> break
        }
    } make Result<Word, ParseError>.Success
} }

fn mayk(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block () -> Result<Word, ParseError> {
    $token ~
    $parser advance match {
        case None -> { $parser "expected a type" abort<Word> break }
        case Some -> {}
    } $parser flip custom-type match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $parser peek match {
        case None -> { make MakeStruct make Word.MakeStruct make Result<Word, ParseError>.Success break }
        case Some -> {}
    } Token-ty match {
        case TOKEN_DOT -> {
            $parser advance assert-some<.Token> drop
        }
        case TOKEN_LEFT_BRACE -> {
            $parser advance assert-some<.Token> @brace
            $parser $brace words match {
                case Error -> { make Result<Word, ParseError>.Error break }
                case Success -> {
                    make MakeStructNamed make Word.MakeStructNamed make Result<Word, ParseError>.Success break
                }
            }
        }
        case _ -> { drop make MakeStruct make Word.MakeStruct make Result<Word, ParseError>.Success break }
    }
    $parser make TokenTy.TOKEN_IDENT expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } ~
    make MakeVariant make Word.MakeVariant make Result<Word, ParseError>.Success
} }

fn cast(parser: .Parser, token: .Token) -> Result<Word, ParseError> {
    $parser advance match {
        case None -> { $parser "expected a type" abort<Word> }
        case Some -> {
            $parser flip type match {
                case Error -> { make Result<Word, ParseError>.Error }
                case Success -> { $token ~ flip make Cast make Word.Cast make Result<Word, ParseError>.Success }
            }
        }
    }
}

fn expect-token(parser: .Parser, ty: TokenTy) -> Result<.Token, ParseError> {
    $parser advance match {
        case None -> {
            $parser.arena Arena:temp @arena @save
            $arena "expected `" ByteArray:copy @message
            $arena &message $ty TokenTy-name ByteArray:push
            $arena &message "`" ByteArray:push
            $parser &message ByteArray:unpack abort<.Token>
            $arena $save Arena:restore
        }
        case Some -> {
            Core:dup<.Token> Token-ty $ty /= if {
                Token-ty @actual
                $parser.arena Arena:temp @arena @save
                $arena "expected `" ByteArray:copy @message
                $arena &message $ty TokenTy-name ByteArray:push
                $arena &message "` got: " ByteArray:push
                $arena &message "`" ByteArray:push
                $arena &message $actual TokenTy-name ByteArray:push
                $arena &message "`" ByteArray:push
                $parser &message ByteArray:unpack abort<.Token>
                $arena $save Arena:restore
            } else {
                make Result<.Token, ParseError>.Success
            }
        }
    }
}

fn iff(parser: .Parser, start: .Token) -> Result<Word, ParseError> { block {
    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @brace
    $parser $brace words match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @if-words
    $parser peek match {
        case None -> { $start ~ $if-words Array:new<Word> make If make Word.If make Result<Word, ParseError>.Success break }
        case Some -> {}
    } Token-ty match {
        case TOKEN_ELSE -> { $parser advance assert-some<.Token> drop }
        case _ -> { drop $start ~ $if-words Array:new<Word> make If make Word.If make Result<Word, ParseError>.Success break }
    }
    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @brace
    $parser $brace words match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @else-words
    $start ~ $if-words $else-words make If make Word.If make Result<Word, ParseError>.Success
} }

fn lop(parser: .Parser, start: .Token) -> Result<Word, ParseError> { block {
    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @brace
    $parser $brace words match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @words
    $start ~ $words make Loop make Word.Loop make Result<Word, ParseError>.Success
} }

fn blok(parser: .Parser, start: .Token) -> Result<Word, ParseError> { block {
    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @brace
    $parser $brace words match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @words
    $start ~ $words make Block make Word.Block make Result<Word, ParseError>.Success
} }

fn indirect-call(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    $parser peek match {
        case None -> { $parser "expected a function name" abort<Word> break }
        case Some -> {}
    } @function
    $parser $function call match {
        case Error -> { make Result<Word, ParseError>.Error }
        case Success -> { make Word.IndirectCall make Result<Word, ParseError>.Success }
    }
} }

fn call(parser: .Parser, token: .Token) -> Result<Call, ParseError> { block {
    $parser peek match {
        case None -> { $token ~ make Call.Local make Result<Call, ParseError>.Success break }
        case Some -> {}
    } @colon
    $colon Token-ty match {
        case TOKEN_COLON -> { $parser advance assert-some<.Token> drop }
        case _ -> { drop $token ~ make Call.Local make Result<Call, ParseError>.Success break }
    }
    $parser advance match {
        case Some -> {}
        case None -> { $parser "expected an identifier" abort<Call> break }
    } @name
    $name Token-ty match {
        case TOKEN_IDENT -> {}
        case _ -> { drop $parser "expected an identifier" abort<Call> break }
    }
    $parser peek match {
        case None -> { Array:new<Type> }
        case Some -> {
            Token-ty match {
                case TOKEN_LEFT_TRIANGLE -> {
                    $parser advance assert-some<.Token> drop
                    $parser generic-arguments match {
                        case Error -> { make Result<Call, ParseError>.Error break }
                        case Success -> {}
                    }
                }
                case _ -> { drop Array:new<Type> }
            }
        }
    } @generic-arguments
    $token ~ $name ~ make ForeignCall make Call.Foreign make Result<Call, ParseError>.Success
} }

fn generic-arguments(parser: .Parser) -> Result<Array<Type>, ParseError> {
    Array:new<Type> @generic-args
    loop {
        $parser advance match {
            case None -> { $parser "expected `>` or a type" abort<Array<Type>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_RIGHT_TRIANGLE -> {
                $generic-args make Result<Array<Type>, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser $next type match {
            case Error -> { make Result<Array<Type>, ParseError>.Error break }
            case Success -> {}
        } @type
        $parser.arena &generic-args $type Array:push<Type>
        $parser peek match {
            case Some -> { Token-ty match {
                case TOKEN_COMMA -> { $parser advance drop }
                case TOKEN_RIGHT_TRIANGLE -> {}
                case _ -> { drop $parser "expected `,` or `>`" abort<Array<Type>> break }
            } }
            case None -> {}
        }
    }
}

fn optional-generic-arguments(parser: .Parser) -> Result<Array<Type>, ParseError> { block {
    $parser peek match {
        case None -> { Array:new<Type> }
        case Some -> { @t
            $t Token-ty match {
                case TOKEN_LEFT_TRIANGLE -> {
                    $parser advance assert-some<.Token> drop
                    $parser generic-arguments match {
                        case Error -> { make Result<Array<Type>, ParseError>.Error break }
                        case Success -> {}
                    }
                }
                case _ -> { drop Array:new<Type> }
            }
        }
    }
    make Result<Array<Type>, ParseError>.Success
} }

fn fields(parser: .Parser) -> Result<Array<Token>, ParseError> {
    Array:new<Token> @fields
    loop {
        $parser peek-immediate match {
            case None -> { $fields make Result<Array<Token>, ParseError>.Success break }
            case Some -> {}
        } @dot
        $dot Token-ty match {
            case TOKEN_DOT -> { $parser advance-immediate assert-some<.Token> drop }
            case TOKEN_SPACE -> { $fields make Result<Array<Token>, ParseError>.Success break }
            case _ -> { drop $parser "expected `.`" abort<Array<Token>> break }
        }
        $parser advance-immediate match {
            case None -> { $parser "expected an identifier" abort<Array<Token>> break }
            case Some -> {}
        } ~ @field
        &field Token-ty match {
            case TOKEN_IDENT -> {}
            case _ -> { drop $parser "expected an identifier" abort<Array<Token>> break }
        }
        $parser.arena &fields $field Array:push<Token>
    }
}

fn ident(parser: .Parser) -> Result<Token, ParseError> { block {
    $parser advance match {
        case None -> { $parser "expected an identifier" abort<Token> break }
        case Some -> {}
    } @ident
    $ident Token-ty match {
        case TOKEN_IDENT -> {}
        case _ -> { drop $parser "expected an identifier" abort<Token> break }
    }
    $ident ~ make Result<Token, ParseError>.Success
} }

fn ref-locl(parser: .Parser) -> Result<Word, ParseError> { block {
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @ident
    $parser fields match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $ident flip make RefLocal
    make Word.RefLocal make Result<Word, ParseError>.Success
} }

fn get-locl(parser: .Parser) -> Result<Word, ParseError> { block {
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @ident
    $parser fields match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $ident flip make GetLocal
    make Word.GetLocal make Result<Word, ParseError>.Success
} }

fn set-locl(parser: .Parser) -> Result<Word, ParseError> { block {
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @ident
    $parser fields match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $ident flip make SetLocal
    make Word.SetLocal make Result<Word, ParseError>.Success
} }

fn init-locl(parser: .Parser) -> Result<Word, ParseError> { block {
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } make Word.InitLocal make Result<Word, ParseError>.Success
} }

fn generic-parameters(parser: .Parser, token: .Token) -> Result<Array<Token>, ParseError> { block {
    Array:new<Token> @generic-params
    loop {
        $parser advance match {
            case None -> { $parser "expected `>` or an identifier" abort<Array<Token>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_RIGHT_TRIANGLE -> {
                $generic-params make Result<Array<Token>, ParseError>.Success break
            }
            case TOKEN_IDENT -> {}
            case _ -> { drop $parser "expected `>` or an identifier" abort<Array<Token>> break }
        }
        $parser.arena &generic-params $next ~ Array:push<Token>
        $parser peek match {
            case Some -> { Token-ty match {
                case TOKEN_COMMA -> { $parser advance drop }
                case _ -> { drop $parser "expected `,` or `>`" abort<Array<Token>> break }
            } }
            case None -> {}
        }
    }
} }

fn signature(parser: .Parser, token: .Token) -> Result<Signature, ParseError> { block {
    $token Token-ty match {
        case TOKEN_LEFT_TRIANGLE -> {
            $parser $token generic-parameters match {
                case Error -> { make Result<Signature, ParseError>.Error break }
                case Success -> {}
            }
        }
        case _ -> { drop Array:new<Token> }
    } @generic-params

    Array:new<NamedType> @params
    loop {
        $parser advance match {
            case None -> { $parser "expected `)` or an identifier" abort<Array<NamedType>> break }
            case Some -> {}
        } @paren-or-ident
        $paren-or-ident Token-ty match {
            case TOKEN_RIGHT_PAREN -> {
                Array:new<NamedType> make Result<Array<NamedType>, ParseError>.Success break
            }
            case TOKEN_IDENT -> { $paren-or-ident }
            case _ -> { drop $parser "expected `)` or an identifer" abort<Array<NamedType>> break }
        } @ident
        $parser make TokenTy.TOKEN_COLON expect-token match {
            case Error -> { make Result<Array<NamedType>, ParseError>.Error break }
            case Success -> { drop }
        }
        $parser advance match {
            case None -> { $parser "expected a type" abort<Array<NamedType>> break }
            case Some -> {}
        } $parser flip type match {
            case Error -> { make Result<Array<NamedType>, ParseError>.Error break }
            case Success -> {}
        } @type
        $parser.arena &params $ident ~ $type make NamedType Array:push<NamedType>
        $parser peek match {
            case Some -> { Token-ty match {
                case TOKEN_COMMA -> { $parser advance drop }
                case TOKEN_RIGHT_PAREN -> {}
                case _ -> { drop $parser "expected `,` or `)`" abort<Array<NamedType>> break }
            } }
            case None -> {}
        }
    } match {
        case Error -> { make Result<Signature, ParseError>.Error break }
        case Success -> {}
    } @params

    $parser peek match {
        case None -> { $generic-params $params Array:new<Type> make Signature make Result<Signature, ParseError>.Success break }
        case Some -> {}
    } @arrow
    $arrow Token-ty match {
        case TOKEN_ARROW -> { $parser advance assert-some<.Token> drop }
        case _ -> { drop $generic-params $params Array:new<Type> make Signature make Result<Signature, ParseError>.Success break }
    }
    Array:new<Type> @returns
    loop {
        $parser peek match {
            case None -> { $parser "expected a type or `{`" abort<Array<Type>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_LEFT_BRACE -> {
                $returns make Result<Array<Type>, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser advance assert-some<.Token> drop
        $parser $next type match {
            case Error -> { make Result<Array<Type>, ParseError>.Error break }
            case Success -> {}
        } @type
        $parser.arena &returns $type Array:push<Type>

        $parser peek match {
            case None -> {
                $returns make Result<Array<Type>, ParseError>.Success break
            }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_COMMA -> { $parser advance drop }
            case TOKEN_LEFT_BRACE -> {
                $returns make Result<Array<Type>, ParseError>.Success break
            }
            case _ -> {
                drop $parser "expected `,` or `{`" abort<Array<Type>> break
            }
        }
    } match {
        case Error -> { make Result<Signature, ParseError>.Error break }
        case Success -> {}
    } @returns
    $generic-params $params $returns make Signature make Result<Signature, ParseError>.Success
} }

fn custom-type(parser: .Parser, token: .Token) -> Result<CustomType, ParseError> {
    block () -> Result<CustomType, ParseError> {
        $parser peek match {
            case None -> { $token ~ make CustomType.Local }
            case Some -> {
                Token-ty match {
                    case TOKEN_COLON -> {
                        $token ~
                        $parser advance assert-some<.Token> drop // skip `:`
                        $parser make TokenTy.TOKEN_IDENT expect-token match {
                            case Error -> { make Result<CustomType, ParseError>.Error break }
                            case Success -> {}
                        } ~
                        $parser optional-generic-arguments match {
                            case Error -> { make Result<CustomType, ParseError>.Error break }
                            case Success -> {}
                        }
                        make ForeignCustomType make CustomType.Foreign
                    }
                    case _ -> {
                        drop $token ~
                        $parser optional-generic-arguments match {
                            case Error -> { make Result<CustomType, ParseError>.Error break }
                            case Success -> {}
                        }
                        make LocalCustomType make CustomType.Local
                    }
                }
            }
        }
        make Result<CustomType, ParseError>.Success break
    }
}

fn type(parser: .Parser, token: .Token) -> Result<Type, ParseError> { block () -> Result<Type, ParseError> {
    $token Token-ty match {
        case TOKEN_BOOL -> { make Type.Bool }
        case TOKEN_I32 -> { make Type.I32 }
        case TOKEN_I64 -> { make Type.I64 }
        case TOKEN_DOT -> {
            $parser advance match {
                case None -> { $parser "expected a type" abort<Type> break }
                case Some -> { $parser flip type match {
                    case Success -> { $parser.arena flip Arena:push<Type> make Type.Ptr }
                    case _ -> { break }
                } }
            }
        }
        case TOKEN_IDENT -> { $parser $token custom-type match {
            case Error -> { make Result<Type, ParseError>.Error break }
            case Success -> { make Type.Custom }
        } }
        case _ -> { drop $parser "expected a type" abort<Type> break }
    } make Result<Type, ParseError>.Success
} }

