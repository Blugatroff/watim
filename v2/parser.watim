import "../std/core.watim" as Core (exit)
import "../std/maybe.watim" as Maybe (Maybe, assert-some)
import "../std/io.watim" as IO
import "../std/arena.watim" as Arena (Arena)
import "../std/array.watim" as Array (Array)
import "../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../std/byte-array.watim" as ByteArray (ByteArray)
import "../std/fmt.watim" as Fmt (Formatter)

import "./lexer.watim" as Lexer (Token, TokenTy, Token-ty, TokenTy-name, Token-lexeme, Token-format, Token-location, Token-column)

struct Import {
    path: Token
    qualifier: Token
    items: Array<Token>
}
fn Import-format(fmt: .Formatter, self: .Import) {
    $fmt "(Import " Fmt:write
    $fmt &self.path Token-format
    $fmt " " Fmt:write
    $fmt &self.qualifier Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.items Array:format<Token>
    $fmt ")" Fmt:write
}

struct ForeignType {
    module: Token
    name: Token
}
fn ForeignType-format(fmt: .Formatter, self: .ForeignType) {
    $fmt &self.module Token-lexeme Fmt:write
    $fmt ":" Fmt:write
    $fmt &self.name Token-lexeme Fmt:write
}

variant Type {
    case Bool
    case I32
    case I64
    case Ptr -> .Type
    case Complex -> Token
    case Foreign -> ForeignType
}
fn Type-format(fmt: .Formatter, self: .Type) { block {
    $self match {
        case Bool -> { "bool" }
        case I32 -> { "i32" }
        case I64 -> { "i64" }
        case Ptr -> { $fmt "." Fmt:write ~ $fmt flip Type-format break }
        case Complex -> { $fmt flip Token-format break }
        case Foreign -> { $fmt flip ForeignType-format break }
    } @len @ptr
    $fmt $ptr $len Fmt:write
} }

struct NamedType {
    name: Token
    type: Type
}
fn NamedType-format(fmt: .Formatter, self: .NamedType) {
    $fmt "(NamedType " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type Type-format
    $fmt ")" Fmt:write
}

struct ForeignCall {
    module: Token
    name: Token
}
fn ForeignCall-format(fmt: .Formatter, self: .ForeignCall) {
    $fmt "(ForeignCall " Fmt:write
    $fmt &self.module Token-format
    $fmt " " Fmt:write
    $fmt &self.name Token-format
    $fmt ")" Fmt:write
}

struct RefLocal {
    ident: Token
    fields: Array<Token>
}
fn RefLocal-format(fmt: .Formatter, self: .RefLocal) {
    $fmt "(RefLocal " Fmt:write
    $fmt &self.ident Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.fields Array:format<Token>
    $fmt ")" Fmt:write
}

struct GetLocal {
    ident: Token
    fields: Array<Token>
}
fn GetLocal-format(fmt: .Formatter, self: .GetLocal) {
    $fmt "(GetLocal " Fmt:write
    $fmt &self.ident Token-format
    $fmt " " Fmt:write
    $fmt \Token-format &self.fields Array:format<Token>
    $fmt ")" Fmt:write
}

struct If {
    token: Token
    true-words: Array<Word>
    false-words: Array<Word>
}
fn If-format(fmt: .Formatter, self: .If) {
    $fmt "(If " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \Word-format &self.true-words Array:format-multi-line<Word>
    $fmt " " Fmt:write
    $fmt \Word-format &self.false-words Array:format-multi-line<Word>
    $fmt ")" Fmt:write
}

variant Word {
    case Call -> Token
    case ForeignCall -> ForeignCall
    case String -> Token
    case InitLocal -> Token
    case RefLocal -> RefLocal
    case GetLocal -> GetLocal
    case Number -> Token
    case If -> If
}
fn Word-format(fmt: .Formatter, self: .Word) { block {
    $self match {
        case Call -> { "Call" }
        case ForeignCall -> { $fmt flip ForeignCall-format break }
        case String -> { "String" }
        case InitLocal -> { "InitLocal" }
        case RefLocal -> { $fmt flip RefLocal-format break }
        case GetLocal -> { $fmt flip GetLocal-format break }
        case Number -> { "Number" }
        case If -> { $fmt flip If-format break }
    } @name-len @name-ptr
    $fmt "(" Fmt:write
    $fmt $name-ptr $name-len Fmt:write
    $fmt " " Fmt:write
    $fmt flip Token-format
    $fmt ")" Fmt:write
} }

struct Signature {
    generic-parameters: Array<Token>
    parameters: Array<NamedType>
    returns: Array<Type>
}
fn Signature-format(fmt: .Formatter, self: .Signature) {
    $fmt "Signature " Fmt:write
    $fmt \Token-format &self.generic-parameters Array:format<Token>
    $fmt \NamedType-format &self.parameters Array:format<NamedType>
    $fmt \Type-format &self.returns Array:format<Type>
}

struct Function {
    name: Token
    export: Maybe<Token>
    signature: Signature
    words: Array<Word>
}
fn Function-format(fmt: .Formatter, self: .Function) {
    $fmt "Function " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    &self.export match {
        case None -> { }
        case Some -> {
            $fmt flip Token-format
            $fmt " " Fmt:write
        }
    }
    $fmt &self.signature Signature-format
    $fmt \Word-format &self.words Array:format-multi-line<Word>
}

variant TopItem {
    case Import -> Import
    case Function -> Function
}
fn TopItem-format(fmt: .Formatter, self: .TopItem) {
    $fmt $self match {
        case Import -> { Import-format }
        case Function -> { Function-format }
    }
}

struct Parser {
    arena: .Arena
    tokens: Array<Token>
    cursor: i32
}
fn eof(parser: .Parser) -> bool {
    $parser.cursor $parser.tokens.len ge
}
fn peek-immediate(parser: .Parser) -> Maybe<.Token> {
    $parser.cursor $parser.tokens.len = if {
        make Maybe<.Token>.None
    } else {
        &parser.tokens $parser.cursor Array:get<Token> make Maybe<.Token>.Some
    }
}
fn peek(parser: .Parser) -> Maybe<.Token> {
    $parser.cursor @i
    loop {
        $parser.tokens.len $i = if { make Maybe<.Token>.None break }
        &parser.tokens $i Array:get<Token> @token
        $i 1 + #i
        $token Token-ty match {
            case TOKEN_SPACE -> {}
            case _ -> { drop $token make Maybe<.Token>.Some break }
        }
    }
}
fn advance-immediate(parser: .Parser) -> Maybe<.Token> {
    $parser.cursor $parser.tokens.len = if {
        make Maybe<.Token>.None
    } else {
        &parser.tokens $parser.cursor Array:get<Token> make Maybe<.Token>.Some
        $parser.cursor 1 + #parser.cursor
    }
}
fn advance(parser: .Parser) -> Maybe<.Token> {
    loop {
        $parser.tokens.len $parser.cursor = if { make Maybe<.Token>.None break }
        &parser.tokens $parser.cursor Array:get<Token> @token
        $parser.cursor 1 + #parser.cursor
        $token Token-ty match {
            case TOKEN_SPACE -> {}
            case _ -> { drop $token make Maybe<.Token>.Some break }
        }
    }
}
fn abort<T>(parser: .Parser, message-ptr: .i32, message-len: i32) -> Result<T, ParseError> {
    $parser.tokens.len 0 = if {
        0 0 / drop // parsing an empty file always should always succeed
    }
    &parser.tokens $parser.cursor 0 = if { 0 } else { $parser.cursor 1 - } Array:get<Token> @token
    $token Token-location $parser.arena $message-ptr $message-len ByteArray:copy make ParseError
    make Result<T, ParseError>.Error
}

variant Result<T, E> {
    case Success -> T
    case Error -> E
}

struct ParseError {
    line: i32
    column: i32
    message: ByteArray
}
fn ParseError-print(fd: i32, self: ParseError, file-path-ptr: .i32, file-path: i32) -> i32 { block {
    $fd $file-path-ptr $file-path IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd ":" IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.line IO:print Core:dup<i32> 0 /= if { break } drop
    $fd ":" IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.column IO:print Core:dup<i32> 0 /= if { break } drop
    $fd " " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd &self.message ByteArray:unpack IO:write-all
} }

fn parse(arena: .Arena, tokens: Array<Token>) -> Result<Array<TopItem>, ParseError> {
    Array:new<TopItem> @items
    $arena $tokens 0 make Parser @parser
    loop {
        &parser advance match {
            case None -> { $items make Result<Array<TopItem>, ParseError>.Success break }
            case Some -> {}
        }
        &parser flip top-item match {
            case Success -> { @top-item $arena &items $top-item Array:push<TopItem> }
            case Error -> {
                2 flip "DEBUG" ParseError-print IO:check
                2 IO:newline
                $items make Result<Array<TopItem>, ParseError>.Success break
                // make Result<Array<TopItem>, ParseError>.Error break
            }
        }
    }
}

fn top-item(parser: .Parser, token: .Token) -> Result<TopItem, ParseError> { block {
    $token Token-ty match {
        case TOKEN_IMPORT -> {
            $parser advance match {
                case None -> { $parser "expected a file path" abort<TopItem> break }
                case Some -> {}
            } @token
            $token Token-ty match {
                case TOKEN_STRING -> { $token }
                case _ -> { drop $parser "expected a file path" abort<TopItem> break }
            } @path

            $parser advance match {
                case None -> { $parser "expected `as`" abort<TopItem> break }
                case Some -> {}
            } @token
            $token Token-ty match {
                case TOKEN_AS -> { }
                case _ -> { drop $parser "expected `as`" abort<TopItem> break }
            }
            $parser advance match {
                case None -> { $parser "expected an identifier" abort<TopItem> break }
                case Some -> {}
            } @token
            $token Token-ty match {
                case TOKEN_IDENT -> { $token }
                case _ -> { drop $parser "expected an identifier" abort<TopItem> break }
            } @qualifier

            $parser peek match {
                case None -> { 1 1 = }
                case Some -> { Token-ty make TokenTy.TOKEN_LEFT_PAREN /= }
            } if {
                make Import {
                    $path ~ @path
                    $qualifier ~ @qualifier
                    Array:new<Token> @items
                }
                make TopItem.Import
                make Result<TopItem, ParseError>.Success break
            }
            Array:new<Token> @items
            $parser advance drop // drop the `(`
            loop {
                $parser advance match {
                    case None -> { $parser "expected `)` or an identifier" abort<Array<Token>> break }
                    case Some -> {}
                } @item
                $item Token-ty match {
                    case TOKEN_RIGHT_PAREN -> {
                        $items make Result<Array<Token>, ParseError>.Success break
                    }
                    case TOKEN_IDENT -> {
                        $parser.arena &items $item ~ Array:push<Token>
                        $parser peek match {
                            case None -> { $parser "expected `)` or `,`" abort<Array<Token>> break }
                            case Some -> { }
                        } @comma
                        $comma Token-ty match {
                            case TOKEN_COMMA -> { $parser advance drop }
                            case TOKEN_RIGHT_PAREN -> { 
                                $parser advance drop
                                $items make Result<Array<Token>, ParseError>.Success break
                            }
                            case _ -> {
                                drop $parser "expected `)` or `,`" abort<Array<Token>> break
                            }
                        }
                    }
                    case _ -> {
                        drop $parser "expected `)` or an identifier" abort<Array<Token>> break
                    }
                }
            } match {
                case Success -> {
                    @items
                    make Import {
                        $path ~ @path
                        $qualifier ~ @qualifier
                        $items @items
                    }
                    make TopItem.Import
                    make Result<TopItem, ParseError>.Success break
                }
                case Error -> { make Result<TopItem, ParseError>.Error break }
            }
        }
        case TOKEN_FN -> {
            $parser advance match {
                case None -> { $parser "expected an identifier" abort<TopItem> break }
                case Some -> {}
            } @name
            $name Token-ty match {
                case TOKEN_IDENT -> {}
                case _ -> { drop $parser "expected an identifer" abort<TopItem> break }
            }
            $parser advance match {
                case None -> { $parser "expected `(`, `<` or a string" abort<TopItem> break }
                case Some -> {}
            } @paren-or-export
            $paren-or-export Token-ty match {
                case TOKEN_STRING -> {
                    $parser advance match {
                        case None -> { $parser "expected `(` or `<`" abort<TopItem> break }
                        case Some -> {}
                    } @paren
                    $paren Token-ty match {
                        case TOKEN_LEFT_PAREN -> {}
                        case TOKEN_LEFT_TRIANGLE -> {}
                        case _ -> { drop $parser "expected `(`" abort<TopItem> break }
                    }
                    $paren-or-export ~ make Maybe<Token>.Some $paren
                }
                case TOKEN_LEFT_PAREN -> { make Maybe<Token>.None $paren-or-export }
                case _ -> { drop $parser "expected `(` or a string" abort<TopItem> break }
            } @paren @export
            $parser $paren signature match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @signature

            $parser advance match {
                case None -> { $parser "expected `{`" abort<TopItem> break }
                case Some -> {}
            } @brace
            $parser $brace words match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @body
            $parser "TODO Function" abort<TopItem>
        }
        case _ -> { drop $parser "TODO" abort<TopItem> }
    }
} }

fn words(parser: .Parser, token: .Token) -> Result<Array<Word>, ParseError> { block {
    Array:new<Word> @words
    loop {
        $parser advance match {
            case None -> { $parser "expected `}` or a word" abort<Array<Word>> break }
            case Some -> {}
        } @token
        $token Token-ty match {
            case TOKEN_RIGHT_BRACE -> {
                $words make Result<Array<Word>, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser $token word match {
            case Error -> {
                2 Fmt:to-fd @fmt
                &fmt \Word-format &words Array:format-multi-line<Word>
                2 IO:newline
                make Result<Array<Word>, ParseError>.Error break
            }
            case Success -> {}
        } @word
        $parser.arena &words $word Array:push<Word>
    }
} }
fn word(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    $token Token-ty match {
        case TOKEN_IDENT -> { $parser $token call break }
        case TOKEN_STRING -> { $token ~ make Word.String }
        case TOKEN_AT -> { $parser init-locl break }
        case TOKEN_AMPERSAND -> { $parser ref-locl break }
        case TOKEN_DOLLAR -> { $parser get-locl break }
        case TOKEN_NUMBER -> { $token ~ make Word.Number }
        case TOKEN_IF -> { $parser $token iff break }
        case _ -> {
            drop
            $parser "word TODO" abort<Word> break
        }
    } make Result<Word, ParseError>.Success
} }

fn expect-token(parser: .Parser, ty: TokenTy) -> Result<.Token, ParseError> {
    $parser advance match {
        case None -> {
            $parser.arena Arena:temp @arena @save
            $arena "expected `" ByteArray:copy @message
            $arena &message $ty TokenTy-name ByteArray:push
            $arena &message "`" ByteArray:push
            $parser &message ByteArray:unpack abort<.Token>
            $arena $save Arena:restore
        }
        case Some -> {
            Core:dup<.Token> Token-ty $ty /= if {
                drop
                $parser.arena Arena:temp @arena @save
                $arena "expected `" ByteArray:copy @message
                $arena &message $ty TokenTy-name ByteArray:push
                $arena &message "`" ByteArray:push
                $parser &message ByteArray:unpack abort<.Token>
                $arena $save Arena:restore
            } else {
                make Result<.Token, ParseError>.Success
            }
        }
    }
}

fn iff(parser: .Parser, start: .Token) -> Result<Word, ParseError> { block {
    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @brace
    $parser $brace words match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @if-words
    $parser peek match {
        case None -> { $start ~ $if-words Array:new<Word> make If make Word.If make Result<Word, ParseError>.Success break }
        case Some -> {}
    } Token-ty match {
        case TOKEN_ELSE -> {}
        case _ -> { drop $start ~ $if-words Array:new<Word> make If make Word.If make Result<Word, ParseError>.Success break }
    }
    $parser make TokenTy.TOKEN_LEFT_BRACE expect-token match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @brace
    $parser $brace words match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @else-words
    $start ~ $if-words $else-words make If make Word.If make Result<Word, ParseError>.Success
} }

fn call(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    $parser peek match {
        case None -> { $token ~ make Word.Call make Result<Word, ParseError>.Success break }
        case Some -> {}
    } @colon
    $colon Token-ty match {
        case TOKEN_COLON -> { $parser advance assert-some<.Token> drop }
        case _ -> { drop $token ~ make Word.Call make Result<Word, ParseError>.Success break }
    }
    $parser advance match {
        case Some -> {}
        case None -> { $parser "expected an identifier" abort<Word> break }
    } @name
    $name Token-ty match {
        case TOKEN_IDENT -> {}
        case _ -> { drop $parser "expected an identifier" abort<Word> break }
    }
    $token ~ $name ~ make ForeignCall make Word.ForeignCall make Result<Word, ParseError>.Success
} }

fn fields(parser: .Parser) -> Result<Array<Token>, ParseError> {
    Array:new<Token> @fields
    loop {
        $parser peek-immediate match {
            case None -> { $fields make Result<Array<Token>, ParseError>.Success break }
            case Some -> {}
        } @dot
        $dot Token-ty match {
            case TOKEN_DOT -> { $parser advance-immediate assert-some<.Token> drop }
            case TOKEN_SPACE -> { $fields make Result<Array<Token>, ParseError>.Success break }
            case _ -> { drop $parser "expected `.`" abort<Array<Token>> break }
        }
        $parser advance-immediate match {
            case None -> { $parser "expected an identifier" abort<Array<Token>> break }
            case Some -> {}
        } ~ @field
        &field Token-ty match {
            case TOKEN_IDENT -> {}
            case _ -> { drop $parser "expected an identifier" abort<Array<Token>> break }
        }
        $parser.arena &fields $field Array:push<Token>
    }
}

fn ident(parser: .Parser) -> Result<Token, ParseError> { block {
    $parser advance match {
        case None -> { $parser "expected an identifier" abort<Token> break }
        case Some -> {}
    } @ident
    $ident Token-ty match {
        case TOKEN_IDENT -> {}
        case _ -> { drop $parser "expected an identifier" abort<Token> break }
    }
    $ident ~ make Result<Token, ParseError>.Success
} }

fn ref-locl(parser: .Parser) -> Result<Word, ParseError> { block {
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @ident
    $parser fields match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $ident flip make RefLocal
    make Word.RefLocal make Result<Word, ParseError>.Success
} }

fn get-locl(parser: .Parser) -> Result<Word, ParseError> { block {
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @ident
    $parser fields match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $ident flip make GetLocal
    make Word.GetLocal make Result<Word, ParseError>.Success
} }

fn init-locl(parser: .Parser) -> Result<Word, ParseError> { block {
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } make Word.InitLocal make Result<Word, ParseError>.Success
} }

fn generic-params(parser: .Parser, token: .Token) -> Result<Array<Token>, ParseError> { block {
    Array:new<Token> @generic-params
    loop {
        $parser advance match {
            case None -> { $parser "expected `>` or an identifier" abort<Array<Token>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_RIGHT_TRIANGLE -> {
                $generic-params make Result<Array<Token>, ParseError>.Success break
            }
            case TOKEN_IDENT -> {}
            case _ -> { drop $parser "expected `>` or an identifier" abort<Array<Token>> break }
        }
        $parser.arena &generic-params $next ~ Array:push<Token>
        $parser peek match {
            case Some -> { Token-ty match {
                case TOKEN_COMMA -> { $parser advance drop }
                case _ -> { drop $parser "expected `,` or `>`" abort<Array<Token>> break }
            } }
            case None -> {}
        }
    }
} }

fn signature(parser: .Parser, token: .Token) -> Result<Signature, ParseError> { block {
    $token Token-ty match {
        case TOKEN_LEFT_TRIANGLE -> {
            $parser $token generic-params match {
                case Error -> { make Result<Signature, ParseError>.Error break }
                case Success -> {}
            }
        }
        case _ -> { drop Array:new<Token> }
    } @generic-params

    Array:new<NamedType> @params
    loop {
        $parser advance match {
            case None -> { $parser "expected `)` or an identifier" abort<Array<NamedType>> break }
            case Some -> {}
        } @paren-or-ident
        $paren-or-ident Token-ty match {
            case TOKEN_RIGHT_PAREN -> {
                Array:new<NamedType> make Result<Array<NamedType>, ParseError>.Success break
            }
            case TOKEN_IDENT -> {}
            case _ -> { drop $parser "expected `)` or an identifer" abort<Array<NamedType>> break }
        }
        $parser advance match {
            case None -> { $parser "expected a type" abort<Array<NamedType>> break }
            case Some -> {}
        } $parser flip type match {
            case Error -> { make Result<Array<NamedType>, ParseError>.Error break }
            case Success -> {}
        } @type
        $parser.arena &params $paren-or-ident ~ $type make NamedType Array:push<NamedType>
        $parser peek match {
            case Some -> { Token-ty match {
                case TOKEN_COMMA -> { $parser advance drop }
                case _ -> { drop $parser "expected `,` or `)`" abort<Array<NamedType>> break }
            } }
            case None -> {}
        }
    } match {
        case Error -> { make Result<Signature, ParseError>.Error break }
        case Success -> {}
    } @params

    $parser peek match {
        case None -> { $generic-params $params Array:new<Type> make Signature make Result<Signature, ParseError>.Success break }
        case Some -> {}
    } @arrow
    $arrow Token-ty match {
        case TOKEN_ARROW -> {}
        case _ -> { drop $generic-params $params Array:new<Type> make Signature make Result<Signature, ParseError>.Success break }
    }
    Array:new<Type> @returns
    loop {
        $parser peek match {
            case None -> { $parser "expected a type or `{`" abort<Array<Type>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_LEFT_BRACE -> {
                $returns make Result<Array<Type>, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser $next type match {
            case Error -> { make Result<Array<Type>, ParseError>.Error break }
            case Success -> {}
        } @type
        $parser.arena &returns $type Array:push<Type>

        $parser peek match {
            case None -> {
                $returns make Result<Array<Type>, ParseError>.Success break
            }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_COMMA -> { $parser advance drop }
            case TOKEN_LEFT_BRACE -> {
                $returns make Result<Array<Type>, ParseError>.Success break
            }
            case _ -> {
                drop $parser "expected `,` or `{`" abort<Array<Type>> break
            }
        }
    } match {
        case Error -> { make Result<Signature, ParseError>.Error break }
        case Success -> {}
    } @returns
    $generic-params $params $returns make Signature make Result<Signature, ParseError>.Success
} }

fn type(parser: .Parser, token: .Token) -> Result<Type, ParseError> { block {
    $token Token-ty match {
        case TOKEN_BOOL -> { make Type.Bool }
        case TOKEN_I32 -> { make Type.I32 }
        case TOKEN_I64 -> { make Type.I64 }
        case TOKEN_IDENT -> {
            $parser peek match {
                case None -> { $token ~ make Type.Complex }
                case Some -> {
                    @next
                    $next Token-ty match {
                        case TOKEN_COLON -> {
                            $token ~ $parser advance assert-some<.Token> ~ make ForeignType make Type.Foreign
                        }
                        case _ -> { drop $token ~ make Type.Complex }
                    }
                }
            }
        }
        case _ -> { drop $parser "expected a type" abort<Type> break }
    } make Result<Type, ParseError>.Success
} }

