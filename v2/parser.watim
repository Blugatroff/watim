import "../std/core.watim" as Core (exit)
import "../std/maybe.watim" as Maybe (Maybe, assert-some)
import "../std/io.watim" as IO
import "../std/arena.watim" as Arena (Arena)
import "../std/array.watim" as Array (Array)
import "../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../std/byte-array.watim" as ByteArray (ByteArray)
import "../std/fmt.watim" as FMT (Formatter-to-fd)

import "./lexer.watim" as Lexer (Token, TokenTy, Token-ty, Token-print, Token-location, Token-column)

struct Import {
    path: Token
    qualifier: Token
    items: Array<Token>
}
fn Import-print(fd: i32, self: .Import) -> i32 { block {
    $fd "Import " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd &self.path Token-print Core:dup<i32> 0 /= if { break } drop
    $fd " " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd &self.qualifier Token-print Core:dup<i32> 0 /= if { break } drop
    $fd " [" IO:write-all Core:dup<i32> 0 /= if { break } drop
    0 @i
    loop {
        $i $self.items.len = if { 0 break }
        $fd &self.items $i Array:get<Token> Token-print Core:dup<i32> 0 /= if { break } drop
        $i 1 + $self.items.len /= if {
            $fd ", " IO:write-all Core:dup<i32> 0 /= if { break } drop
        }
        $i 1 + #i
    } Core:dup<i32> 0 /= if { break } drop
    $fd "]" IO:write-all
} }

struct ForeignType {
    module: Token
    name: Token
}

variant Type {
    case Bool
    case I32
    case I64
    case Ptr -> .Type
    case Complex -> Token
    case Foreign -> ForeignType
}

struct NamedType {
    name: Token
    type: Type
}

struct ForeignCall {
    module: Token
    name: Token
}
fn ForeignCall-print(fd: i32, self: .ForeignCall) -> i32 { block {
    $fd "(ForeignCall " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd &self.module Token-print Core:dup<i32> 0 /= if { break } drop
    $fd " " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd &self.name Token-print Core:dup<i32> 0 /= if { break } drop
    $fd ")" IO:write-all
} }

struct RefLocal {
    ident: Token
    fields: Array<Token>
}
fn RefLocal-print(fd: i32, self: .RefLocal) -> i32 { block {
    $fd "(RefLocal " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd &self.ident Token-print Core:dup<i32> 0 /= if { break } drop
    $fd " " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd \Token-print &self.fields Array:print<Token> Core:dup<i32> 0 /= if { break } drop
    $fd ")" IO:write-all
} }

struct GetLocal {
    ident: Token
    fields: Array<Token>
}
fn GetLocal-print(fd: i32, self: .GetLocal) -> i32 { block {
    $fd "(GetLocal " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd &self.ident Token-print Core:dup<i32> 0 /= if { break } drop
    $fd " " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd \Token-print &self.fields Array:print<Token> Core:dup<i32> 0 /= if { break } drop
    $fd ")" IO:write-all
} }

variant Word {
    case Call -> Token
    case ForeignCall -> ForeignCall
    case String -> Token
    case InitLocal -> Token
    case RefLocal -> RefLocal
    case GetLocal -> GetLocal
    case Number -> Token
}
fn Word-print(fd: i32, self: .Word) -> i32 { block {
    $self match {
        case Call -> { "Call" }
        case ForeignCall -> { $fd flip ForeignCall-print break }
        case String -> { "String" }
        case InitLocal -> { "InitLocal" }
        case RefLocal -> { $fd flip RefLocal-print break }
        case GetLocal -> { $fd flip GetLocal-print break }
        case Number -> { "Number" }
    } @name-len @name-ptr
    $fd "(" IO:write-all Core:dup<i32> 0 /= if { flip drop break } drop
    $fd $name-ptr $name-len IO:write-all Core:dup<i32> 0 /= if { flip drop break } drop
    $fd " " IO:write-all Core:dup<i32> 0 /= if { flip drop break } drop
    $fd flip Token-print Core:dup<i32> 0 /= if { break } drop
    $fd ")" IO:write-all
} }

struct Signature {
    generic-parameters: Array<Token>
    parameters: Array<NamedType>
    returns: Array<Type>
}
fn Signature-print(fd: i32, self: .Signature) -> i32 { block {
    $fd "Signature " IO:write-all Core:dup<i32> 0 /= if { break } drop
    0
} }

struct Function {
    name: Token
    export: Maybe<Token>
    signature: Signature
    words: Array<Word>
}
fn Function-print(fd: i32, self: .Function) -> i32 { block {
    $fd "Function " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd &self.name Token-print Core:dup<i32> 0 /= if { break } drop
    $fd " " IO:write-all Core:dup<i32> 0 /= if { break } drop
    &self.export match {
        case None -> { }
        case Some -> {
            $fd flip Token-print Core:dup<i32> 0 /= if { break } drop
            $fd " " IO:write-all Core:dup<i32> 0 /= if { break } drop
        }
    }
    $fd &self.signature Signature-print Core:dup<i32> 0 /= if { break } drop
    0 @i
    loop {
        $i $self.words.len = if { 0 break }
        $fd "\n  " IO:write-all Core:dup<i32> 0 /= if { break } drop
        $fd &self.words $i Array:get<Word> Word-print Core:dup<i32> 0 /= if { break } drop
        $i 1 + #i
    } Core:dup<i32> 0 /= if { break }
} }

variant TopItem {
    case Import -> Import
    case Function -> Function
}
fn TopItem-print(fd: i32, self: .TopItem) -> i32 { block {
    $fd $self match {
        case Import -> { Import-print }
        case Function -> { Function-print }
    } }
}

struct Parser {
    arena: .Arena
    tokens: Array<Token>
    cursor: i32
}
fn eof(parser: .Parser) -> bool {
    $parser.cursor $parser.tokens.len ge
}
fn peek-immediate(parser: .Parser) -> Maybe<.Token> {
    $parser.cursor $parser.tokens.len = if {
        make Maybe<.Token>.None
    } else {
        &parser.tokens $parser.cursor Array:get<Token> make Maybe<.Token>.Some
    }
}
fn peek(parser: .Parser) -> Maybe<.Token> {
    $parser.cursor @i
    loop {
        $parser.tokens.len $i = if { make Maybe<.Token>.None break }
        &parser.tokens $i Array:get<Token> @token
        $i 1 + #i
        $token Token-ty match {
            case TOKEN_SPACE -> {}
            case _ -> { drop $token make Maybe<.Token>.Some break }
        }
    }
}
fn advance-immediate(parser: .Parser) -> Maybe<.Token> {
    $parser.cursor $parser.tokens.len = if {
        make Maybe<.Token>.None
    } else {
        &parser.tokens $parser.cursor Array:get<Token> make Maybe<.Token>.Some
        $parser.cursor 1 + #parser.cursor
    }
}
fn advance(parser: .Parser) -> Maybe<.Token> {
    loop {
        $parser.tokens.len $parser.cursor = if { make Maybe<.Token>.None break }
        &parser.tokens $parser.cursor Array:get<Token> @token
        $parser.cursor 1 + #parser.cursor
        $token Token-ty match {
            case TOKEN_SPACE -> {}
            case _ -> { drop $token make Maybe<.Token>.Some break }
        }
    }
}
fn abort<T>(parser: .Parser, message-ptr: .i32, message-len: i32) -> Result<T, ParseError> {
    $parser.tokens.len 0 = if {
        0 0 / drop // parsing an empty file always should always succeed
    }
    &parser.tokens $parser.cursor 0 = if { 0 } else { $parser.cursor 1 - } Array:get<Token> @token
    $token Token-location $parser.arena $message-ptr $message-len ByteArray:copy make ParseError
    make Result<T, ParseError>.Error
}

variant Result<T, E> {
    case Success -> T
    case Error -> E
}

struct ParseError {
    line: i32
    column: i32
    message: ByteArray
}
fn ParseError-print(fd: i32, self: ParseError, file-path-ptr: .i32, file-path: i32) -> i32 { block {
    $fd $file-path-ptr $file-path IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd ":" IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.line IO:print Core:dup<i32> 0 /= if { break } drop
    $fd ":" IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd $self.column IO:print Core:dup<i32> 0 /= if { break } drop
    $fd " " IO:write-all Core:dup<i32> 0 /= if { break } drop
    $fd &self.message ByteArray:unpack IO:write-all
} }

fn parse(arena: .Arena, tokens: Array<Token>) -> Result<Array<TopItem>, ParseError> {
    Array:new<TopItem> @items
    $arena $tokens 0 make Parser @parser
    loop {
        &parser advance match {
            case None -> { $items make Result<Array<TopItem>, ParseError>.Success break }
            case Some -> {}
        }
        &parser flip top-item match {
            case Success -> { @top-item $arena &items $top-item Array:push<TopItem> }
            case Error -> {
                2 flip "DEBUG" ParseError-print IO:check
                2 IO:newline
                $items make Result<Array<TopItem>, ParseError>.Success break
                // make Result<Array<TopItem>, ParseError>.Error break
            }
        }
    }
}

fn top-item(parser: .Parser, token: .Token) -> Result<TopItem, ParseError> { block {
    $token Token-ty match {
        case TOKEN_IMPORT -> {
            $parser advance match {
                case None -> { $parser "expected a file path" abort<TopItem> break }
                case Some -> {}
            } @token
            $token Token-ty match {
                case TOKEN_STRING -> { $token }
                case _ -> { drop $parser "expected a file path" abort<TopItem> break }
            } @path

            $parser advance match {
                case None -> { $parser "expected `as`" abort<TopItem> break }
                case Some -> {}
            } @token
            $token Token-ty match {
                case TOKEN_AS -> { }
                case _ -> { drop $parser "expected `as`" abort<TopItem> break }
            }
            $parser advance match {
                case None -> { $parser "expected an identifier" abort<TopItem> break }
                case Some -> {}
            } @token
            $token Token-ty match {
                case TOKEN_IDENT -> { $token }
                case _ -> { drop $parser "expected an identifier" abort<TopItem> break }
            } @qualifier

            $parser peek match {
                case None -> { 1 1 = }
                case Some -> { Token-ty make TokenTy.TOKEN_LEFT_PAREN /= }
            } if {
                make Import {
                    $path ~ @path
                    $qualifier ~ @qualifier
                    Array:new<Token> @items
                }
                make TopItem.Import
                make Result<TopItem, ParseError>.Success break
            }
            Array:new<Token> @items
            $parser advance drop // drop the `(`
            loop {
                $parser advance match {
                    case None -> { $parser "expected `)` or an identifier" abort<Array<Token>> break }
                    case Some -> {}
                } @item
                $item Token-ty match {
                    case TOKEN_RIGHT_PAREN -> {
                        $items make Result<Array<Token>, ParseError>.Success break
                    }
                    case TOKEN_IDENT -> {
                        $parser.arena &items $item ~ Array:push<Token>
                        $parser peek match {
                            case None -> { $parser "expected `)` or `,`" abort<Array<Token>> break }
                            case Some -> { }
                        } @comma
                        $comma Token-ty match {
                            case TOKEN_COMMA -> { $parser advance drop }
                            case TOKEN_RIGHT_PAREN -> { 
                                $parser advance drop
                                $items make Result<Array<Token>, ParseError>.Success break
                            }
                            case _ -> {
                                drop $parser "expected `)` or `,`" abort<Array<Token>> break
                            }
                        }
                    }
                    case _ -> {
                        drop $parser "expected `)` or an identifier" abort<Array<Token>> break
                    }
                }
            } match {
                case Success -> {
                    @items
                    make Import {
                        $path ~ @path
                        $qualifier ~ @qualifier
                        $items @items
                    }
                    make TopItem.Import
                    make Result<TopItem, ParseError>.Success break
                }
                case Error -> { make Result<TopItem, ParseError>.Error break }
            }
        }
        case TOKEN_FN -> {
            $parser advance match {
                case None -> { $parser "expected an identifier" abort<TopItem> break }
                case Some -> {}
            } @name
            $name Token-ty match {
                case TOKEN_IDENT -> {}
                case _ -> { drop $parser "expected an identifer" abort<TopItem> break }
            }
            $parser advance match {
                case None -> { $parser "expected `(`, `<` or a string" abort<TopItem> break }
                case Some -> {}
            } @paren-or-export
            $paren-or-export Token-ty match {
                case TOKEN_STRING -> {
                    $parser advance match {
                        case None -> { $parser "expected `(` or `<`" abort<TopItem> break }
                        case Some -> {}
                    } @paren
                    $paren Token-ty match {
                        case TOKEN_LEFT_PAREN -> {}
                        case TOKEN_LEFT_TRIANGLE -> {}
                        case _ -> { drop $parser "expected `(`" abort<TopItem> break }
                    }
                    $paren-or-export ~ make Maybe<Token>.Some $paren
                }
                case TOKEN_LEFT_PAREN -> { make Maybe<Token>.None $paren-or-export }
                case _ -> { drop $parser "expected `(` or a string" abort<TopItem> break }
            } @paren @export
            $parser $paren signature match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @signature

            $parser advance match {
                case None -> { $parser "expected `{`" abort<TopItem> break }
                case Some -> {}
            } @brace
            $parser $brace words match {
                case Error -> { make Result<TopItem, ParseError>.Error break }
                case Success -> {}
            } @body
            $parser "TODO Function" abort<TopItem>
        }
        case _ -> { drop $parser "TODO" abort<TopItem> }
    }
} }

fn words(parser: .Parser, token: .Token) -> Result<Array<Word>, ParseError> { block {
    Array:new<Word> @words
    loop {
        $parser advance match {
            case None -> { $parser "expected `}` or a word" abort<Array<Word>> break }
            case Some -> {}
        } @token
        $token Token-ty match {
            case TOKEN_RIGHT_BRACE -> {
                $words make Result<Array<Word>, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser $token word match {
            case Error -> {
                2 \Word-print &words Array:print-multi-line<Word> IO:check
                2 IO:newline
                make Result<Array<Word>, ParseError>.Error break
            }
            case Success -> {}
        } @word
        $parser.arena &words $word Array:push<Word>
    }
} }
fn word(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    $token Token-ty match {
        case TOKEN_IDENT -> { $parser $token call break }
        case TOKEN_STRING -> { $token ~ make Word.String }
        case TOKEN_AT -> { $parser init-locl break }
        case TOKEN_AMPERSAND -> { $parser ref-locl break }
        case TOKEN_DOLLAR -> { $parser get-locl break }
        case TOKEN_NUMBER -> { $token ~ make Word.Number }
        case _ -> {
            drop
            $parser "word TODO" abort<Word> break
        }
    } make Result<Word, ParseError>.Success
} }

fn call(parser: .Parser, token: .Token) -> Result<Word, ParseError> { block {
    $parser peek match {
        case None -> { $token ~ make Word.Call make Result<Word, ParseError>.Success break }
        case Some -> {}
    } @colon
    $colon Token-ty match {
        case TOKEN_COLON -> { $parser advance assert-some<.Token> drop }
        case _ -> { drop $token ~ make Word.Call make Result<Word, ParseError>.Success break }
    }
    $parser advance match {
        case Some -> {}
        case None -> { $parser "expected an identifier" abort<Word> break }
    } @name
    $name Token-ty match {
        case TOKEN_IDENT -> {}
        case _ -> { drop $parser "expected an identifier" abort<Word> break }
    }
    $token ~ $name ~ make ForeignCall make Word.ForeignCall make Result<Word, ParseError>.Success
} }

fn fields(parser: .Parser) -> Result<Array<Token>, ParseError> {
    Array:new<Token> @fields
    loop {
        $parser peek-immediate match {
            case None -> { $fields make Result<Array<Token>, ParseError>.Success break }
            case Some -> {}
        } @dot
        $dot Token-ty match {
            case TOKEN_DOT -> { $parser advance-immediate assert-some<.Token> drop }
            case TOKEN_SPACE -> { $fields make Result<Array<Token>, ParseError>.Success break }
            case _ -> { drop $parser "expected `.`" abort<Array<Token>> break }
        }
        $parser advance-immediate match {
            case None -> { $parser "expected an identifier" abort<Array<Token>> break }
            case Some -> {}
        } ~ @field
        &field Token-ty match {
            case TOKEN_IDENT -> {}
            case _ -> { drop $parser "expected an identifier" abort<Array<Token>> break }
        }
        $parser.arena &fields $field Array:push<Token>
    }
}

fn ident(parser: .Parser) -> Result<Token, ParseError> { block {
    $parser advance match {
        case None -> { $parser "expected an identifier" abort<Token> break }
        case Some -> {}
    } @ident
    $ident Token-ty match {
        case TOKEN_IDENT -> {}
        case _ -> { drop $parser "expected an identifier" abort<Token> break }
    }
    $ident ~ make Result<Token, ParseError>.Success
} }

fn ref-locl(parser: .Parser) -> Result<Word, ParseError> { block {
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @ident
    $parser fields match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $ident flip make RefLocal
    make Word.RefLocal make Result<Word, ParseError>.Success
} }

fn get-locl(parser: .Parser) -> Result<Word, ParseError> { block {
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } @ident
    $parser fields match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    }
    $ident flip make GetLocal
    make Word.GetLocal make Result<Word, ParseError>.Success
} }

fn init-locl(parser: .Parser) -> Result<Word, ParseError> { block {
    $parser ident match {
        case Error -> { make Result<Word, ParseError>.Error break }
        case Success -> {}
    } make Word.InitLocal make Result<Word, ParseError>.Success
} }

fn generic-params(parser: .Parser, token: .Token) -> Result<Array<Token>, ParseError> { block {
    Array:new<Token> @generic-params
    loop {
        $parser advance match {
            case None -> { $parser "expected `>` or an identifier" abort<Array<Token>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_RIGHT_TRIANGLE -> {
                $generic-params make Result<Array<Token>, ParseError>.Success break
            }
            case TOKEN_IDENT -> {}
            case _ -> { drop $parser "expected `>` or an identifier" abort<Array<Token>> break }
        }
        $parser.arena &generic-params $next ~ Array:push<Token>
        $parser peek match {
            case Some -> { Token-ty match {
                case TOKEN_COMMA -> { $parser advance drop }
                case _ -> { drop $parser "expected `,` or `>`" abort<Array<Token>> break }
            } }
            case None -> {}
        }
    }
} }

fn signature(parser: .Parser, token: .Token) -> Result<Signature, ParseError> { block {
    $token Token-ty match {
        case TOKEN_LEFT_TRIANGLE -> {
            $parser $token generic-params match {
                case Error -> { make Result<Signature, ParseError>.Error break }
                case Success -> {}
            }
        }
        case _ -> { drop Array:new<Token> }
    } @generic-params

    Array:new<NamedType> @params
    loop {
        $parser advance match {
            case None -> { $parser "expected `)` or an identifier" abort<Array<NamedType>> break }
            case Some -> {}
        } @paren-or-ident
        $paren-or-ident Token-ty match {
            case TOKEN_RIGHT_PAREN -> {
                Array:new<NamedType> make Result<Array<NamedType>, ParseError>.Success break
            }
            case TOKEN_IDENT -> {}
            case _ -> { drop $parser "expected `)` or an identifer" abort<Array<NamedType>> break }
        }
        $parser advance match {
            case None -> { $parser "expected a type" abort<Array<NamedType>> break }
            case Some -> {}
        } $parser flip type match {
            case Error -> { make Result<Array<NamedType>, ParseError>.Error break }
            case Success -> {}
        } @type
        $parser.arena &params $paren-or-ident ~ $type make NamedType Array:push<NamedType>
        $parser peek match {
            case Some -> { Token-ty match {
                case TOKEN_COMMA -> { $parser advance drop }
                case _ -> { drop $parser "expected `,` or `)`" abort<Array<NamedType>> break }
            } }
            case None -> {}
        }
    } match {
        case Error -> { make Result<Signature, ParseError>.Error break }
        case Success -> {}
    } @params

    $parser peek match {
        case None -> { $generic-params $params Array:new<Type> make Signature make Result<Signature, ParseError>.Success break }
        case Some -> {}
    } @arrow
    $arrow Token-ty match {
        case TOKEN_ARROW -> {}
        case _ -> { drop $generic-params $params Array:new<Type> make Signature make Result<Signature, ParseError>.Success break }
    }
    Array:new<Type> @returns
    loop {
        $parser peek match {
            case None -> { $parser "expected a type or `{`" abort<Array<Type>> break }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_LEFT_BRACE -> {
                $returns make Result<Array<Type>, ParseError>.Success break
            }
            case _ -> { drop }
        }
        $parser $next type match {
            case Error -> { make Result<Array<Type>, ParseError>.Error break }
            case Success -> {}
        } @type
        $parser.arena &returns $type Array:push<Type>

        $parser peek match {
            case None -> {
                $returns make Result<Array<Type>, ParseError>.Success break
            }
            case Some -> {}
        } @next
        $next Token-ty match {
            case TOKEN_COMMA -> { $parser advance drop }
            case TOKEN_LEFT_BRACE -> {
                $returns make Result<Array<Type>, ParseError>.Success break
            }
            case _ -> {
                drop $parser "expected `,` or `{`" abort<Array<Type>> break
            }
        }
    } match {
        case Error -> { make Result<Signature, ParseError>.Error break }
        case Success -> {}
    } @returns
    $generic-params $params $returns make Signature make Result<Signature, ParseError>.Success
} }

fn type(parser: .Parser, token: .Token) -> Result<Type, ParseError> { block {
    $token Token-ty match {
        case TOKEN_BOOL -> { make Type.Bool }
        case TOKEN_I32 -> { make Type.I32 }
        case TOKEN_I64 -> { make Type.I64 }
        case TOKEN_IDENT -> {
            $parser peek match {
                case None -> { $token ~ make Type.Complex }
                case Some -> {
                    @next
                    $next Token-ty match {
                        case TOKEN_COLON -> {
                            $token ~ $parser advance assert-some<.Token> ~ make ForeignType make Type.Foreign
                        }
                        case _ -> { drop $token ~ make Type.Complex }
                    }
                }
            }
        }
        case _ -> { drop $parser "expected a type" abort<Type> break }
    } make Result<Type, ParseError>.Success
} }

