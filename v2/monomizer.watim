import "../std/core.watim" as Core
import "../std/maybe.watim" as Maybe (Maybe, assert-none, assert-some)
import "../std/result.watim" as Result (Result)
import "../std/result.watim" as Result (Result)
import "../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../std/arena.watim" as Arena (Arena)
import "../std/array.watim" as Array (Array)
import "../std/map.watim" as Map (Map)
import "../std/fmt.watim" as Fmt (Formatter, ByteSlice-format)
import "../std/util.watim" as Util (i32-format, bool-format, i32-format-ref)
import "../std/io.watim" as IO

import "./logging.watim" as Logging
import "./lexer.watim" as Lexer (Token, Token-format)
import "./type.watim" as Resolved (
    ModuleId, ModuleId-format,
    CustomTypeHandle, CustomTypeHandle-eq, CustomTypeHandle-format
)
import "./env.watim" as Env (LocalId, LocalId-format)
import "./resolver.watim" as Resolved (
    StringWord, StringWord-format,
    VarId, VarId-format,
)

// =============================================================================
//  Monomorphized Types
// =============================================================================

struct TypeId {
    index: i32
}
fn TypeId-eq(a: .TypeId, b: .TypeId) -> bool {
    $a.index $b.index =
}
fn TypeId-format(fmt: .Formatter, self: .TypeId) {
    $fmt "(TypeId " Fmt:write
    $fmt $self.index i32-format
    $fmt ")" Fmt:write
}
fn TypeIds-eq(a: .Array<TypeId>, b: .Array<TypeId>) -> bool {
    \TypeId-eq $a $b Array:eq<TypeId>
}
fn TypeIds-format(fmt: .Formatter, self: .Array<TypeId>) {
    $fmt \TypeId-format $self Array:format<TypeId>
}

struct NamedTypeId {
    name: Token
    type: TypeId
}
fn NamedTypeId-eq(a: .NamedTypeId, b: .NamedTypeId) -> bool {
    &a.type &b.type TypeId-eq
}
fn NamedTypeId-format(fmt: .Formatter, self: .NamedTypeId) {
    $fmt "(NamedTypeId " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type TypeId-format
    $fmt ")" Fmt:write
}

struct FunType {
    parameters: Array<TypeId>
    returns: Array<TypeId>
}
fn FunType-format(fmt: .Formatter, self: .FunType) {
    $fmt "(FunType " Fmt:write
    $fmt \TypeId-format &self.parameters Array:format<TypeId>
    $fmt " " Fmt:write
    $fmt \TypeId-format &self.returns Array:format<TypeId>
    $fmt ")" Fmt:write
}

variant Type {
    case Bool
    case I32
    case I64
    case Ptr -> TypeId
    case Custom -> CustomTypeHandle
    case Fun -> FunType
    case Tuple -> Array<TypeId>
}
fn Type-eq(a: .Type, b: .Type) -> bool { block {
    $a !.i32 ~ $b !.i32 ~ /= if { // compare tags
        0 1 = break
    }
    $a match {
        case Ptr -> { $b match {
            case Ptr -> { flip TypeId-eq }
            case _ -> { drop drop 0 1 = }
        } }
        case Custom -> { $b match {
            case Custom -> { flip CustomTypeHandle-eq }
            case _ -> { drop drop 0 1 = }
        } }
        case Fun -> { @a $b match {
            case Fun -> {
                @b
                \TypeId-eq &a.parameters &b.parameters Array:eq<TypeId>
                \TypeId-eq &a.returns    &b.returns    Array:eq<TypeId> and
            }
            case _ -> { drop 0 1 = }
        } }
        case Tuple -> { \TypeId-eq flip $b match {
            case Tuple -> { Array:eq<TypeId> }
            case _ -> { drop drop drop 0 1 = }
        } }
        case _ -> { drop 1 1 = }
    }
} }
fn Type-format(fmt: .Formatter, self: .Type) { block {
    $fmt $self match {
        case Bool -> { "Bool" }
        case I32 -> { "I32" }
        case I64 -> { "I64" }
        case Ptr -> { $fmt "(Ptr " Fmt:write TypeId-format $fmt ")" Fmt:write break }
        case Custom -> {
            @handle
            "(CustomType " Fmt:write
            $fmt $handle.module.index i32-format
            $fmt " " Fmt:write
            $fmt $handle.index i32-format
            $fmt ")" Fmt:write break
        }
        case Fun -> { FunType-format break }
        case Tuple -> { \TypeId-format flip Array:format<TypeId> break }
    } Fmt:write
} }

variant CustomType {
    case Struct -> Struct
    case Variant -> Variant
}
fn CustomType-eq(a: .CustomType, b: .CustomType) -> bool {
    $a match {
        case Struct -> { $b match {
            case Struct -> { Struct-eq }
            case _ -> { drop drop 0 1 = }
        } }
        case Variant -> { $b match {
            case Variant -> { Variant-eq }
            case _ -> { drop drop 0 1 = }
        } }
    }
}
fn CustomType-format(fmt: .Formatter, self: .CustomType) {
    $fmt $self match {
        case Struct -> { Struct-format }
        case Variant -> { Variant-format }
    }
}


// =============================================================================
//  Monomorphized Type Definitions and Globals
// =============================================================================

struct Struct {
    name: Token
    fields: Array<NamedTypeId>
}
fn Struct-eq(a: .Struct, b: .Struct) -> bool {
    \NamedTypeId-eq &a.fields &b.fields Array:eq<NamedTypeId>
}
fn Struct-format(fmt: .Formatter, self: .Struct) {
    $fmt "(Struct\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "fields=" Fmt:write
    $fmt \NamedTypeId-format &self.fields Array:format-multi-line<NamedTypeId>
    $fmt Fmt:dedent
}

struct VariantCase {
    name: Token
    type: Maybe<TypeId>
}
fn VariantCase-eq(a: .VariantCase, b: .VariantCase) -> bool {
    &a.type match {
        case None -> { &b.type match {
            case None -> { 1 1 = }
            case Some -> { drop 0 1 = }
        } }
        case Some -> { &b.type match {
            case Some -> { TypeId-eq }
            case None -> { drop 0 1 = }
        } }
    }
}
fn VariantCase-format(fmt: .Formatter, self: .VariantCase) {
    $fmt "(VariantCase " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt \TypeId-format &self.type Maybe:format<TypeId>
    $fmt ")" Fmt:write
}

struct Variant {
    name: Token
    cases: Array<VariantCase>
}
fn Variant-eq(a: .Variant, b: .Variant) -> bool {
    \VariantCase-eq &a.cases &b.cases Array:eq<VariantCase>
}
fn Variant-format(fmt: .Formatter, self: .Variant) {
    $fmt "(Variant\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "cases=" Fmt:write
    $fmt \VariantCase-format &self.cases Array:format-multi-line<VariantCase>
    $fmt Fmt:dedent
}

struct Global {
    name: Token
    type: TypeId
    reffed: bool
}
fn Global-format(fmt: .Formatter, self: .Global) {
    $fmt "(Global " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt $self.reffed bool-format
    $fmt ")" Fmt:write
}


// =============================================================================
//  Monomorphized Extern and Function
// =============================================================================

struct Extern {
    name: Token
    extrn-module: ByteSlice
    extrn-name: ByteSlice
    signature: Signature
}
fn Extern-format(fmt: .Formatter, self: .Extern) {
    $fmt "(Extern\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "extrn-module=" Fmt:write
    $fmt &self.extrn-module ByteSlice-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "extrn-name=" Fmt:write
    $fmt &self.extrn-name ByteSlice-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "signature=" Fmt:write
    $fmt &self.signature Signature-format
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

struct Function {
    name: Token
    export: Maybe<Token>
    signature: Signature
    words: Array<Word>
}
fn Function-format(fmt: .Formatter, self: .Function) {
    $fmt "(Function\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "export=" Fmt:write
    $fmt \Token-format &self.export Maybe:format<Token>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "signature=" Fmt:write
    $fmt &self.signature Signature-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "words=" Fmt:write
    $fmt \Word-format &self.words Array:format-multi-line<Word>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}
fn Function-ref-format(fmt: .Formatter, self: ..Function) {
    $fmt $self ~ Function-format
}

struct Signature {
    parameters: Array<NamedTypeId>
    returns: Array<TypeId>
}
fn Signature-format(fmt: .Formatter, self: .Signature) {
    $fmt "(Signature " Fmt:write
    $fmt \NamedTypeId-format &self.parameters Array:format-multi-line<NamedTypeId>
    $fmt " " Fmt:write
    $fmt \TypeId-format &self.returns Array:format-multi-line<TypeId>
    $fmt ")" Fmt:write
}

struct FunctionHandle {
    module: ModuleId
    index: i32
    instance: i32
}
fn FunctionHandle-format(fmt: .Formatter, self: .FunctionHandle) {
    $fmt "(FunctionHandle " Fmt:write
    $fmt $self.module.index i32-format
    $fmt " " Fmt:write
    $fmt $self.index i32-format
    $fmt " " Fmt:write
    $fmt $self.instance i32-format
    $fmt ")" Fmt:write
}
fn FunctionHandle-eq(self: .FunctionHandle, other: .FunctionHandle) -> bool {
    $self.module.index $other.module.index =
    $self.index $other.index = and
    $self.instance $other.instance = and
}

// =============================================================================
//  Output of Monomorphization pass
// =============================================================================

struct Monomized {
    types: Array<Maybe<Key>>
    modules: Map<ByteSlice, Module>
    sizes: Array<i32>
    function-table: Array<FunctionHandle>
}
fn Monomized-format(fmt: .Formatter, self: .Monomized) {
    $fmt "(Monomized\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "types=" Fmt:write
    $fmt \MaybeKey-format &self.types Array:format-multi-line<Maybe<Key>>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "sizes=" Fmt:write
    $fmt \i32-format-ref &self.sizes Array:format<i32>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "modules=" Fmt:write
    $fmt \ByteSlice-format \Module-format &self.modules Map:format-multi-line<ByteSlice, Module>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "function-table=" Fmt:write
    $fmt \FunctionHandle-format &self.function-table Array:format<FunctionHandle>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

struct Module {
    custom-types: Array<CustomType>
    globals: Array<Global>
    externs: Array<Extern>
    static-data: ByteSlice
    functions: Array<Array<.Function>>
}
fn Module-format(fmt: .Formatter, self: .Module) {
    $fmt "(Module\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "custom-types=" Fmt:write
    $fmt \CustomType-format &self.custom-types Array:format-multi-line<CustomType>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "globals=" Fmt:write
    $fmt \Global-format &self.globals Array:format-multi-line<Global>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "externs=" Fmt:write
    $fmt \Extern-format &self.externs Array:format-multi-line<Extern>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "functions=" Fmt:write
    $fmt \FunctionArray-format &self.functions Array:format-multi-line<Array<.Function>>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}
fn FunctionArray-format(fmt: .Formatter, self: .Array<.Function>) {
    $fmt \Function-ref-format $self Array:format-multi-line<.Function>
}


// =============================================================================
//  Context for monomorphization
// =============================================================================

struct Ctx {
    arena: .Arena
    module-id: ModuleId
    resolved-modules: .Array<Resolved:Module>
    types: .Array<Maybe<Key>>
    function-table: .Array<FunctionHandle>
    custom-types: Array<CustomType>
    functions: .Array<Array<Map<Array<TypeId>, .Maybe<Function>>>>
}
fn pre-insert-function(ctx: .Ctx, handle: Resolved:FunctionHandle, generic-arguments: Array<TypeId>) -> .Maybe<Function>, i32 {
    $ctx.arena make Maybe<Function>.None Arena:push<Maybe<Function>> @slot
    loop {
        $ctx.functions.len $handle.module.index gt if { break }
        $ctx.arena $ctx.functions
        Array:new<Map<Array<TypeId>, .Maybe<Function>>>
        Array:push<Array<Map<Array<TypeId>, .Maybe<Function>>>>
    }
    $ctx.functions $handle.module.index Array:get<Array<Map<Array<TypeId>, .Maybe<Function>>>> @module-functions

    loop {
        $module-functions.len $handle.index gt if { break }
        $ctx.arena $module-functions
        \TypeIds-eq Map:new<Array<TypeId>, .Maybe<Function>>
        Array:push<Map<Array<TypeId>, .Maybe<Function>>>
    }
    $module-functions $handle.index Array:get<Map<Array<TypeId>, .Maybe<Function>>> @instances

    $instances.values.len
    $ctx.arena $instances $generic-arguments $slot Map:insert<Array<TypeId>, .Maybe<Function>> drop
    $slot flip
}
fn lookup-function(ctx: .Ctx, handle: Resolved:FunctionHandle, generic-arguments: .Array<TypeId>) -> Maybe<i32> { block {
    $ctx.functions.len $handle.module.index le if { make Maybe<i32>.None break }
    $ctx.functions $handle.module.index Array:get<Array<Map<Array<TypeId>, .Maybe<Function>>>> @module-functions

    $module-functions.len $handle.index le if { make Maybe<i32>.None break }
    $module-functions $handle.index Array:get<Map<Array<TypeId>, .Maybe<Function>>> @instances

    $instances $generic-arguments Map:get-index<Array<TypeId>, .Maybe<Function>>
} }
fn lookup-resolved-function(ctx: .Ctx, handle: Resolved:FunctionHandle) -> .Resolved:FunctionOrExtern {
    $ctx.resolved-modules $handle.module.index Array:get<Resolved:Module>
    .functions.values $handle.index Array:get<Resolved:FunctionOrExtern>
}
fn insert-into-function-table(ctx: .Ctx, handle: FunctionHandle) -> i32 {
    $ctx.function-table \FunctionHandle-eq  &handle Array:find<FunctionHandle, .FunctionHandle> if {
        // TODO: This should not be necessary
        @a $a
    } else {
        drop
        $ctx.function-table.len
        $ctx.arena $ctx.function-table $handle Array:push<FunctionHandle>
    }
}

struct PrimitiveTypes { a: Maybe<Key> b: Maybe<Key> c: Maybe<Key> }
global PRIMITIVE_TYPES: PrimitiveTypes

fn primitive-types() -> Array<Maybe<Key>> {
    uninit<PrimitiveTypes> @zeroed
    &zeroed !.i32 0 sizeof(PrimitiveTypes) mem-fill
    &PRIMITIVE_TYPES !.i32 &zeroed !.i32 sizeof(PrimitiveTypes) Core:bytes-eq if {
        make Type.Bool make Key.Other make Maybe<Key>.Some #PRIMITIVE_TYPES.a
        make Type.I32  make Key.Other make Maybe<Key>.Some #PRIMITIVE_TYPES.b
        make Type.I64  make Key.Other make Maybe<Key>.Some #PRIMITIVE_TYPES.c
    }
    &PRIMITIVE_TYPES.a sizeof(PrimitiveTypes) sizeof(Maybe<Key>) / Array:init-no-copy<Maybe<Key>>
}

fn Bool-id() -> TypeId { 0 make TypeId }
fn I32-id () -> TypeId { 1 make TypeId }
fn I64-id () -> TypeId { 2 make TypeId }


// =============================================================================
//  Type monomorphization procedures
// =============================================================================

struct CustomTypeKey {
    handle: Resolved:CustomTypeHandle
    generic-arguments: Array<TypeId>
    type: Maybe<Type>
}
fn CustomTypeKey-eq(a: .CustomTypeKey, b: .CustomTypeKey) -> bool {
    &a.handle &b.handle Resolved:CustomTypeHandle-eq
    \TypeId-eq &a.generic-arguments &b.generic-arguments Array:eq<TypeId> and
}
fn CustomTypeKey-format(fmt: .Formatter, self: .CustomTypeKey) {
    $fmt "(CustomTypeKey " Fmt:write
    &self.type match {
        case Some -> { $fmt flip Type-format }
        case None -> {
            $fmt &self.handle Resolved:CustomTypeHandle-format
            $fmt " " Fmt:write
            $fmt \TypeId-format &self.generic-arguments Array:format<TypeId>
        }
    }
    $fmt ")" Fmt:write
}
variant Key {
    case CustomType -> CustomTypeKey
    case Other -> Type
}
fn Key-type(self: .Key) -> .Type {
    $self match {
        case CustomType -> { .type Maybe:ref<Type> Maybe:assert-some<.Type> }
        case Other -> {}
    }
}

fn Key-eq(a: .Key, b: .Key) -> bool {
    $a match {
        case CustomType -> { $b match {
            case CustomType -> { CustomTypeKey-eq }
            case Other -> { drop drop 0 1 = }
        } }
        case Other -> { $b match {
            case Other -> { Type-eq }
            case CustomType -> { drop drop 0 1 = }
        } }
    }
}
fn Key-format(fmt: .Formatter, self: .Key) {
    $fmt $self match {
        case CustomType -> { CustomTypeKey-format }
        case Other -> { Type-format }
    }
}
fn MaybeKey-format(fmt: .Formatter, self: .Maybe<Key>) {
    $fmt \Key-format $self Maybe:format<Key>
}
fn monomize-type(ctx: .Ctx, type: .Resolved:Type, generic-arguments: .Array<TypeId>) -> TypeId { block {
    $type match {
        case Bool -> { Bool-id break }
        case I32 -> { I32-id break }
        case I64 -> { I64-id break }
        case Generic -> { .index ~ $generic-arguments flip Array:get<TypeId> ~ break }
        case _ -> { drop }
    }

    $ctx.types.len make TypeId @type-id
    $ctx.arena $ctx.types make Maybe<Key>.None Array:push<Maybe<Key>>

    $type match {
        case Ptr -> {
            $ctx flip ~ $generic-arguments monomize-type make Type.Ptr make Key.Other
        }
        case Tuple -> {
            $ctx flip .items.inner $generic-arguments monomize-types make Type.Tuple make Key.Other
        }
        case Fun -> {
            @fun-type
            $ctx &fun-type.parameters.inner $generic-arguments monomize-types
            $ctx &fun-type.returns   .inner $generic-arguments monomize-types
            make FunType make Type.Fun make Key.Other
        }
        case Custom -> {
            @custom-type
            $custom-type.type-definition 
            $ctx &custom-type.generic-arguments.inner $generic-arguments monomize-types
            make Maybe<Type>.None
            make CustomTypeKey make Key.CustomType
        }
        case _ -> { $ctx flip $generic-arguments monomize-type break }
    } @key
    2 Fmt:to-fd @fmt
    $ctx.types \cmp-perhaps-empty-type-slot &key Array:find<Maybe<Key>, .Key> if {
        $ctx.types.len $type-id.index 1 + = if {
            $ctx.types Array:pop<Maybe<Key>> assert-none<Key>
        }
        make TypeId
    } else {
        drop
        $ctx.types $type-id.index $key make Maybe<Key>.Some Array:set<Maybe<Key>> drop
        &key match {
            case CustomType -> {
                @key
                $type match {
                    case Custom -> {
                        $ctx flip &key.generic-arguments monomize-custom-type
                        make Type.Custom make Maybe<Type>.Some @type

                        $ctx.types $type-id.index Array:get<Maybe<Key>> Maybe:ref<Key> Maybe:assert-some<.Key> match {
                            case CustomType -> { .type $type store }
                            case _ -> { drop 0 0 / drop }
                        }
                    }
                    case _ -> { drop 0 0 / drop }
                }
            }
            case _ -> { drop }
        }
        $type-id
    }
} }

fn monomize-fun-type(ctx: .Ctx, fun-type: .Resolved:FunType, generic-arguments: .Array<TypeId>) -> TypeId {
    $fun-type ~ make Resolved:Type.Fun @type
    $ctx &type $generic-arguments monomize-type
}

fn cmp-perhaps-empty-type-slot(slot: .Maybe<Key>, type: .Key) -> bool {
    $slot match {
        case None -> { 0 1 = }
        case Some -> { $type Key-eq }
    }
}

fn monomize-types(ctx: .Ctx, types: .Array<Resolved:Type>, generic-arguments: .Array<TypeId>) -> Array<TypeId> { block {
    $ctx.arena $types.len Array:new-with-capacity<TypeId> @monomized
    loop {
        $monomized.len $types.len = if { $monomized break }
        &monomized
        $ctx $types $monomized.len Array:get<Resolved:Type> $generic-arguments monomize-type
        Array:push-assert-no-alloc<TypeId>
    }
} }

fn monomize-custom-type'(ctx: .Ctx, custom-type: .Resolved:CustomTypeType, generic-arguments: .Array<TypeId>) -> TypeId {
    $custom-type ~ make Resolved:Type.Custom @type
    $ctx &type $generic-arguments monomize-type
}
fn monomize-custom-type(
    ctx: .Ctx,
    custom-type: .Resolved:CustomTypeType,
    generic-arguments: .Array<TypeId>
) -> CustomTypeHandle {
    $ctx.resolved-modules $custom-type.type-definition.module.index Array:get<Resolved:Module> .custom-types.values
    $custom-type.type-definition.index Array:get<Resolved:CustomType> @resolved-custom-type

    $resolved-custom-type match {
        case Struct -> {
            @resolved-struct
            $resolved-struct.name
            $ctx &resolved-struct.fields $generic-arguments monomize-named-types @fields
            $fields
            make Struct make CustomType.Struct $ctx flip add-monomized-custom-type
        }
        case Variant -> {
            @resolved-variant
            $resolved-variant.name
            $ctx.arena $resolved-variant.cases.len Array:new-with-capacity<VariantCase> @monomized-cases
            loop {
                $monomized-cases.len $resolved-variant.cases.len = if { $monomized-cases break }
                &monomized-cases
                &resolved-variant.cases $monomized-cases.len Array:get<Resolved:VariantCase> @resolved-case
                $resolved-case.name
                &resolved-case.type match {
                    case None -> { make Maybe<TypeId>.None }
                    case Some -> {
                        $ctx flip $generic-arguments monomize-type make Maybe<TypeId>.Some
                    }
                }
                make VariantCase
                Array:push-assert-no-alloc<VariantCase>
            }
            make Variant make CustomType.Variant $ctx flip add-monomized-custom-type
        }
    }
}

fn add-monomized-custom-type(ctx: .Ctx, type: CustomType) -> CustomTypeHandle {
    &ctx.custom-types \CustomType-eq &type Array:find<CustomType, .CustomType> if {
        $ctx.module-id flip make CustomTypeHandle
    } else {
        drop
        $ctx.module-id $ctx.custom-types.len make CustomTypeHandle
        $ctx.arena &ctx.custom-types $type Array:push<CustomType>
    }
}

fn monomize-named-types(ctx: .Ctx, types: .Array<Resolved:NamedType>, generic-arguments: .Array<TypeId>) -> Array<NamedTypeId> {
    $ctx.arena $types.len Array:new-with-capacity<NamedTypeId> @monomized
    loop {
        $monomized.len $types.len = if { $monomized break }
        &monomized
        $ctx $types $monomized.len Array:get<Resolved:NamedType> $generic-arguments monomize-named-type
        Array:push-assert-no-alloc<NamedTypeId>
    }
}

fn monomize-named-type(ctx: .Ctx, type: .Resolved:NamedType, generic-arguments: .Array<TypeId>) -> NamedTypeId {
    $type.name
    $ctx &type.type $generic-arguments monomize-type
    make NamedTypeId
}


// =============================================================================
//  Top level monomorphization procedures
// =============================================================================

fn monomize(arena: .Arena, modules: .Map<ByteSlice, Resolved:Module>) -> Monomized {
    \ByteSlice:eq-by-ref Map:new<ByteSlice, Module> @monomized-modules
    Array:new<Array<Map<Array<TypeId>, .Maybe<Function>>>> @functions
    primitive-types @types
    Array:new<FunctionHandle> @function-table
    0 @i
    loop {
        $i $modules.values.len = if { break }
        &modules.values $i Array:get<Resolved:Module> @module
        make Ctx {
            $arena @arena
            $i make ModuleId @module-id
            &modules.values @resolved-modules
            &types @types
            &function-table @function-table
            Array:new<CustomType> @custom-types
            &functions @functions
        } @ctx
        $arena &monomized-modules
        &modules.keys $i Array:get<ByteSlice> ~
        make Module {
            &ctx &module.globals.values monomize-globals @globals
            &ctx &module.functions.values monomize-functions @externs
            $ctx.custom-types @custom-types
            $arena $module.static-data ByteSlice:copy @static-data
            Array:new<Array<.Function>> @functions
        }
        Map:insert<ByteSlice, Module> drop
        $i 1 + #i
    }
    0 @i
    loop {
        $i $monomized-modules.values.len = if { break }
        &monomized-modules.values $i Array:get<Module> .functions @module-functions

        $i $functions.len lt if {
            &monomized-modules.values $i Array:get<Module> .functions @module-functions
            &functions $i Array:get<Array<Map<Array<TypeId>, .Maybe<Function>>>> @functions

            0 @j
            loop {
                $functions.len $j = if { break }
                $functions $j Array:get<Map<Array<TypeId>, .Maybe<Function>>> .values @instances

                loop {
                    $module-functions.len $j gt if { break }
                    $arena $module-functions Array:new<.Function> Array:push<Array<.Function>>
                }
                $module-functions $j Array:get<Array<.Function>> @target

                0 @k
                loop {
                    $instances.len $k = if { break }

                    $arena $target
                    $instances $k Array:get<.Maybe<Function>> ~ Maybe:ref<Function> Maybe:assert-some<.Function>
                    Array:push<.Function>
                    $k 1 + #k
                }
                $j 1 + #j
            }
        }
        $i 1 + #i
    }
    $types $monomized-modules
    Logging:enabled if {
        2 "Calculating type sizes\n" IO:write-all IO:check
    }
    $arena &monomized-modules &types compute-sizes $function-table
    make Monomized
}

fn monomize-globals(ctx: .Ctx, globals: .Array<Resolved:Global>) -> Array<Global> {
    $ctx.arena $globals.len Array:new-with-capacity<Global> @monomized
    0 @i
    loop {
        $i $globals.len = if { $monomized break }
        $globals $i Array:get<Resolved:Global> @globl
        &monomized $ctx $globl monomize-globl Array:push-assert-no-alloc<Global>
        $i 1 + #i
    }
}

fn monomize-globl(ctx: .Ctx, globl: .Resolved:Global) -> Global {
    Array:new<TypeId> @generic-arguments
    $globl.name $ctx &globl.type &generic-arguments monomize-type $globl.reffed make Global
}

fn monomize-extrn(ctx: .Ctx, extrn: .Resolved:Extern) -> Extern {
    Array:new<TypeId> @generic-arguments
    make Extern {
        $extrn.name @name
        $extrn.extrn-module @extrn-module
        $extrn.extrn-name @extrn-name
        $ctx &extrn.signature &generic-arguments monomize-signature @signature
    }
}

fn monomize-function(ctx: .Ctx, function: .Resolved:Function, generic-arguments: .Array<TypeId>) -> Function {
    $function.name $function.export
    $ctx &function.signature $generic-arguments monomize-signature
    $ctx &function.words $generic-arguments monomize-words
    make Function
}

fn monomize-functions(ctx: .Ctx, functions: .Array<Resolved:FunctionOrExtern>) -> Array<Extern> {
    Array:new<Extern> @monomized-externs
    0 @i
    loop {
        $i $functions.len = if { $monomized-externs break }
        $functions $i Array:get<Resolved:FunctionOrExtern>
        match {
            case Extern -> { $ctx flip monomize-extrn $ctx.arena flip &monomized-externs flip Array:push<Extern>   }
            case Function -> {
                @function
                &function.export Maybe:is-some<Token> if {
                    Array:new<TypeId> @generic-arguments
                    $ctx.module-id $i make Resolved:FunctionHandle @handle
                    $ctx $handle $generic-arguments pre-insert-function drop @slot
                    $ctx $function &generic-arguments monomize-function make Maybe<Function>.Some =>slot
                }
            }
        }
        $i 1 + #i
    }
}

fn monomize-signature(ctx: .Ctx, extrn: .Resolved:Signature, generic-arguments: .Array<TypeId>) -> Signature {
    make Signature {
        $ctx &extrn.parameters    $generic-arguments monomize-named-types @parameters
        $ctx &extrn.returns.inner $generic-arguments monomize-types       @returns
    }
}


// =============================================================================
//  Compute size of all types after monomorphization.
// =============================================================================

fn compute-sizes(arena: .Arena, modules: .Map<ByteSlice, Module>, types: .Array<Maybe<Key>>) -> Array<i32> {
    $arena $types.len Arena:alloc-many<i32> $types.len Array:init-no-copy<i32> @sizes
    $sizes.ptr 255 $types.len sizeof(i32) * mem-fill
    0 @i
    loop {
        $i $types.len = if { $sizes break }
        $modules &sizes $types $i compute-size
        $i 1 + #i
    }
}

fn compute-size(modules: .Map<ByteSlice, Module>, sizes: .Array<i32>, types: .Array<Maybe<Key>>, index: i32) {
    $sizes $index Array:get<i32> ~ 0 not = if {
        $types $index Array:get<Maybe<Key>> match {
            case None -> { 0 not 1 - }
            case Some -> {
                Key-type match {
                    case Ptr -> { drop 4 }
                    case Bool -> { 4 }
                    case I32 -> { 4 }
                    case I64 -> { 8 }
                    case Custom -> {
                        @handle
                        $modules $sizes $types
                        &modules.values $handle.module.index Array:get<Module> .custom-types
                        $handle.index Array:get<CustomType> compute-custom-type-size
                    }
                    case Tuple -> {
                        @items 0 @size 0 @i
                        loop {
                            $i $items.len = if { $size break }
                            $modules $sizes $types $items $i Array:get<TypeId> ~ compute-typeid-size $size + #size
                            $i 1 + #i
                        }
                    }
                    case Fun -> { drop 4 }
                }
            }
        } @size
        $sizes $index $size Array:set<i32> drop
    }
}

fn compute-typeid-size(modules: .Map<ByteSlice, Module>, sizes: .Array<i32>, types: .Array<Maybe<Key>>, type: TypeId) -> i32 {
    $sizes $type.index Array:get<i32> ~ @size
    $size 0 not = if {
        $modules $sizes $types $type.index compute-size
        $modules $sizes $types $type compute-typeid-size
    } else {
        $size
    }
}

fn compute-custom-type-size(modules: .Map<ByteSlice, Module>, sizes: .Array<i32>, types: .Array<Maybe<Key>>, type: .CustomType) -> i32 {
    $modules $sizes $types $type match {
        case Struct -> { compute-struc-size }
        case Variant -> { compute-varint-size }
    }
}

fn compute-struc-size(modules: .Map<ByteSlice, Module>, sizes: .Array<i32>, types: .Array<Maybe<Key>>, struc: .Struct) -> i32 {
    0 @size
    0 @i
    loop {
        $i $struc.fields.len = if { $size break }
        $modules $sizes $types
        &struc.fields $i Array:get<NamedTypeId> .type ~ compute-typeid-size
        $size + #size
        $i 1 + #i
    }
}

fn compute-varint-size(modules: .Map<ByteSlice, Module>, sizes: .Array<i32>, types: .Array<Maybe<Key>>, varint: .Variant) -> i32 {
    0 @size
    0 @i
    loop {
        $i $varint.cases.len = if { $size 4 + break }
        &varint.cases $i Array:get<VariantCase> .type match {
            case None -> { 0 }
            case Some -> { ~ $modules flip $sizes flip $types flip compute-typeid-size }
        } $size Core:max #size
        $i 1 + #i
    }
}


// =============================================================================
//  Monomorphized Words
// =============================================================================

struct GetLocal {
    name: Token
    var: VarId
    fields: Array<FieldAccess>
    result-taip: TypeId
}
fn GetLocal-format(fmt: .Formatter, self: .GetLocal) {
    $fmt "(GetLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt &self.result-taip TypeId-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt ")" Fmt:write
}

struct SetLocal {
    name: Token
    var: VarId
    fields: Array<FieldAccess>
}
fn SetLocal-format(fmt: .Formatter, self: .SetLocal) {
    $fmt "(SetLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt ")" Fmt:write
}

struct RefLocal {
    name: Token
    var: VarId
    fields: Array<FieldAccess>
}
fn RefLocal-format(fmt: .Formatter, self: .RefLocal) {
    $fmt "(RefLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt ")" Fmt:write
}

struct StoreLocal {
    name: Token
    var: VarId
    fields: Array<FieldAccess>
}
fn StoreLocal-format(fmt: .Formatter, self: .StoreLocal) {
    $fmt "(StoreLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt ")" Fmt:write
}

struct InitLocal {
    name: Token
    type: TypeId
    local: LocalId
}
fn InitLocal-format(fmt: .Formatter, self: .InitLocal) {
    $fmt "(InitLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt &self.local LocalId-format
    $fmt ")" Fmt:write
}

struct GetField {
    token: Token
    fields: Array<FieldAccess>
    on-ptr: bool
}
fn GetField-format(fmt: .Formatter, self: .GetField) {
    $fmt "(GetField " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format<FieldAccess>
    $fmt " " Fmt:write
    $fmt $self.on-ptr bool-format
    $fmt ")" Fmt:write
}

struct FieldAccess {
    name: Token
    source-taip: TypeId
    target-taip: TypeId
    field-index: i32
}
fn FieldAccess-format(fmt: .Formatter, self: .FieldAccess) {
    $fmt "(FieldAccess " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.source-taip TypeId-format
    $fmt " " Fmt:write
    $fmt &self.target-taip TypeId-format
    $fmt " " Fmt:write
    $fmt $self.field-index i32-format
    $fmt ")" Fmt:write
}

struct Cast {
    token: Token
    src: TypeId
    dst: TypeId
}
fn Cast-format(fmt: .Formatter, self: .Cast) {
    $fmt "(Cast " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.src TypeId-format
    $fmt " " Fmt:write
    $fmt &self.dst TypeId-format
    $fmt ")" Fmt:write
}

struct Call {
    name: Token
    function: FunctionHandle
}
fn Call-format(fmt: .Formatter, self: .Call) {
    $fmt "(Call " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.function FunctionHandle-format
    $fmt ")" Fmt:write
}

variant Intrinsic {
    case Gt -> TypeId
    case Lt -> TypeId
    case Add -> TypeId
    case Sub -> TypeId
    case Mul -> TypeId
    case Div -> TypeId
    case Mod -> TypeId
    case Eq -> TypeId
    case NotEq -> TypeId
    case MemGrow
    case MemCopy
    case MemFill
    case Store8
    case Load8
    case Rotl -> TypeId
    case Rotr -> TypeId
    case And -> TypeId
    case Or -> TypeId
    case Ge -> TypeId
    case Le -> TypeId
    case Not -> TypeId
    case Store -> TypeId
    case SetStackSize
}
fn Intrinsic-format(fmt: .Formatter, self: .Intrinsic) {
    $self match {
        case Gt -> { $fmt "(Gt " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Lt -> { $fmt "(Lt " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Add -> { $fmt "(Add " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Sub -> { $fmt "(Sub " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Mul -> { $fmt "(Mul " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Div -> { $fmt "(Div " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Mod -> { $fmt "(Mod " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Eq -> { $fmt "(Eq " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case NotEq -> { $fmt "(NotEq " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case MemGrow -> { $fmt "MemGrow" Fmt:write }
        case MemCopy -> { $fmt "MemCopy" Fmt:write }
        case MemFill -> { $fmt "MemFill" Fmt:write }
        case Store8 -> { $fmt "Store8" Fmt:write }
        case Load8 -> { $fmt "Load8" Fmt:write }
        case Rotl -> { $fmt "(Rotl " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Rotr -> { $fmt "(Rotr " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case And -> { $fmt "(And " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Or -> { $fmt "(Or " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Ge -> { $fmt "(Ge " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Le -> { $fmt "(Le " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Not -> { $fmt "(Not " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case Store -> { $fmt "(Store " Fmt:write $fmt flip TypeId-format $fmt ")" Fmt:write }
        case SetStackSize -> { $fmt "SetStackSize" Fmt:write }
    }
}

struct IntrinsicWord {
    token: Token
    intrinsic: Intrinsic
}
fn IntrinsicWord-format(fmt: .Formatter, self: .IntrinsicWord) {
    $fmt "(Intrinsic " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.intrinsic Intrinsic-format
    $fmt ")" Fmt:write
}

struct If {
    token: Token
    parameters: Array<TypeId>
    returns: Maybe<Array<TypeId>>
    true-words: Array<Word>
    false-words: Array<Word>
}
fn If-format(fmt: .Formatter, self: .If) {
    $fmt "(If\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt &self.parameters TypeIds-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt \TypeIds-format &self.returns Maybe:format<Array<TypeId>>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "true-words=" Fmt:write
    $fmt \Word-format &self.true-words Array:format-multi-line<Word>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "false-words=" Fmt:write
    $fmt \Word-format &self.false-words Array:format-multi-line<Word>
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct Loop {
    token: Token
    parameters: Array<TypeId>
    returns: Maybe<Array<TypeId>>
    words: Array<Word>
}
fn Loop-format(fmt: .Formatter, self: .Loop) {
    $fmt "(Loop\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt &self.parameters TypeIds-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt \TypeIds-format &self.returns Maybe:format<Array<TypeId>>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "words=" Fmt:write
    $fmt \Word-format &self.words Array:format-multi-line<Word>
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct Block {
    token: Token
    parameters: Array<TypeId>
    returns: Array<TypeId>
    words: Array<Word>
}
fn Block-format(fmt: .Formatter, self: .Block) {
    $fmt "(Block\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "token=" Fmt:write
    $fmt &self.token Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt &self.parameters TypeIds-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt &self.returns TypeIds-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "words=" Fmt:write
    $fmt \Word-format &self.words Array:format-multi-line<Word>
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct MatchCase {
    type: Maybe<TypeId>
    tag: i32
    words: Array<Word>
}
fn MatchCase-format(fmt: .Formatter, self: .MatchCase) {
    $fmt "(MatchCase " Fmt:write
    $fmt \TypeId-format &self.type Maybe:format<TypeId>
    $fmt " " Fmt:write
    $fmt $self.tag i32-format
    $fmt " " Fmt:write
    $fmt \Word-format &self.words Array:format-multi-line<Word>
    $fmt ")" Fmt:write
}
struct Match {
    type: TypeId
    by-ref: bool
    cases: Array<MatchCase>
    default: Maybe<Array<Word>>
    parameters: Array<TypeId>
    returns: Array<TypeId>
}
fn Match-format(fmt: .Formatter, self: .Match) {
    $fmt "(Match\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "type=" Fmt:write
    $fmt &self.type TypeId-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "by-ref=" Fmt:write
    $fmt $self.by-ref bool-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "cases=" Fmt:write
    $fmt \MatchCase-format &self.cases Array:format-multi-line<MatchCase>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "default=" Fmt:write
    $fmt \Words-format &self.default Maybe:format<Array<Word>>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "parameters=" Fmt:write
    $fmt &self.parameters TypeIds-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "returns=" Fmt:write
    $fmt &self.returns TypeIds-format
    $fmt ")" Fmt:write
    $fmt Fmt:dedent
}

struct StructWordNamed {
    type: TypeId
    words: Array<Word>
}
fn StructWordNamed-format(fmt: .Formatter, self: .StructWordNamed) {
    $fmt "(StructWordNamed " Fmt:write
    $fmt &self.type TypeId-format
    $fmt " " Fmt:write
    $fmt &self.words Words-format
    $fmt ")" Fmt:write
}


struct VariantWord {
    tag: i32
    type: TypeId
}
fn VariantWord-format(fmt: .Formatter, self: .VariantWord) {
    $fmt "(VariantWord " Fmt:write
    $fmt $self.tag i32-format
    $fmt " " Fmt:write
    $fmt &self.type TypeId-format
    $fmt ")" Fmt:write
}

struct FunRef {
    call: Call
    table-index: i32
}
fn FunRef-format(fmt: .Formatter, self: .FunRef) {
    $fmt "(FunRef " Fmt:write
    $fmt &self.call Call-format
    $fmt " " Fmt:write
    $fmt $self.table-index i32-format
    $fmt ")" Fmt:write
}

variant Word {
    case Number -> Token
    case String -> StringWord
    case GetLocal -> GetLocal
    case InitLocal -> InitLocal
    case SetLocal -> SetLocal
    case RefLocal -> RefLocal
    case StoreLocal -> StoreLocal
    case Cast -> Cast
    case Call -> Call
    case Intrinsic -> IntrinsicWord
    case Todo -> .Resolved:Word
    case Drop -> Token
    case If -> If
    case Loop -> Loop
    case Flip -> Token
    case Break -> Token
    case Block -> Block
    case Sizeof -> TypeId
    case Uninit -> TypeId
    case FieldInit -> TypeId
    case Load -> TypeId
    case MakeTuple -> Array<TypeId>
    case UnpackTuple -> Array<TypeId>
    case IndirectCall -> TypeId
    case GetField -> GetField
    case FunRef -> FunRef
    case Match -> Match
    case Struct -> TypeId
    case StructNamed -> StructWordNamed
    case Variant -> VariantWord
}
fn Word-format(fmt: .Formatter, self: .Word) { block {
    $fmt $self match {
        case Number -> { $fmt "(Number " Fmt:write Token-format $fmt ")" }
        case String -> { StringWord-format break }
        case GetLocal -> { GetLocal-format break }
        case InitLocal -> { InitLocal-format break }
        case SetLocal -> { SetLocal-format break }
        case RefLocal -> { RefLocal-format break }
        case StoreLocal -> { StoreLocal-format break }
        case Cast -> { Cast-format break }
        case Call -> { Call-format break }
        case Intrinsic -> { IntrinsicWord-format break }
        case Drop -> { $fmt "(Drop " Fmt:write Token-format $fmt ")" }
        case Flip -> { $fmt "(Flip " Fmt:write Token-format $fmt ")" }
        case Break -> { $fmt "(Break " Fmt:write Token-format $fmt ")" }
        case If -> { If-format break }
        case Loop -> { Loop-format break }
        case Block -> { Block-format break }
        case Sizeof -> { $fmt "(Sizeof " Fmt:write TypeId-format $fmt ")" }
        case Uninit -> { $fmt "(Uninit " Fmt:write TypeId-format $fmt ")" }
        case FieldInit -> { $fmt "(FieldInit " Fmt:write TypeId-format $fmt ")" }
        case Load -> { $fmt "(Load " Fmt:write TypeId-format $fmt ")" }
        case MakeTuple -> { $fmt "(MakeTuple " Fmt:write TypeIds-format $fmt ")" }
        case UnpackTuple -> { $fmt "(UnpackTuple " Fmt:write TypeIds-format $fmt ")" }
        case IndirectCall -> { $fmt "(IndirectCall " Fmt:write TypeId-format $fmt ")" }
        case GetField -> { GetField-format break }
        case FunRef -> { FunRef-format break }
        case Match -> { Match-format break }
        case Struct -> { $fmt "(Struct " Fmt:write TypeId-format $fmt ")" }
        case StructNamed -> { StructWordNamed-format break }
        case Variant -> { VariantWord-format break }
        case Todo -> {
            $fmt "(Todo" Fmt:write
            drop // $fmt flip ~ Resolved:Word-format
            ")"
        }
    } Fmt:write
} }
fn Words-format(fmt: .Formatter, self: .Array<Word>) {
    $fmt \Word-format $self Array:format-multi-line<Word>
}


// =============================================================================
//  Word monomorphization procedures
// =============================================================================

fn monomize-cast(ctx: .Ctx, word: .Resolved:Cast, generic-arguments: .Array<TypeId>) -> Word {
    $word.token
    $ctx &word.src $generic-arguments monomize-type
    $ctx &word.dst $generic-arguments monomize-type
    make Cast make Word.Cast
}

fn monomize-get-locl(ctx: .Ctx, word: .Resolved:GetLocal, generic-arguments: .Array<TypeId>) -> Word {
    make GetLocal {
        $word.name @name
        $word.var @var
        $ctx &word.var-type $generic-arguments monomize-type @var-type
        $ctx &word.fields $generic-arguments monomize-field-accesses @fields
        $ctx &word.result-taip $generic-arguments monomize-type @result-taip
    }
    make Word.GetLocal
}
fn monomize-set-locl(ctx: .Ctx, word: .Resolved:SetLocal, generic-arguments: .Array<TypeId>) -> Word {
    make SetLocal {
        $word.name @name
        $word.var @var
        $ctx &word.fields $generic-arguments monomize-field-accesses @fields
    }
    make Word.SetLocal
}

fn monomize-field-accesses(ctx: .Ctx, fields: .Array<Resolved:FieldAccess>, generic-arguments: .Array<TypeId>) -> Array<FieldAccess> {
    $ctx.arena $fields.len Array:new-with-capacity<FieldAccess> @monomized
    loop {
        $monomized.len $fields.len = if { $monomized break }
        &monomized
        $ctx
        $fields $fields.len 1 - Array:get<Resolved:FieldAccess>
        $generic-arguments monomize-field-access
        Array:push-assert-no-alloc<FieldAccess>
    }
}
fn monomize-field-access(ctx: .Ctx, field: .Resolved:FieldAccess, generic-arguments: .Array<TypeId>) -> FieldAccess {
    make FieldAccess {
        $field.name @name
        $ctx &field.source-taip $generic-arguments monomize-type @source-taip
        $ctx &field.target-taip $generic-arguments monomize-type @target-taip
        $field.field-index @field-index
    }
}

fn monomize-call(ctx: .Ctx, call: .Resolved:Call, generic-arguments: .Array<TypeId>) -> Call { block {
    $ctx &call.generic-arguments.inner $generic-arguments monomize-types @generic-arguments-of-this-call

    $ctx $call.function lookup-resolved-function match {
        case Extern -> {
            drop
            make Call {
                $call.name @name
                $call.function.module $call.function.index 0
                make FunctionHandle @function
                0 @instance-id
            }
        }
        case Function -> {
            $ctx $call.function $generic-arguments lookup-function match {
                case Some -> { flip drop }
                case None -> {
                    $ctx $call.function $generic-arguments-of-this-call pre-insert-function @instance @slot
                    $ctx flip &generic-arguments-of-this-call monomize-function make Maybe<Function>.Some =>slot
                    $instance
                }
            } @instance
            make Call {
                $call.name @name
                $call.function.module $call.function.index $instance
                make FunctionHandle @function
            }
        }
    }
} }

fn monomize-intrinsic(ctx: .Ctx, word: .Resolved:IntrinsicWord, generic-arguments: .Array<TypeId>) -> Word {
    $word.token
    $ctx &word.intrinsic match {
        case Gt -> { $generic-arguments monomize-type make Intrinsic.Gt }
        case Lt -> { $generic-arguments monomize-type make Intrinsic.Lt }
        case Add -> { $generic-arguments monomize-type make Intrinsic.Add }
        case Sub -> { $generic-arguments monomize-type make Intrinsic.Sub }
        case Mul -> { $generic-arguments monomize-type make Intrinsic.Mul }
        case Div -> { $generic-arguments monomize-type make Intrinsic.Div }
        case Mod -> { $generic-arguments monomize-type make Intrinsic.Mod }
        case Eq -> { $generic-arguments monomize-type make Intrinsic.Eq }
        case NotEq -> { $generic-arguments monomize-type make Intrinsic.NotEq }
        case MemGrow -> { drop make Intrinsic.MemGrow }
        case MemCopy -> { drop make Intrinsic.MemCopy }
        case MemFill -> { drop make Intrinsic.MemFill }
        case Store8 -> { drop make Intrinsic.Store8 }
        case Load8 -> { drop make Intrinsic.Load8 }
        case Rotl -> { $generic-arguments monomize-type make Intrinsic.Rotl }
        case Rotr -> { $generic-arguments monomize-type make Intrinsic.Rotr }
        case And -> { $generic-arguments monomize-type make Intrinsic.And }
        case Or -> { $generic-arguments monomize-type make Intrinsic.Or }
        case Ge -> { $generic-arguments monomize-type make Intrinsic.Ge }
        case Le -> { $generic-arguments monomize-type make Intrinsic.Le }
        case Not -> { $generic-arguments monomize-type make Intrinsic.Not }
        case Store -> { $generic-arguments monomize-type make Intrinsic.Store }
        case SetStackSize -> { drop make Intrinsic.SetStackSize }
    } make IntrinsicWord make Word.Intrinsic
}

fn monomize-init-locl(ctx: .Ctx, word: .Resolved:InitLocal, generic-arguments: .Array<TypeId>) -> Word {
    $word.name
    $ctx &word.type $generic-arguments monomize-type
    $word.local
    make InitLocal make Word.InitLocal
}

fn monomize-ref-locl(ctx: .Ctx, word: .Resolved:RefLocal, generic-arguments: .Array<TypeId>) -> Word {
    $word.name
    $word.var
    $ctx &word.fields $generic-arguments monomize-field-accesses
    make RefLocal make Word.RefLocal
}

fn monomize-store-locl(ctx: .Ctx, word: .Resolved:StoreLocal, generic-arguments: .Array<TypeId>) -> Word {
    $word.name
    $word.var
    $ctx &word.fields $generic-arguments monomize-field-accesses
    make StoreLocal make Word.StoreLocal
}

fn monomize-iff(ctx: .Ctx, word: .Resolved:If, generic-arguments: .Array<TypeId>) -> Word {
    $word.token
    $ctx &word.parameters.inner $generic-arguments monomize-types
    &word.returns match {
        case None -> { make Maybe<Array<TypeId>>.None }
        case Some -> { .inner $ctx flip $generic-arguments monomize-types make Maybe<Array<TypeId>>.Some }
    }
    $ctx &word.true-words  $generic-arguments monomize-words
    $ctx &word.false-words $generic-arguments monomize-words
    make If make Word.If
}

fn monomize-lop(ctx: .Ctx, word: .Resolved:Loop, generic-arguments: .Array<TypeId>) -> Word {
    $word.token
    $ctx &word.parameters.inner $generic-arguments monomize-types
    &word.returns match {
        case None -> { make Maybe<Array<TypeId>>.None }
        case Some -> { .inner $ctx flip $generic-arguments monomize-types make Maybe<Array<TypeId>>.Some }
    }
    $ctx &word.words  $generic-arguments monomize-words
    make Loop make Word.Loop
}

fn monomize-blok(ctx: .Ctx, word: .Resolved:Block, generic-arguments: .Array<TypeId>) -> Word {
    $word.token
    $ctx &word.parameters.inner $generic-arguments monomize-types
    $ctx &word.returns.inner $generic-arguments monomize-types
    $ctx &word.words  $generic-arguments monomize-words
    make Block make Word.Block
}

fn monomize-sizeof(ctx: .Ctx, word: .Resolved:Sizeof, generic-arguments: .Array<TypeId>) -> Word {
    $ctx &word.type $generic-arguments monomize-type make Word.Sizeof
}

fn monomize-uninit(ctx: .Ctx, word: .Resolved:Uninit, generic-arguments: .Array<TypeId>) -> Word {
    $ctx &word.type $generic-arguments monomize-type make Word.Uninit
}

fn monomize-field-init(ctx: .Ctx, word: .Resolved:FieldInit, generic-arguments: .Array<TypeId>) -> Word {
    $ctx &word.type $generic-arguments monomize-type make Word.FieldInit
}

fn monomize-load(ctx: .Ctx, word: .Resolved:Load, generic-arguments: .Array<TypeId>) -> Word {
    $ctx &word.type $generic-arguments monomize-type make Word.Load
}

fn monomize-get-field(ctx: .Ctx, word: .Resolved:GetField, generic-arguments: .Array<TypeId>) -> Word {
    $word.token
    $ctx &word.fields $generic-arguments monomize-field-accesses
    $word.on-ptr
    make GetField make Word.GetField
}

fn monomize-matsh-cays(ctx: .Ctx, cays: .Resolved:MatchCase, generic-arguments: .Array<TypeId>) -> MatchCase {
    &cays.type match {
        case None -> { make Maybe<TypeId>.None }
        case Some -> { $ctx flip $generic-arguments monomize-type make Maybe<TypeId>.Some }
    }
    $cays.tag
    $ctx &cays.words $generic-arguments monomize-words
    make MatchCase
}

fn monomize-matsh-cases(ctx: .Ctx, cases: .Array<Resolved:MatchCase>, generic-arguments: .Array<TypeId>) -> Array<MatchCase> {
    $ctx.arena $cases.len Array:new-with-capacity<MatchCase> @monomized
    loop {
        $monomized.len $cases.len = if { $monomized break }
        &monomized
        $ctx $cases $monomized.len Array:get<Resolved:MatchCase> $generic-arguments monomize-matsh-cays
        Array:push-assert-no-alloc<MatchCase>
    }
}

fn monomize-matsh(ctx: .Ctx, word: .Resolved:Match, generic-arguments: .Array<TypeId>) -> Word {
    make Match {
        $ctx &word.cases $generic-arguments monomize-matsh-cases @cases
        $word.by-ref @by-ref
        $ctx &word.varint $generic-arguments monomize-custom-type' @type
        &word.default match {
            case None -> { make Maybe<Array<Word>>.None }
            case Some -> { $ctx flip $generic-arguments monomize-words make Maybe<Array<Word>>.Some }
        } @default
        $ctx &word.parameters.inner $generic-arguments monomize-types @parameters
        $ctx &word.returns.inner    $generic-arguments monomize-types @returns
    } make Word.Match
}

fn monomize-struc-word(ctx: .Ctx, word: .Resolved:StructWord, generic-arguments: .Array<TypeId>) -> Word {
    $ctx &word.type $generic-arguments monomize-custom-type' make Word.Struct
}

fn monomize-struc-word-named(ctx: .Ctx, word: .Resolved:StructWordNamed, generic-arguments: .Array<TypeId>) -> Word {
    $ctx &word.type $generic-arguments monomize-custom-type'
    $ctx &word.words $generic-arguments monomize-words
    make StructWordNamed make Word.StructNamed
}

fn monomize-varint-word(ctx: .Ctx, word: .Resolved:VariantWord, generic-arguments: .Array<TypeId>) -> Word {
    $word.tag
    $ctx &word.type $generic-arguments monomize-custom-type'
    make VariantWord make Word.Variant
}

fn monomize-fun-ref(ctx: .Ctx, word: .Resolved:FunRef, generic-arguments: .Array<TypeId>) -> Word {
    $ctx &word.call $generic-arguments monomize-call @call
    $call
    $ctx $call.function insert-into-function-table
    make FunRef make Word.FunRef
}

fn monomize-word(ctx: .Ctx, word: .Resolved:Word, generic-arguments: .Array<TypeId>) -> Word {
    $ctx $word match {
        case Number -> { flip drop ~ make Word.Number }
        case String -> { flip drop ~ make Word.String }
        case GetLocal -> { $generic-arguments monomize-get-locl }
        case InitLocal -> { $generic-arguments monomize-init-locl }
        case RefLocal -> { $generic-arguments monomize-ref-locl }
        case SetLocal -> { $generic-arguments monomize-set-locl }
        case StoreLocal -> { $generic-arguments monomize-store-locl }
        case Cast -> { $generic-arguments monomize-cast }
        case Call -> { $generic-arguments monomize-call make Word.Call }
        case Intrinsic -> { $generic-arguments monomize-intrinsic }
        case Drop -> { flip drop ~ make Word.Drop }
        case If -> { $generic-arguments monomize-iff }
        case Loop -> { $generic-arguments monomize-lop }
        case Block -> { $generic-arguments monomize-blok }
        case Sizeof -> { $generic-arguments monomize-sizeof }
        case Flip -> { flip drop ~ make Word.Flip }
        case Uninit -> { $generic-arguments monomize-uninit }
        case FieldInit -> { $generic-arguments monomize-field-init }
        case Load -> { $generic-arguments monomize-load }
        case MakeTuple -> { .items.inner $generic-arguments monomize-types make Word.MakeTuple }
        case UnpackTuple -> { .items.inner $generic-arguments monomize-types make Word.UnpackTuple }
        case IndirectCall -> { .type $generic-arguments monomize-fun-type make Word.IndirectCall }
        case Break -> { flip drop ~ make Word.Break }
        case GetField -> { $generic-arguments monomize-get-field }
        case FunRef -> { $generic-arguments monomize-fun-ref }
        case Match -> { $generic-arguments monomize-matsh }
        case StructWord -> { $generic-arguments monomize-struc-word }
        case StructWordNamed -> { $generic-arguments monomize-struc-word-named }
        case VariantWord -> { $generic-arguments monomize-varint-word }
    }
}
fn monomize-words(ctx: .Ctx, words: .Array<Resolved:Word>, generic-arguments: .Array<TypeId>) -> Array<Word> {
    Array:new<Word> @monomized
    loop {
        $monomized.len $words.len = if { $monomized break }
        $ctx.arena &monomized
        $ctx $words $monomized.len Array:get<Resolved:Word> $generic-arguments monomize-word
        Array:push<Word>
    }
}
