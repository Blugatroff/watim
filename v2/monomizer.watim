import "../std/core.watim" as Core
import "../std/maybe.watim" as Maybe (Maybe, assert-none, assert-some)
import "../std/result.watim" as Result (Result)
import "../std/result.watim" as Result (Result)
import "../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../std/arena.watim" as Arena (Arena)
import "../std/array.watim" as Array (Array)
import "../std/map.watim" as Map (Map)
import "../std/fmt.watim" as Fmt (Formatter, ByteSlice-format)
import "../std/util.watim" as Util (i32-format)

import "./lexer.watim" as Lexer (Token, Token-format)
import "./type.watim" as Resolved (ModuleId, ModuleId-format, CustomTypeHandle, CustomTypeHandle-eq, CustomTypeHandle-format)
import "./resolver.watim" as Resolved (
    StringWord, StringWord-format,
    VarId, VarId-format,
    FunctionHandle, FunctionHandle-format, FunctionHandle-eq
)

struct TypeId {
    index: i32
}
fn TypeId-eq(a: .TypeId, b: .TypeId) -> bool {
    $a.index $b.index =
}
fn TypeId-format(fmt: .Formatter, self: .TypeId) {
    $fmt "(TypeId " Fmt:write
    $fmt $self.index i32-format
    $fmt ")" Fmt:write
}

struct NamedTypeId {
    name: Token
    type: TypeId
}
fn NamedTypeId-eq(a: .NamedTypeId, b: .NamedTypeId) -> bool {
    &a.type &b.type TypeId-eq
}
fn NamedTypeId-format(fmt: .Formatter, self: .NamedTypeId) {
    $fmt "(NamedTypeId " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type TypeId-format
    $fmt ")" Fmt:write
}

struct FunType {
    parameters: Array<TypeId>
    returns: Array<TypeId>
}
fn FunType-format(fmt: .Formatter, self: .FunType) {
    $fmt "(FunType " Fmt:write
    $fmt \TypeId-format &self.parameters Array:format<TypeId>
    $fmt " " Fmt:write
    $fmt \TypeId-format &self.returns Array:format<TypeId>
    $fmt ")" Fmt:write
}

variant Type {
    case Bool
    case I32
    case I64
    case Ptr -> TypeId
    case Custom -> CustomTypeHandle
    case Fun -> FunType
    case Tuple -> Array<TypeId>
}
fn Type-eq(a: .Type, b: .Type) -> bool { block {
    $a !.i32 ~ $b !.i32 ~ /= if { // compare tags
        0 1 = break
    }
    $a match {
        case Ptr -> { $b match {
            case Ptr -> { flip TypeId-eq }
            case _ -> { drop drop 0 1 = }
        } }
        case Custom -> { $b match {
            case Custom -> { flip CustomTypeHandle-eq }
            case _ -> { drop drop 0 1 = }
        } }
        case Fun -> { @a $b match {
            case Fun -> {
                @b
                \TypeId-eq &a.parameters &b.parameters Array:eq<TypeId>
                \TypeId-eq &a.returns    &b.returns    Array:eq<TypeId> and
            }
            case _ -> { drop 0 1 = }
        } }
        case Tuple -> { \TypeId-eq flip $b match {
            case Tuple -> { Array:eq<TypeId> }
            case _ -> { drop drop drop 0 1 = }
        } }
        case _ -> { drop 1 1 = }
    }
} }
fn Type-format(fmt: .Formatter, self: .Type) { block {
    $fmt $self match {
        case Bool -> { "Bool" }
        case I32 -> { "I32" }
        case I64 -> { "I64" }
        case Ptr -> { $fmt "(Ptr " Fmt:write TypeId-format $fmt ")" Fmt:write break }
        case Custom -> {
            @handle
            "(CustomType " Fmt:write
            $fmt $handle.module.index i32-format
            $fmt " " Fmt:write
            $fmt $handle.index i32-format
            $fmt ")" Fmt:write break
        }
        case Fun -> { FunType-format break }
        case Tuple -> { \TypeId-format flip Array:format<TypeId> break }
    } Fmt:write
} }
fn MaybeType-format(fmt: .Formatter, self: .Maybe<Type>) {
    $fmt \Type-format $self Maybe:format<Type>
}

variant CustomType {
    case Struct -> Struct
    case Variant -> Variant
}
fn CustomType-eq(a: .CustomType, b: .CustomType) -> bool {
    $a match {
        case Struct -> { $b match {
            case Struct -> { Struct-eq }
            case _ -> { drop drop 0 1 = }
        } }
        case Variant -> { $b match {
            case Variant -> { Variant-eq }
            case _ -> { drop drop 0 1 = }
        } }
    }
}
fn CustomType-format(fmt: .Formatter, self: .CustomType) {
    $fmt $self match {
        case Struct -> { Struct-format }
        case Variant -> { Variant-format }
    }
}

struct Struct {
    name: Token
    fields: Array<NamedTypeId>
}
fn Struct-eq(a: .Struct, b: .Struct) -> bool {
    \NamedTypeId-eq &a.fields &b.fields Array:eq<NamedTypeId>
}
fn Struct-format(fmt: .Formatter, self: .Struct) {
    $fmt "(Struct\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "fields=" Fmt:write
    $fmt \NamedTypeId-format &self.fields Array:format-multi-line<NamedTypeId>
    $fmt Fmt:dedent
}

struct VariantCase {
    name: Token
    type: Maybe<TypeId>
}
fn VariantCase-eq(a: .VariantCase, b: .VariantCase) -> bool {
    &a.type match {
        case None -> { &b.type match {
            case None -> { 1 1 = }
            case Some -> { drop 0 1 = }
        } }
        case Some -> { &b.type match {
            case Some -> { TypeId-eq }
            case None -> { drop 0 1 = }
        } }
    }
}
fn VariantCase-format(fmt: .Formatter, self: .VariantCase) {
    $fmt "(VariantCase " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt \TypeId-format &self.type Maybe:format<TypeId>
    $fmt ")" Fmt:write
}

struct Variant {
    name: Token
    cases: Array<VariantCase>
}
fn Variant-eq(a: .Variant, b: .Variant) -> bool {
    \VariantCase-eq &a.cases &b.cases Array:eq<VariantCase>
}
fn Variant-format(fmt: .Formatter, self: .Variant) {
    $fmt "(Variant\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "cases=" Fmt:write
    $fmt \VariantCase-format &self.cases Array:format-multi-line<VariantCase>
    $fmt Fmt:dedent
}

struct Module {
    custom-types: Array<CustomType>
    globals: Array<Global>
    externs: Array<Extern>
}
fn Module-format(fmt: .Formatter, self: .Module) {
    $fmt "(Module\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "custom-types=" Fmt:write
    $fmt \CustomType-format &self.custom-types Array:format-multi-line<CustomType>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "globals=" Fmt:write
    $fmt \Global-format &self.globals Array:format-multi-line<Global>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "externs=" Fmt:write
    $fmt \Extern-format &self.externs Array:format-multi-line<Extern>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

struct Monomized {
    types: Array<Maybe<Type>>
    modules: Map<ByteSlice, Module>
    functions: Map<FunctionHandle, Map<Array<TypeId>, Function>>
}
fn TypeIds-format(fmt: .Formatter, self: .Array<TypeId>) {
    $fmt \TypeId-format $self Array:format<TypeId>
}
fn format-function-map(fmt: .Formatter, self: .Map<Array<TypeId>, Function>) {
    $fmt \TypeIds-format \Function-format $self Map:format-multi-line<Array<TypeId>, Function>
}
fn Monomized-format(fmt: .Formatter, self: .Monomized) {
    $fmt "(Monomized\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "types=" Fmt:write
    $fmt \MaybeType-format &self.types Array:format-multi-line<Maybe<Type>>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "modules=" Fmt:write
    $fmt \ByteSlice-format \Module-format &self.modules Map:format-multi-line<ByteSlice, Module>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "functions=" Fmt:write
    $fmt \ModuleId-format \format-function-map &self.functions Map:format-multi-line<ModuleId, Map<Array<TypeId>, Function>>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

struct Global {
    name: Token
    type: TypeId
}
fn Global-format(fmt: .Formatter, self: .Global) {
    $fmt "(Global " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.type TypeId-format
    $fmt ")" Fmt:write
}

fn TypeIds-eq(a: .Array<TypeId>, b: .Array<TypeId>) -> bool {
    \TypeId-eq $a $b Array:eq<TypeId>
}

struct Ctx {
    arena: .Arena
    module-id: ModuleId
    resolved-modules: .Array<Resolved:Module>
    types: .Array<Maybe<Type>>
    custom-types: Array<CustomType>
    type-monomize-cache: .Map<Resolved:Type, TypeId>
    functions: .Map<FunctionHandle, Map<Array<TypeId>, Function>>
}
fn insert-function(ctx: .Ctx, handle: FunctionHandle, generic-arguments: Array<TypeId>, function: Function) -> i32 {
    $ctx.functions &handle Map:get<FunctionHandle, Map<Array<TypeId>, Function>> match {
        case None -> {
            $ctx.arena $ctx.functions $handle
            \TypeIds-eq Map:new<Array<TypeId>, Function>
            Map:insert<FunctionHandle, Map<Array<TypeId>, Function>> drop
            $ctx $handle $generic-arguments $function insert-function
        }
        case Some -> {
            @instances
            $instances.values.len
            $ctx.arena $instances $generic-arguments $function Map:insert<Array<TypeId>, Function> drop
        }
    }
}
fn lookup-function(ctx: .Ctx, handle: FunctionHandle, generic-arguments: .Array<TypeId>) -> Maybe<.Function> {
    $ctx.functions &handle Map:get<FunctionHandle, Map<Array<TypeId>, Function>> match {
        case None -> { make Maybe<.Function>.None }
        case Some -> { $generic-arguments Map:get<Array<TypeId>, Function> }
    }
}
fn lookup-resolved-function(ctx: .Ctx, handle: FunctionHandle) -> .Resolved:FunctionOrExtern {
    $ctx.resolved-modules $handle.module.index Array:get<Resolved:Module>
    .functions.values $handle.index Array:get<Resolved:FunctionOrExtern>
}

struct PrimitiveTypes { a: Maybe<Type> b: Maybe<Type> c: Maybe<Type> }
global PRIMITIVE_TYPES: PrimitiveTypes

fn primitive-types() -> Array<Maybe<Type>> {
    uninit<PrimitiveTypes> @zeroed
    &zeroed !.i32 0 sizeof(PrimitiveTypes) mem-fill
    &PRIMITIVE_TYPES !.i32 &zeroed !.i32 sizeof(PrimitiveTypes) Core:bytes-eq if {
        make Type.Bool make Maybe<Type>.Some #PRIMITIVE_TYPES.a
        make Type.I32  make Maybe<Type>.Some #PRIMITIVE_TYPES.b
        make Type.I64  make Maybe<Type>.Some #PRIMITIVE_TYPES.c
    }
    &PRIMITIVE_TYPES.a sizeof(PrimitiveTypes) sizeof(Maybe<Type>) / Array:init-no-copy<Maybe<Type>>
}

fn Bool-id() -> TypeId { 0 make TypeId }
fn I32-id () -> TypeId { 1 make TypeId }
fn I64-id () -> TypeId { 2 make TypeId }

fn monomize(arena: .Arena, modules: .Map<ByteSlice, Resolved:Module>) -> Monomized {
    \Resolved:Type-eq Map:new<Resolved:Type, TypeId> @type-monomize-cache
    \ByteSlice:eq-by-ref Map:new<ByteSlice, Module> @monomized-modules
    \FunctionHandle-eq Map:new<FunctionHandle, Map<Array<TypeId>, Function>> @functions
    primitive-types @types
    0 @i
    loop {
        $i $modules.values.len = if { break }
        &modules.values $i Array:get<Resolved:Module> @module
        make Ctx {
            $arena @arena
            $i make ModuleId @module-id
            &modules.values @resolved-modules
            &types @types
            &type-monomize-cache @type-monomize-cache
            Array:new<CustomType> @custom-types
            &functions @functions
        } @ctx
        $arena &monomized-modules
        &modules.keys $i Array:get<ByteSlice> ~
        make Module {
            &ctx &module.globals.values monomize-globals @globals
            &ctx &module.functions.values monomize-functions @externs
            $ctx.custom-types @custom-types
        }
        Map:insert<ByteSlice, Module> drop
        $i 1 + #i
    }
    $types $monomized-modules $functions make Monomized
}

fn monomize-globals(ctx: .Ctx, globals: .Array<Resolved:Global>) -> Array<Global> {
    $ctx.arena $globals.len Array:new-with-capacity<Global> @monomized
    0 @i
    loop {
        $i $globals.len = if { $monomized break }
        $globals $i Array:get<Resolved:Global> @globl
        &monomized $ctx $globl monomize-globl Array:push-assert-no-alloc<Global>
        $i 1 + #i
    }
}

fn monomize-globl(ctx: .Ctx, globl: .Resolved:Global) -> Global {
    Array:new<TypeId> @generic-arguments
    $globl.name $ctx &globl.type &generic-arguments monomize-type' make Global
}

struct Extern {
    name: Token
    extrn-module: ByteSlice
    extrn-name: ByteSlice
    signature: Signature
}
fn Extern-format(fmt: .Formatter, self: .Extern) {
    $fmt "(Extern\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "extrn-module=" Fmt:write
    $fmt &self.extrn-module ByteSlice-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "extrn-name=" Fmt:write
    $fmt &self.extrn-name ByteSlice-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "signature=" Fmt:write
    $fmt &self.signature Signature-format
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

fn monomize-extrn(ctx: .Ctx, extrn: .Resolved:Extern) -> Extern {
    Array:new<TypeId> @generic-arguments
    make Extern {
        $extrn.name @name
        $extrn.extrn-module @extrn-module
        $extrn.extrn-name @extrn-name
        $ctx &extrn.signature &generic-arguments monomize-signature @signature
    }
}

struct FieldAccess {
    name: Token
    source-taip: TypeId
    target-taip: TypeId
    field-index: i32
}
fn FieldAccess-format(fmt: .Formatter, self: .FieldAccess) {
    $fmt "(FieldAccess " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.source-taip TypeId-format
    $fmt " " Fmt:write
    $fmt &self.target-taip TypeId-format
    $fmt " " Fmt:write
    $fmt $self.field-index i32-format
    $fmt ")" Fmt:write
}

struct GetLocal {
    name: Token
    var: VarId
    fields: Array<FieldAccess>
    result-taip: TypeId
}
fn GetLocal-format(fmt: .Formatter, self: .GetLocal) {
    $fmt "(GetLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt &self.result-taip TypeId-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt ")" Fmt:write
}

struct SetLocal {
    name: Token
    var: VarId
    fields: Array<FieldAccess>
}
fn SetLocal-format(fmt: .Formatter, self: .SetLocal) {
    $fmt "(SetLocal " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.var VarId-format
    $fmt " " Fmt:write
    $fmt \FieldAccess-format &self.fields Array:format-multi-line<FieldAccess>
    $fmt ")" Fmt:write
}

struct Cast {
    token: Token
    src: TypeId
    dst: TypeId
}
fn Cast-format(fmt: .Formatter, self: .Cast) {
    $fmt "(Cast " Fmt:write
    $fmt &self.token Token-format
    $fmt " " Fmt:write
    $fmt &self.src TypeId-format
    $fmt " " Fmt:write
    $fmt &self.dst TypeId-format
    $fmt ")" Fmt:write
}

struct Call {
    name: Token
    function: FunctionHandle
    instance-id: i32
}
fn Call-format(fmt: .Formatter, self: .Call) {
    $fmt "(Call " Fmt:write
    $fmt &self.name Token-format
    $fmt " " Fmt:write
    $fmt &self.function FunctionHandle-format
    $fmt " " Fmt:write
    $fmt $self.instance-id i32-format
    $fmt ")" Fmt:write
}

variant Word {
    case Number -> Token
    case String -> StringWord
    case GetLocal -> GetLocal
    case SetLocal -> SetLocal
    case Cast -> Cast
    case Call -> Call
    case Todo -> .Resolved:Word
}
fn Word-format(fmt: .Formatter, self: .Word) { block {
    $fmt $self match {
        case Number -> { $fmt "(Number " Fmt:write Token-format $fmt ")" }
        case String -> { StringWord-format break }
        case GetLocal -> { GetLocal-format break }
        case SetLocal -> { SetLocal-format break }
        case Cast -> { Cast-format break }
        case Call -> { Call-format break }
        case Todo -> {
            $fmt "(Todo" Fmt:write
            drop // $fmt flip ~ Resolved:Word-format
            ")"
        }
    } Fmt:write
} }

fn monomize-cast(ctx: .Ctx, word: .Resolved:Cast, generic-arguments: .Array<TypeId>) -> Word {
    $word.token
    $ctx &word.src $generic-arguments monomize-type'
    $ctx &word.dst $generic-arguments monomize-type'
    make Cast make Word.Cast
}

fn monomize-get-locl(ctx: .Ctx, word: .Resolved:GetLocal, generic-arguments: .Array<TypeId>) -> Word {
    make GetLocal {
        $word.name @name
        $word.var @var
        $ctx &word.var-type $generic-arguments monomize-type' @var-type
        $ctx &word.fields $generic-arguments monomize-field-accesses @fields
        $ctx &word.result-taip $generic-arguments monomize-type' @result-taip
    }
    make Word.GetLocal
}
fn monomize-get-locl(ctx: .Ctx, word: .Resolved:SetLocal, generic-arguments: .Array<TypeId>) -> Word {
    make SetLocal {
        $word.name @name
        $word.var @var
        $ctx &word.fields $generic-arguments monomize-field-accesses @fields
    }
    make Word.SetLocal
}

fn monomize-field-accesses(ctx: .Ctx, fields: .Array<Resolved:FieldAccess>, generic-arguments: .Array<TypeId>) -> Array<FieldAccess> {
    $ctx.arena $fields.len Array:new-with-capacity<FieldAccess> @monomized
    loop {
        $monomized.len $fields.len = if { $monomized break }
        &monomized
        $ctx
        $fields $fields.len 1 - Array:get<Resolved:FieldAccess>
        $generic-arguments monomize-field-access
        Array:push-assert-no-alloc<FieldAccess>
    }
}
fn monomize-field-access(ctx: .Ctx, field: .Resolved:FieldAccess, generic-arguments: .Array<TypeId>) -> FieldAccess {
    make FieldAccess {
        $field.name @name
        $ctx &field.source-taip $generic-arguments monomize-type' @source-taip
        $ctx &field.target-taip $generic-arguments monomize-type' @target-taip
        $field.field-index @field-index
    }
}

fn monomize-call(ctx: .Ctx, call: .Resolved:Call, generic-arguments: .Array<TypeId>) -> Word { block {
    $ctx &call.generic-arguments.inner $generic-arguments monomize-types' @generic-arguments-of-this-call

    $ctx $call.function lookup-resolved-function match {
        case Extern -> {
            drop
            make Call {
                $call.name @name
                $call.function @function
                0 @instance-id
            } make Word.Call
        }
        case Function -> {
            $ctx flip &generic-arguments-of-this-call monomize-function @function
            $ctx $call.function $generic-arguments-of-this-call $function insert-function @instance
            make Call {
                $call.name @name
                $call.function @function
                $instance @instance-id
            } make Word.Call
        }
    }
} }

fn monomize-word(ctx: .Ctx, word: .Resolved:Word, generic-arguments: .Array<TypeId>) -> Word {
    $word match {
        case Number -> { ~ make Word.Number }
        case String -> { ~ make Word.String }
        case GetLocal -> { $ctx flip $generic-arguments monomize-get-locl }
        case Cast -> { $ctx flip $generic-arguments monomize-cast }
        case Call -> { $ctx flip $generic-arguments monomize-call }
        case _ -> {
            make Word.Todo
        }
    }
}
fn monomize-words(ctx: .Ctx, words: .Array<Resolved:Word>, generic-arguments: .Array<TypeId>) -> Array<Word> {
    Array:new<Word> @monomized
    loop {
        $monomized.len $words.len = if { $monomized break }
        $ctx.arena &monomized
        $ctx $words $monomized.len Array:get<Resolved:Word> $generic-arguments monomize-word
        Array:push<Word>
    }
}

struct Function {
    name: Token
    export: Maybe<Token>
    signature: Signature
    words: Array<Word>
}
fn Function-format(fmt: .Formatter, self: .Function) {
    $fmt "(Function\n" Fmt:write
    $fmt Fmt:indent
    $fmt Fmt:write-indent
    $fmt "name=" Fmt:write
    $fmt &self.name Token-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "export=" Fmt:write
    $fmt \Token-format &self.export Maybe:format<Token>
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "signature=" Fmt:write
    $fmt &self.signature Signature-format
    $fmt ",\n" Fmt:write
    $fmt Fmt:write-indent
    $fmt "words=" Fmt:write
    $fmt \Word-format &self.words Array:format-multi-line<Word>
    $fmt Fmt:dedent
    $fmt ")" Fmt:write
}

fn monomize-function(ctx: .Ctx, function: .Resolved:Function, generic-arguments: .Array<TypeId>) -> Function {
    $function.name $function.export
    $ctx &function.signature $generic-arguments monomize-signature
    $ctx &function.words $generic-arguments monomize-words
    make Function
}

fn monomize-functions(ctx: .Ctx, functions: .Array<Resolved:FunctionOrExtern>) -> Array<Extern> {
    Array:new<Extern> @monomized-externs
    0 @i
    loop {
        $i $functions.len = if { $monomized-externs break }
        $functions $i Array:get<Resolved:FunctionOrExtern>
        match {
            case Extern -> { $ctx flip monomize-extrn $ctx.arena flip &monomized-externs flip Array:push<Extern>   }
            case Function -> {
                @function
                &function.export Maybe:is-some<Token> if {
                    Array:new<TypeId> @generic-arguments
                    $ctx $function &generic-arguments monomize-function @function
                    $ctx.module-id $i make FunctionHandle @handle
                    $ctx $handle $generic-arguments $function insert-function drop
                }
            }
        }
        $i 1 + #i
    }
}

struct Signature {
    parameters: Array<NamedTypeId>
    returns: Array<TypeId>
}
fn Signature-format(fmt: .Formatter, self: .Signature) {
    $fmt "(Signature " Fmt:write
    $fmt \NamedTypeId-format &self.parameters Array:format-multi-line<NamedTypeId>
    $fmt " " Fmt:write
    $fmt \TypeId-format &self.returns Array:format-multi-line<TypeId>
    $fmt ")" Fmt:write
}

fn monomize-signature(ctx: .Ctx, extrn: .Resolved:Signature, generic-arguments: .Array<TypeId>) -> Signature {
    make Signature {
        $ctx &extrn.parameters    $generic-arguments monomize-named-types' @parameters
        $ctx &extrn.returns.inner $generic-arguments monomize-types'       @returns
    }
}

fn compare-stack-key(a: .[.Resolved:Type, .Array<TypeId>], b: .[.Resolved:Type, .Array<TypeId>]) -> bool {
    $a ~ [,] @a-gen-args @a-type
    $b ~ [,] @b-gen-args @b-type
    \TypeId-eq $a-gen-args $b-gen-args Array:eq<TypeId>
    $a-type $b-type Resolved:Type-eq and
}
fn monomize-type'(ctx: .Ctx, type: .Resolved:Type, generic-arguments: .Array<TypeId>) -> TypeId {
    \compare-stack-key Map:new<[.Resolved:Type, .Array<TypeId>], TypeId> @stack
    $ctx $type $generic-arguments &stack monomize-type
}
fn monomize-type(ctx: .Ctx, type: .Resolved:Type, generic-arguments: .Array<TypeId>, stack: .Map<[.Resolved:Type, .Array<TypeId>], TypeId>) -> TypeId { block {
    $type match {
        case Bool -> { Bool-id break }
        case I32 -> { I32-id break }
        case I64 -> { I64-id break }
        case Generic -> { .index ~ $generic-arguments flip Array:get<TypeId> ~ break }
        case _ -> { drop }
    }
    $stack $type $generic-arguments [,2] @key &key Map:get<[.Resolved:Type, .Array<TypeId>], TypeId> match {
        case Some -> { ~ break }
        case None -> {}
    }
    $ctx.type-monomize-cache $type Map:get<Resolved:Type, TypeId> match {
        case None -> {}
        case Some -> { ~ break }
    }
    $ctx.types.len make TypeId @type-id
    $ctx.arena $ctx.types make Maybe<Type>.None Array:push<Maybe<Type>>
    $ctx.arena &stack.keys $type $generic-arguments [,2] Array:push<[.Resolved:Type, .Array<TypeId>]>
    $ctx.arena &stack.values $type-id Array:push<TypeId>
    $type match {
        case Ptr -> {
            $ctx flip ~ $generic-arguments $stack monomize-type make Type.Ptr
        }
        case Tuple -> {
            $ctx flip .items.inner $generic-arguments $stack monomize-types make Type.Tuple
        }
        case Fun -> {
            @fun-type
            $ctx &fun-type.parameters.inner $generic-arguments $stack monomize-types
            $ctx &fun-type.returns   .inner $generic-arguments $stack monomize-types
            make FunType make Type.Fun
        }
        case Custom -> {
            $ctx flip $generic-arguments $stack monomize-custom-type make Type.Custom
        }
        case _ -> { $ctx flip $generic-arguments $stack monomize-type break }
    } @monomized-type
    $ctx.types \cmp-perhaps-empty-type-slot &monomized-type Array:find<Maybe<Type>, .Type> if {
        $ctx.types.len $type-id.index 1 + = if {
            $ctx.types Array:pop<Maybe<Type>> assert-none<Type>
        }
        make TypeId
    } else {
        drop
        $ctx.types $type-id.index $monomized-type make Maybe<Type>.Some Array:set<Maybe<Type>> drop
        $ctx.arena $ctx.type-monomize-cache $type ~ $type-id Map:insert<Resolved:Type, TypeId> drop
        $type-id
    }
    &stack.keys Array:pop<[.Resolved:Type, .Array<TypeId>]> drop
    &stack.values Array:pop<TypeId> drop
} }

fn cmp-perhaps-empty-type-slot(slot: .Maybe<Type>, type: .Type) -> bool {
    $slot match {
        case None -> { 0 1 = }
        case Some -> { $type Type-eq }
    }
}

fn monomize-types'(ctx: .Ctx, types: .Array<Resolved:Type>, generic-arguments: .Array<TypeId>) -> Array<TypeId> {
    \compare-stack-key Map:new<[.Resolved:Type, .Array<TypeId>], TypeId> @stack
    $ctx $types $generic-arguments &stack monomize-types
}

fn monomize-types(ctx: .Ctx, types: .Array<Resolved:Type>, generic-arguments: .Array<TypeId>, stack: .Map<[.Resolved:Type, .Array<TypeId>], TypeId>) -> Array<TypeId> { block {
    $ctx.arena $types.len Array:new-with-capacity<TypeId> @monomized
    loop {
        $monomized.len $types.len = if { $monomized break }
        &monomized
        $ctx $types $monomized.len Array:get<Resolved:Type> $generic-arguments $stack monomize-type
        Array:push-assert-no-alloc<TypeId>
    }
} }

fn monomize-custom-type(ctx: .Ctx, custom-type: .Resolved:CustomTypeType, generic-arguments: .Array<TypeId>, stack: .Map<[.Resolved:Type, .Array<TypeId>], TypeId>) -> CustomTypeHandle {
    $ctx &custom-type.generic-arguments.inner $generic-arguments $stack monomize-types @generic-arguments-for-custom-type

    $ctx.resolved-modules $custom-type.type-definition.module.index Array:get<Resolved:Module> .custom-types.values
    $custom-type.type-definition.index Array:get<Resolved:CustomType> @resolved-custom-type

    $resolved-custom-type match {
        case Struct -> {
            @resolved-struct
            $resolved-struct.name
            $ctx &resolved-struct.fields &generic-arguments-for-custom-type $stack monomize-named-types
            make Struct make CustomType.Struct $ctx flip add-monomized-custom-type
        }
        case Variant -> {
            @resolved-variant
            $resolved-variant.name
            $ctx.arena $resolved-variant.cases.len Array:new-with-capacity<VariantCase> @monomized-cases
            loop {
                $monomized-cases.len $resolved-variant.cases.len = if { $monomized-cases break }
                &monomized-cases
                &resolved-variant.cases $monomized-cases.len Array:get<Resolved:VariantCase> @resolved-case
                $resolved-case.name
                &resolved-case.type match {
                    case None -> { make Maybe<TypeId>.None }
                    case Some -> {
                        $ctx flip &generic-arguments-for-custom-type $stack monomize-type make Maybe<TypeId>.Some
                    }
                }
                make VariantCase
                Array:push-assert-no-alloc<VariantCase>
            }
            make Variant make CustomType.Variant $ctx flip add-monomized-custom-type
        }
    }
}

fn add-monomized-custom-type(ctx: .Ctx, type: CustomType) -> CustomTypeHandle {
    &ctx.custom-types \CustomType-eq &type Array:find<CustomType, .CustomType> if {
        $ctx.module-id flip make CustomTypeHandle
    } else {
        drop
        $ctx.module-id $ctx.custom-types.len make CustomTypeHandle
        $ctx.arena &ctx.custom-types $type Array:push<CustomType>
    }
}

fn monomize-named-types'(ctx: .Ctx, types: .Array<Resolved:NamedType>, generic-arguments: .Array<TypeId>) -> Array<NamedTypeId> {
    \compare-stack-key Map:new<[.Resolved:Type, .Array<TypeId>], TypeId> @stack
    $ctx $types $generic-arguments &stack monomize-named-types
}

fn monomize-named-types(ctx: .Ctx, types: .Array<Resolved:NamedType>, generic-arguments: .Array<TypeId>, stack: .Map<[.Resolved:Type, .Array<TypeId>], TypeId>) -> Array<NamedTypeId> {
    $ctx.arena $types.len Array:new-with-capacity<NamedTypeId> @monomized
    loop {
        $monomized.len $types.len = if { $monomized break }
        &monomized
        $ctx $types $monomized.len Array:get<Resolved:NamedType> $generic-arguments $stack monomize-named-type
        Array:push-assert-no-alloc<NamedTypeId>
    }
}

fn monomize-named-type(ctx: .Ctx, type: .Resolved:NamedType, generic-arguments: .Array<TypeId>, stack: .Map<[.Resolved:Type, .Array<TypeId>], TypeId>) -> NamedTypeId {
    $type.name
    $ctx &type.type $generic-arguments $stack monomize-type
    make NamedTypeId
}

