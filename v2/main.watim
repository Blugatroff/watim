import "../std/core.watim" as CORE
import "../std/arena.watim" as A
import "../std/args.watim" as ARGS
import "../std/array.watim" as Array
import "../std/io.watim" as IO
import "../std/fs.watim" as FS
import "../std/byte-array.watim" as ByteArray
import "../std/byte-slice.watim" as ByteSlice
import "../std/page-alloc.watim" as PA

import "./lexer.watim" as Lexer
import "./parser.watim" as Parser

fn print-stdout(ptr: .i32, len: i32) {
    1 $ptr $len IO:write-all IO:check
}

fn main "_start" () {
    "Main" A:new @arena
    &arena ARGS:get-args @args
    $args.len 1 le if {
        2 "expected file arg" IO:write-all IO:check
        1 CORE:exit
    }
    &args 1 Array:get<ByteSlice:T> @file-path

    "Files" A:new @files-arena
    &files-arena FS:init IO:check @fs
    &files-arena &fs $file-path ~ ByteSlice:unpack FS:read-file IO:check @file-content

    &file-content ByteArray:to-slice @file-content
    "Tokens" A:new @tokens-arena
    &tokens-arena &file-content Lexer:lex @tokens
    &files-arena A:shred

    2 "tokens-arena usage: " IO:write-all IO:check
    2 &tokens-arena A:usage IO:print IO:check
    2 IO:newline

    // 1 \Lexer:Token-write &tokens Array:print<Lexer:Token> IO:check 2 IO:newline
    // 1 CORE:exit

    "Ast" A:new @ast-arena
    &ast-arena $file-path ~ &tokens Parser:parse @parsed-module

    1 &parsed-module Parser:ParsedModule-write IO:check 2 IO:newline
    2 "ast-arena usage: " IO:write-all IO:check
    2 &ast-arena A:usage IO:print IO:check
    2 IO:newline

    1 1 = if {
        2 "Used " IO:write-all IO:check
        2 0 mem-grow IO:print IO:check
        2 " 64KiB pages of memory = " IO:write-all IO:check
        2 0 mem-grow PA:page-size * 1 20 rotl 1 - + 1 20 rotl / IO:print IO:check
        2 "MiB\n" IO:write-all IO:check
    }
}

