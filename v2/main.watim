import "../std/core.watim" as Core
import "../std/option.watim" as Option (Option, or-default)
import "../std/arena.watim" as Arena (Arena)
import "../std/args.watim" as Args
import "../std/array.watim" as Array (Array)
import "../std/io.watim" as IO
import "../std/fs.watim" as FS
import "../std/bytes.watim" as Bytes
import "../std/byte-array.watim" as ByteArray
import "../std/byte-slice.watim" as ByteSlice (ByteSlice)
import "../std/page-alloc.watim" as PA

import "./logging.watim" as Logging
import "./lexer.watim" as Lexer
import "./parser.watim" as Parser (parse, ParseError-print)

fn print-usage-and-exit() {
    2 "The native Watim compiler\n\n" IO:write-all IO:check
    2 "Usage: watim <watim-source-file>\n" IO:write-all IO:check
    2 "Commands:\n" IO:write-all IO:check
    2 "  lex   [path]   Lex watim code and print the Tokens.\n" IO:write-all IO:check
    2 "  parse [path]   Parse watim code and print the AST\n" IO:write-all IO:check
    2 "Options:\n" IO:write-all IO:check
    2 "  -q, --quiet  Don't print any logs to stderr\n" IO:write-all IO:check
    1 Core:exit
}

fn find-flag(args: .Array<ByteSlice>, ptr: .i32, len: i32) -> bool {
    $ptr $len make ByteSlice @str
    $args \ByteSlice:eq-by-ref &str Array:find<ByteSlice, .ByteSlice> if {
        $args flip Array:remove<ByteSlice> drop
        1 1 =
    } else { 
        drop
        0 1 =
    }
}

variant CliCommand {
    case Lex -> Option<ByteSlice>
    case Parse -> Option<ByteSlice>
}
struct CliArgs {
    command: CliCommand
    quiet: bool
}

fn parse-args(arena: .Arena) -> CliArgs {
    $arena Args:get-args @args
    $args.len 1 le if {
        print-usage-and-exit
    }
    block {
        &args 1 Array:remove<ByteSlice> @command
        $args.len 1 gt if {
            &args 1 Array:remove<ByteSlice> make Option<ByteSlice>.Some
        } else { make Option<ByteSlice>.None } @path
        $command ByteSlice:unpack "lex" Bytes:eq if {
            $path make CliCommand.Lex break
        }
        $command ByteSlice:unpack "parse" Bytes:eq if {
            $path make CliCommand.Parse break
        }
        print-usage-and-exit loop { }
    }
    &args "-q" find-flag &args "--quiet" find-flag or
    make CliArgs
}

fn main "_start" () {
    Arena:init-temp
    "Main" Arena:new @arena

    &arena parse-args @args
    $args.quiet Logging:set

    "Files" Arena:new @files-arena
    &files-arena FS:init IO:check @fs

    $args.command match {
        case Lex -> { "-" make ByteSlice or-default<ByteSlice> }
        case Parse -> { "-" make ByteSlice or-default<ByteSlice> }
    } @file-path

    $file-path ByteSlice:unpack "-" Bytes:eq if {
        &files-arena 0 FS:read-all IO:check
    } else {
        &files-arena &fs $file-path ByteSlice:unpack FS:read-file IO:check
    } @file-content
    &file-content ByteArray:to-slice @file-content

    "Lexer" Arena:new @lexer-arena
    &lexer-arena &file-content Lexer:lex @tokens
    &files-arena Arena:shred
    "Tokens" Arena:new @tokens-arena
    &tokens-arena &tokens Lexer:Tokens-copy @tokens
    &lexer-arena Arena:shred

    &args.command match {
        case Lex -> {
            drop
            0 @i
            loop {
                $tokens.len $i = if { break }
                1 &tokens $i Array:get<Lexer:Token> Lexer:Token-print IO:check
                1 IO:newline
                $i 1 + #i
            }
            Logging:enabled if {
                2 "tokens-arena usage: " IO:write-all IO:check
                2 &tokens-arena Arena:usage IO:print IO:check
                2 IO:newline
            }
        }
        case Parse -> {
            drop
            &arena $tokens parse match {
                case Error -> {
                    2 flip $file-path ByteSlice:unpack ParseError-print drop
                    2 IO:newline
                    1 Core:exit
                }
                case Success -> {
                    .len
                    2 "Successfully parsed " IO:write-all IO:check
                    2 flip IO:print IO:check
                    2 " TopItems\n" IO:write-all IO:check
                }
            }
        }
    }
    exit
}

fn exit() {
    Logging:enabled if {
        2 "Used " IO:write-all IO:check
        2 0 mem-grow IO:print IO:check
        2 " 64KiB pages of memory = " IO:write-all IO:check
        2 0 mem-grow PA:page-size * 1 20 rotl 1 - + 1 20 rotl / IO:print IO:check
        2 "MiB\n" IO:write-all IO:check
    }
    0 Core:exit
}

